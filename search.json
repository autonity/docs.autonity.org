[
  {
    "objectID": "concepts/accountability/index.html",
    "href": "concepts/accountability/index.html",
    "title": "Accountability and fault detection (AFD)",
    "section": "",
    "text": "This section describes the Autonity accountability and fault detection protocol, the role of validators in submitting and verifying accountability event proofs (fault, accusation, innocence), the lifecycle for fault accountability and detection, and slashing.\n    Autonity implements an accountability and fault detection (AFD) protocol for detecting infractions of consensus rules by validators participating in consensus as consensus committee members. Consensus rules govern committee behavior while participating in block proposal and voting. Failure to adhere to these rules is a rule infraction.\n    Proven rule infractions are reported as faults and slashing makes faults accountable. Faults are detected by validators and submitted on chain as accountability events providing proof of misbehavior. Proofs are derived from cryptographically signed messages broadcast between committee members during Tendermint consensus rounds as validators propose, prevote, and precommit blocks (see the concept description Consensus round and internal state). The proofs are then submitted on-chain to the Accountability Contract.\n    It is important to note that AFD runs alongside Autonity’s Tendermint proof of stake consensus implementation and is fully automated: accountability events are generated and processed by protocol; no manual intervention by validator operators is required.\n    AFD functions by submitting, verifying, and processing accountability event proofs for Rule infractions by epoch. There are two ways for Rule infractions to be created.\n    Rule infractions can be directly submitted as a fault proof by a reporting validator.\n    Rule infractions can also be promoted from accusations. In this case, the Rule infraction is reported as an accusation, submitted by a reporting validator against an offending validator. An accusation may be defended by an innocence proof submitted by the offending validator within a proof submission window measured in blocks. If not defended against, the accusation may be promoted to a fault by the protocol once the innocence window has expired.\n    Slashing penalties are computed by protocol and applied for proven faults at epoch end. The penalty amount is computed based on a base slashing rate and slashing factors including the total number of slashable offences committed in the epoch (collusion) and the individual offending validator’s own slashing history.\n    Slashing is applied as part of the state finalization function. As the last block of an epoch is finalized, the Autonity contract will: apply accountability for faults to offending validators, slashing self-bonded and delegated stake according to Autonity’s Penalty-Absorbing Stake (PAS) model.\n    Rewards are paid for reporting a slashable fault at epoch end. The offending_ validator’s_ share of the epoch’s staking rewards is forfeited and paid to the reporting validator treasury account for distribution along with the staking rewards at epoch end.\n    \n    \n    To participate in AFD a validator must be a consensus committee member."
  },
  {
    "objectID": "concepts/accountability/index.html#overview",
    "href": "concepts/accountability/index.html#overview",
    "title": "Accountability and fault detection (AFD)",
    "section": "",
    "text": "This section describes the Autonity accountability and fault detection protocol, the role of validators in submitting and verifying accountability event proofs (fault, accusation, innocence), the lifecycle for fault accountability and detection, and slashing.\n    Autonity implements an accountability and fault detection (AFD) protocol for detecting infractions of consensus rules by validators participating in consensus as consensus committee members. Consensus rules govern committee behavior while participating in block proposal and voting. Failure to adhere to these rules is a rule infraction.\n    Proven rule infractions are reported as faults and slashing makes faults accountable. Faults are detected by validators and submitted on chain as accountability events providing proof of misbehavior. Proofs are derived from cryptographically signed messages broadcast between committee members during Tendermint consensus rounds as validators propose, prevote, and precommit blocks (see the concept description Consensus round and internal state). The proofs are then submitted on-chain to the Accountability Contract.\n    It is important to note that AFD runs alongside Autonity’s Tendermint proof of stake consensus implementation and is fully automated: accountability events are generated and processed by protocol; no manual intervention by validator operators is required.\n    AFD functions by submitting, verifying, and processing accountability event proofs for Rule infractions by epoch. There are two ways for Rule infractions to be created.\n    Rule infractions can be directly submitted as a fault proof by a reporting validator.\n    Rule infractions can also be promoted from accusations. In this case, the Rule infraction is reported as an accusation, submitted by a reporting validator against an offending validator. An accusation may be defended by an innocence proof submitted by the offending validator within a proof submission window measured in blocks. If not defended against, the accusation may be promoted to a fault by the protocol once the innocence window has expired.\n    Slashing penalties are computed by protocol and applied for proven faults at epoch end. The penalty amount is computed based on a base slashing rate and slashing factors including the total number of slashable offences committed in the epoch (collusion) and the individual offending validator’s own slashing history.\n    Slashing is applied as part of the state finalization function. As the last block of an epoch is finalized, the Autonity contract will: apply accountability for faults to offending validators, slashing self-bonded and delegated stake according to Autonity’s Penalty-Absorbing Stake (PAS) model.\n    Rewards are paid for reporting a slashable fault at epoch end. The offending_ validator’s_ share of the epoch’s staking rewards is forfeited and paid to the reporting validator treasury account for distribution along with the staking rewards at epoch end.\n    \n    \n    To participate in AFD a validator must be a consensus committee member."
  },
  {
    "objectID": "concepts/accountability/index.html#accountability-and-fault-detection-protocol",
    "href": "concepts/accountability/index.html#accountability-and-fault-detection-protocol",
    "title": "Accountability and fault detection (AFD)",
    "section": "Accountability and Fault Detection protocol",
    "text": "Accountability and Fault Detection protocol\n    AFD roles, core concepts, and the lifecycle of accountability event processing from accusation to slashing.\n    \n    Roles\n    As a consensus committee member the validator may play the roles in the table beneath during AFD processing.\n    \n    \n    \n    \n    \n    \n    \n    Role\n    Description\n    \n    \n    \n    \n    reporting\n    as the validator reporting a (suspected) rule infraction and submitting new fault proof / accusation on-chain\n    \n    \n    offending\n    as the validator committing a suspected rule infraction and being requested to submit innocence proofs on-chain\n    \n    \n    committee member\n    as a validator in the consensus committee executing Autonity’s consensus protocol and for AFD handling and processing accountability events, maintaining system state for accountability events, and computing and applying slashing penalties\n    \n    \n    \n    The economic impact of the AFD protocol on a validator depends on their role.\n    \n    \n    \n    \n    \n    \n    \n    Role\n    Economic impact\n    \n    \n    \n    \n    offender\n    loss of stake, validator reputation, staking reward revenue as the offending validator of a slashed fault\n    \n    \n    reporting\n    gain of the offending validator’s protocol rewards as the reporting validator of a slashed fault\n    \n    \n    \n    The Autonity community is also a beneficiary of AFD processing as slashed stake tokens will be used for community funds.\n    \n    \n    Protocol primitives\n    Essential primitives of AFD are: accusation, innocence, and fault proofs; slashing and severity; jailing.\n    \n    Accusations\n    An accusation is a claim that a consensus committee member has failed to participate correctly in consensus. The protocol only allows a validator to have one pending accusation at a time. New accusations are made by submitting evidence of an accusable rule infraction on-chain as an accountability event of type Accusation.\n    Accusations do not automatically cause slashing, as an innocence proof window measured in blocks gives the accused offending validator a window to detect an accusation and prove innocence by submitting an innocence proof on-chain.\n    \n    \n    \n    \n    \n    \n    A note on why a new accusation cannot be submitted until the innocence window has expired\n    \n    \n    \n    \n    \n    If the offending validator already has an accusation pending, the accountability protocol determines the offender is not currently accusable. This is because the protocol has to wait to determine if the pending accusation has been defended or, if not, promoted to a fault. Until then, it cannot determine if the offending validator has committed a rule infraction with a higher severity than the new candidate accusation in the epoch or not.\n    \n    \n    \n    After successful handling and verification of an accusation on-chain, a NewAccusation event is emitted logging the offending validator identifier address, severity of rule infraction, and the event ID.\n    There are protocol constraints on when an accusation can be made. A reporting validator can only submit an accusation against an offending validator within the constraints described in the table beneath.\n    \n    \n    \n    Constraint\n    Description\n    \n    \n    \n    \n    A fault with a higher severity has not already been reported for the epoch\n    The offending validator does not already have a fault in the current epoch n with a higher severity than the fault of the new accusation being made. If the accusation is for an earlier epoch, e.g. n-1, then the protocol checks that the offending validator has not already been slashed in that epoch for an offence with a higher severity. Slashing history is checked to determine this.\n    \n    \n    There is not a pending accusation\n    The offending validator does not already have an accusation for committing a rule infraction in the epoch. If there is a pending accusation, then the accountability protocol has to wait until the innocence proof submission window for the pending accusation expires to determine whether a new accusation can be made or not. This creates a deadline measured in block height before it becomes possible to submit a new accusation. The innocence proof submission window length is set in the slashing protocol configuration.\n    \n    \n    The accusation is being made within a number of blocks after the detected rule infraction\n    An accusation must be made within an accusation window that is &lt;= 256 blocks after the detected accountability event. This creates a deadline measured in block height after which an accusation cannot be submitted.\n    \n    \n    \n    As each block is finalized, AFD will attempt to promote expired accusations (where the innocence proof submission window has elapsed) to proven faults.\n    \n    \n    Innocence\n    Accusations do not automatically cause slashing. An offending validator can present a claim of innocence to refute a pending accusation for an accusable rule infraction.\n    Claims of innocence are made by submitting an innocence claim on-chain as an event of type InnocenceProof. If successful, the proof of innocence cancels the pending accusation.\n    An innocence claim must be submitted within an innocence proof submission window to be accepted. The window length is measured as a count of blocks set as a parameter in the slashing protocol configuration. The window begins at the block height number at which the accusation was reported and gives the accused validator a window of opportunity to detect if an accusation against it has been made, and if so to defend itself and prove innocence by submitting an innocence claim on-chain. Otherwise, the accusation may be promoted to a fault and become slashable at the end of epoch.\n    If the innocence claim is successfully verified, then the accusation queue is checked and the corresponding accusation is cancelled. The pending accusation state is cleared and a reporting validator is now able to submit a new accusation against the offending validator.\n    After successful handling and verification of an innocence claim on-chain, an InnocenceProven event is emitted that logs: offending validator identifier address, and 0 indicating there are no pending accusations against the validator.\n    \n    \n    Faults\n    A fault is a proven consensus rule infraction in an epoch. A fault is created directly or by promotion of an accusation.\n    In the direct submission method a fault proof is submitted on-chain directly by a reporting validator. This method of fault reporting is reserved for rule infractions that rely on unforgeable evidence. It does not offer the possibility of defence.\n    A pending accusation can be automatically promoted to a fault after expiry of an innocence proof submission window. This method offers the possibility of defence by submission of an innocence proof. If the offending validator has not submitted a successfully verified innocence claim within the window, and a fault with a higher severity for the epoch has not already been proven against the offending validator during that epoch, then the accusation is promoted to a fault.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Unlike accusations where an accusation must be made within a &lt;= 256 block window of the rule infraction, there is no window constraint for direct fault submissions.\n    A direct fault proof can be reported at any time.\n    \n    \n    \n    After successful handling and verification of a directly submitted fault on-chain, a NewFaultProof event is emitted logging the offending validator identifier address, severity of rule infraction, and the event ID.\n    \n    \n    Slashing and severity\n    The AFD protocol will apply slashing to an offending validator for the fault with the highest severity reported in an epoch. A validator can only be slashed more than once in an epoch in the case where faults committed in different epochs are reported and applied in the same epoch.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    In certain cases, a validator can be slashed for committing a fault in an epoch more than once. For example:\n    \n    Epoch n: The offending validator is slashed for a fault committed in epoch n.\n    Epoch n+1: New faults are reported for the offending validator: (1) one for the current epoch n+1; (2) one for epoch n with a higher severity than the fault already slashed in epoch n.\n    Slashing applied in epoch n+1: The offending validator is slashed twice: (a) once for the fault committed in epoch n+1, and (2) once for the fault committed in epoch n.\n    \n    \n    \n    \n    Rule infraction severity has two key influences. Firstly, it will determine if a new fault is created or not. New fault creation is conditional on whether the offending validator already has an existing fault with a severity &gt;= to that of the candidate new fault for the epoch. Secondly, severity will determine the amount of the slashing applied.\n    The slashing amount is calculated from a number of parameters, including severity. For slashing calculation and parameters see Slashing. For the severity taxonomy see Rule severity.\n    \n    \n    Jail\n    Jailing is a protocol action that excludes a validator from consensus committee selection. Jailing may be applied as part of a slashing penalty depending on the severity of the fault being slashed.\n    Jailing transitions the offending validator from an active to a jailed or jailbound state. Jailing is either temporary or permanent:\n    On temporary jailing the validator enters a jailed state and is impermanently jailed for a number of blocks, the jail period. The validator’s jail release block number is computed based on its proven fault history as described in Jail period calculation. After expiry of the jail period a validator may get out of jail by re-activating to revert to an active state and resume eligibility for consensus committee selection.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The offending validator will remain in a jailed state even after jail period expiry. The validator operator must manually re-activate by calling the activateValidator() function to get out of jail.\n    The protocol does not automatically revert validator state from jailed to active at the jail release block number.\n    \n    \n    \n    On permanent jailing the validator enters a jailbound state and is permanently jailed. It becomes jailbound and cannot get out of jail. Permanent jailing is only applied in the case where a validator is found guilty by the accountability and fault detection protocol of a fault with a 100% stake slashing penalty as a member of the consensus committee.\n    \n    \n    \n    Accountability event lifecycle\n    Accountability event lifecycle management comprises: accountability event submission on-chain, event handling on-chain, accusations, innocence, fault promotion, and slashing. Rule infractions are detected by validators and submitted on-chain. As noted under Protocol Primitives above, Faults may be directly submitted as FaultProofs or promoted from Accusations.\n    Rule infractions can be directly submitted as a fault proof by a reporting validator or promoted from an accusation. In the latter case, they they are promoted when: - reported as an accusation, submitted by a reporting validator against an offending validator - eventually defended by an innocence proof, submitted by the offending validator within a proof submission window measured in blocks - if not defended, promoted to fault by the protocol once the innocence window has expired.\n    The sequence of lifecycle events for an accountability event is:\n    \n    An accountability event is detected by the AFD protocol and submitted on-chain by a reporting validator.\n    Event handling takes place. The event is verified and processed based on event type:\n    \n    FaultProof: If the severity is greater than the severity of a fault in the offending validator’s slashing history for the epoch, the event is recorded. Else, discarded.\n    Accusation: If the severity is greater than the severity of a fault in the offending validator’s slashing history for the epoch, and the validator does not already have a pending accusation, then the event is recorded. Else, it is discarded.\n    InnocenceProof: If the innocence proof matches to a pending accusation against an offending validator, then the event is recorded and the corresponding Accusation is deleted. Else, it is discarded.\n    \n    Fault promotion is tried. Each block until epoch end, the protocol attempts to promote Accusations to new FaultProofs. Promotion only takes place if the proof innocence window has expired and the severity is greater than the severity of an existing fault in the offending validator’s slashing history for the epoch. Else, it is discarded.\n    Faults are queued for slashing. Accountability FaultProof events are placed on a slashing queue for slashing at the end of epoch. For each offending validator with one or more proven faults, a slashing penalty is applied for the FaultProof with the highest severity for its fault epoch.\n    Validators are jailed. Validators may be jailed as part of the slashing penalty for a fault. The validator’s node transitions from active to a jailed state and is barred from consensus committee selection. (The validator will only resume an active state when re-activated by the validator operator after the jail period expires.)"
  },
  {
    "objectID": "concepts/accountability/index.html#slashing",
    "href": "concepts/accountability/index.html#slashing",
    "title": "Accountability and fault detection (AFD)",
    "section": "Slashing",
    "text": "Slashing\n    Slashing penalties are computed by the protocol and applied for proven faults at epoch end. The penalty amount is computed based on a base slashing rate and slashing factors including the total number of slashable offences committed in the epoch and the individual offending validator’s own slashing history. For parameters see slashing protocol configuration beneath.\n    Slashing is applied as part of the state finalization function. As the last block of an epoch is finalized, AFD will apply slashing for proven faults to validator stake, slashing stake per Autonity’s Penalty-Absorbing Stake (PAS) model, and applying validator jailing.\n    \n    Slashing protocol configuration\n    Accountability protocol parameters are set by default to:\n    \n    \n    \n    \n    \n    \n    \n    \n    Protocol parameter\n    Description\n    Value\n    \n    \n    \n    \n    innocence proof submission window\n    the number of blocks within which an accused offending validator can submit a proof of innocence on-chain refuting an accusation\n    100\n    \n    \n    base slashing rate low\n    the base slashing rate for a fault of Low severity\n    1000 (10%)\n    \n    \n    base slashing rate mid\n    the base slashing rate for a fault of Mid severity\n    2000 (20%)\n    \n    \n    collusion factor\n    a factor that measures the number of validators committing slashable offences in the same epoch. The factor is applied as a multiplicand to the total number of slashable offences committed in the epoch when computing the slashing amount of a penalty\n    500 (5%)\n    \n    \n    history factor\n    a factor that measures the number of proven faults committed by a validator since registration. The factor is applied as a multiplicand to that proven fault count when computing the slashing amount of a penalty\n    750 (7.5%)\n    \n    \n    jail factor\n    the number of epochs applied as a multiplier to the proven fault count of a validator. The factor is applied when computing the jail period of an offending validator\n    48 (1 day at 30 mins epochs)\n    \n    \n    slashing rate precision\n    the division precision used as the denominator when computing the slashing amount of a penalty\n    10_000\n    \n    \n    \n    \n    \n    Slashing amount calculation\n    The economic cost of a stake slashing is calculated by applying a slashing rate to a validator’s bonded stake to compute a slashing amount.\n    The slashing rate is calculated by the formula base rate + epoch offences count * collusion factor + history * history factor where:\n    \n    base rate: is determined by the severity of the rule infraction\n    epoch offences count: is the count of proven faults created by all validators in the epoch, which is used as evidence of collusion\n    history: is the count of proven faults committed by the offending validator since it first registered\n    collusion factor and history factor: are used to compute a percentage of individual and total validator offence counts to supplement the base rate and scale the slashing rate according to the individual validator history and evidence of general validator collusion in the current epoch.\n    \n    The slashing amount is calculated by the formula (slashing rate * validator bonded stake)/slashing rate precision, applying the computed slashing rate as a multiplier to the validator’s bonded stake amount divided by the slashing protocol configuration slashing rate precision.\n    The slashing fine is then applied to validator bonded stake according to the protocol’s Penalty-Absorbing Stake (PAS) model: self-bonded stake is slashed before delegated stake. The validator state is updated: (a) the self-bonded and total staked amounts adjusted, (b) the slashing amount is added to the validator’s totalSlashed counter. The slashed NTN stake token is then transferred to the Autonity Protocol global treasury account for community funding.\n    \n    \n    Jail period calculation\n    Depending upon fault severity, a slashing penalty may apply temporary or permanent validator jailing.\n    If temporary, jailing will bar the validator from committee selection for a number of blocks known as a jail period. The jail release block number is computed by the formula current block number + jail factor * history * epoch period where:\n    \n    current block number: The block number at the time of computation (i.e. the last block of an epoch when slashing is applied).\n    jail factor: A multiplier measured as a number of epochs, defined as a protocol parameter in the slashing protocol configuration.\n    history: The number of faults that the validator has been slashed for since registration. This applies a reputational factor based on the validator’s slashing history over time.\n    epoch period: The period of time for which a consensus committee is elected. This is defined as a number of blocks in the Autonity network’s protocol parameterisation and set in the network’s genesis configuration.\n    \n    If permanent, the validator becomes jailbound and there i sno jail release block. Permanent jailing is only applied in the case where a validator suffers 100% stake slashing as a member of the consensus committee.\n    \n    \n    Penalty-Absorbing Stake (PAS)\n    Slashing penalties for accountability events are applied according to Autonity’s penalty-absorbing stake model.\n    The offending validator’s own self-bonded stake is slashed before delegated stake when applying slashing penalties for accountability events.\n    To learn more about PAS, see the section on Penalty-Absorbing Stake (PAS) in Staking."
  },
  {
    "objectID": "concepts/accountability/index.html#rules",
    "href": "concepts/accountability/index.html#rules",
    "title": "Accountability and fault detection (AFD)",
    "section": "Rules",
    "text": "Rules\n    \n    Accountability rules\n    Accountability rules are applied to detect faults in the three Tendermint consensus round phases propose, prevote, and precommit.\n    The table below lists each of the rules defined in the AFD rule engine, identified by a unique Rule ID.\n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    The ID prefixes P, PV, and C that are used in Rule IDs correspond to Tendermint consensus phases:\n    \n    P: propose\n    PV: prevote\n    C: precommit\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Rule ID\n    Description\n    \n    \n    \n    \n    PN - PO\n    Propose step related consensus rule infraction.\n    \n    \n    PVN - PVO - PVO12 - PVO3\n    Prevote step related consensus rule infraction.\n    \n    \n    C - C1\n    Precommit step related consensus rule infraction.\n    \n    \n    InvalidProposal\n    Proposer has proposed a block that fails blockchain validation.\n    \n    \n    InvalidProposer\n    Proposer of a block proposal is not the committee’s elected Proposer.\n    \n    \n    Equivocation\n    Validator has sent conflicting messages during a consensus round: a committee member sending multiple prevotes/precommits for different values, or a proposer has broadcast conflicting block proposals to different committee members.\n    \n    \n    InvalidRoundStep\n    Consensus round message contains invalid round number or step.\n    \n    \n    WrongValidRound\n    Consensus round message contains wrong valid round number.\n    \n    \n    GarbageMessage\n    Consensus round message was signed by sender, but it cannot be decoded.\n    \n    \n    \n    \n    \n    Rule severity\n    Rules are given a severity rating according to the risk that failure to adhere to the rule brings to block chain finality and integrity.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    In this release all offences are treated as Mid severity.\n    Future releases will introduce an offence scale range."
  },
  {
    "objectID": "concepts/accountability/index.html#events",
    "href": "concepts/accountability/index.html#events",
    "title": "Accountability and fault detection (AFD)",
    "section": "Events",
    "text": "Events\n    \n    Event handling\n    Accountability events are submitted on-chain by validator’s submitting proofs of behavior from consensus messaging. See handleEvent() for a description of event handling logic.\n    \n    \n    Event types\n    There are three accountability event types in AFD:\n    \n    \n    \n    \n    \n    \n    \n    Event type\n    Description\n    \n    \n    \n    \n    Accusation\n    an accusation of a committee member validator failing to adhere to, or violating, a consensus rule submitted by another validator committee member\n    \n    \n    InnocenceProof\n    a proof of innocence from an accusation submitted by the accused committee member, which refutes and cancels the accusation if the proof is valid\n    \n    \n    FaultProof\n    a misbehavior fault\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    See distinction between direct and promoted in Faults above.\n    \n    \n    \n    \n    \n    Event structure\n    struct Event:\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    chunks\n    uint8\n    Counter for the number of chunks in an oversize accountability event. (Large events are chunked into smaller segments with ID’s and stored in a map; see handleEvent()).\n    \n    \n    chunkId\n    uint8\n    Chunk index to construct an oversize accountability event.\n    \n    \n    eventType\n    EventType\n    The accountability event type, one of: FaultProof (proven misbehavior), Accusation (pending accusation), or InnocenceProof (proven innocence).\n    \n    \n    rule\n    Rule\n    The identifier of the accountability Rule defined in the Accountability Fault Detector (AFD) rule engine. Enumerated values are defined for each AFD Rule ID.\n    \n    \n    reporter\n    address\n    The node address of the validator that reported this accountability event.\n    \n    \n    offender\n    address\n    The node address of the validator accused of the accountability event.\n    \n    \n    rawProof\n    bytes\n    The rlp encoded bytes of the accountability proof object.\n    \n    \n    block\n    uint256\n    The block number in which the accountability event occurred. Assigned during event handling by internal processing of raw proof data.\n    \n    \n    epoch\n    uint256\n    The epoch identifier in which the accountability event block occurred. Assigned during event handling by internal processing of raw proof data.\n    \n    \n    reportingBlock\n    uint256\n    The number of the block at which the accountability event was verified. Assigned during event handling by internal processing of raw proof data.\n    \n    \n    messageHash\n    uint256\n    Hash of the main evidence for the accountability event. Assigned during event handling by internal processing of raw proof data."
  },
  {
    "objectID": "concepts/accountability/index.html#slashing-economics",
    "href": "concepts/accountability/index.html#slashing-economics",
    "title": "Accountability and fault detection (AFD)",
    "section": "Slashing economics",
    "text": "Slashing economics\n    There are two aspects to the economics of slashing: slashing penalties for offending validators and slashing rewards for reporting validators.\n    \n    Slashing penalties\n    The economic loss to validators and their delegators from slashing penalties covers stake token and staking rewards.\n    \n    \n    \n    Economic loss\n    Description\n    \n    \n    \n    \n    Slashing of stake token\n    The offending validator’s bonded stake is slashed for the penalty amount. Slashing is applied at epoch end according to the protocol’s Penalty-Absorbing Stake (PAS) model. The amount of stake token slashed varies according to the severity of the fault committed and the slashing factors applied.\n    \n    \n    Loss of current epoch staking rewards\n    The offending validator loses staking rewards earned if a member of the consensus committee in the epoch when the slashing penalty is applied. The forfeited staking rewards are distributed to the reporting validator.\n    \n    \n    Loss of future staking rewards\n    If the slashing penalty applies jailing for the fault, then the offending validator loses the opportunity to earn future staking rewards as a committee member until it resumes an active state.\n    \n    \n    \n    \n    \n    Slashing rewards\n    Slashing rewards are provided by forfeiture of an offending validator’s staking rewards.\n    Slashing rewards are distributed for reporting provable faults committed by an offending validator to the reporting validator. Rewards are only distributed to the last reporter of a slashing penalty applied to an offending validator in an epoch. Reward revenue is determined by the offender’s share of the stake active (voting power) in the committee at the time the slashing penalty is applied.\n    Slashing rewards earned by a reporting validator are conditional on the offending validator being a member of the consensus committee in the epoch when the slashing penalty is applied. If multiple slashing events are committed by the same offending validator during the same epoch, then rewards are only distributed to the last reporter for the last slashing penalty applied to an offending validator in the epoch.\n    Staking rewards earned by the offending validator for the epoch are distributed to the reporting validator at epoch end.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The protocol distributes rewards for reporting provable faults committed by an offending validator to the reporting validator.\n    If multiple slashing events are committed by the same offending validator during the same epoch, then rewards are only distributed to the last reporter.\n    If the distribution of rewards to the reporting validator’s treasury account fails, then the slashing rewards are sent to the Autonity Protocol treasury account for community funds."
  },
  {
    "objectID": "concepts/oracle-server/index.html",
    "href": "concepts/oracle-server/index.html",
    "title": "Autonity Oracle Server (AOS)",
    "section": "",
    "text": "AOS is the reference implementation of the Autonity Oracle Protocol and the oracle server software run by validator nodes in an Autonity network. It is composed of off- and on-chain components."
  },
  {
    "objectID": "concepts/oracle-server/index.html#features",
    "href": "concepts/oracle-server/index.html#features",
    "title": "Autonity Oracle Server (AOS)",
    "section": "Features",
    "text": "Features\n    \n    Core logic\n    \n    Core, the core off-chain Autonity Oracle Server (AOS) codebase. Core manages interactions with external price data source providers via data adaptor ‘plugins’ and the connected Autonity Go Client (AGC) validator node AOS serves. Core executes aggregation of data from external sources (“off-chain aggregation”), calculates an aggregated median price, and submits price report transactions on-chain to the Oracle Contract.\n    Autonity Oracle Contract, the oracle protocol contract logic deployed to the ledger by AGC. The Oracle Contract manages the computation of median price data for currency pair price reports submitted by oracle servers. The contract provides operations for: computing median price (“on-chain aggregation”) from submitted price report transactions in oracle voting rounds, providing median price data via interface, and managing the currency-pair symbols for which price data is provided by the Autonity oracle network. See Autonity Oracle Contract and concept Client.\n    Networking, the system uses WebSocket and HTTP network protocols. RPC calls are made to configured data source providers over HTTP, HTTPS, or WebSocket. The system establishes a connection to the AGC validator using WebSocket to (a) submit price report transactions and (b) listen for on-chain Oracle Contract events.\n    \n    The RPC calls to configured data source might have different network protocols, it may have HTTP, HTTPS, or even Web Socket, the plugin should implement this adaptation protocols, it depends on the provider’s scheme.\n    \n    \n    State storage\n    Oracle server is stateless and does not maintain an off-chain database. Off-chain price aggregation is computed by the server in memory. Price report transactions submitted to the Oracle Contract on-chain are committed to the Autonity network’s ledger and persisted in world state. See also System model and the Ledger object.\n    \n    \n    Data adaptors - plugin architecture\n    Oracle server provides a standard interface for data adaptors pulling data from external data providers. Any party can build a new plugin implementing this interface and so provide an adaptor for any data source on demand.\n    The oracle server scans and load plugins from the /plugins directory (see how to install oracle server) during runtime. Detection of new or updated plugins is dynamic; no shutdown of the oracle client is required to detect and apply the change.\n    \n    Runtime plugin management\n    The oracle server scans and load plugins from the /plugins directory during runtime. Detection of new or changed plugins is dynamic; no shutdown of the oracle client is required to detect and apply the change.\n    \n    Adding new plugins. To add an adaptor for a new data source, place the new plugin into the oracle server’s /plugins directory. The oracle server auto-discovers and manages it. There are no other operations required from the operator.\n    Replace or upgrade running plugins. To replace a (running) data adaptor plugin with a new version, just replace the binary in the /plugins directory. The oracle server auto-discovers the new version by checking the modification time of the binary and manages the plugin replacement itself. There are no other operations required from the operator.\n    \n    \n    \n    Oracle data providers\n    Valid price data sources are exchanges providing up to date market prices for trades in the currency pairs provided by the oracle server’s configuration.\n    Primary data providers for oracle data are:\n    \n    FX and protocol asset (ATN, NTN) currency pairs utilised in the Auton Stabilization Mechanism (ASM).\n    \n    A basic set of data adaptor plugins for sourcing this price data is provided out the box with oracle server for testnet pre-Mainnet:\n    \n    Forex plugins: for connecting to public FX data sources. See the forex_ prefixed adaptors in /plugins. Four forex plugins are currently provided.\n    Simulator plugin: for simulated protocol asset (ATN, NTN, NTN-ATN) data. See the sim_plugin adaptor in /plugins.\n    \n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    ATN and NTN symbols are preview listed but untraded:\n    \n    https://www.coingecko.com/en/coins/auton\n    https://www.coingecko.com/en/coins/newton\n    \n    Plugins for retrieving ATN/NTN price data are to be developed for Mainnet launch.\n    \n    \n    \n    \n    \n    Developing data plugins\n    Additional data adaptors for any external data source can be developed using the oracle server’s plugin template. See:\n    \n    Adaptor code template template_plugin in /plugins.\n    Guide for how To write a new plugin using the template in /plugins/README.\n    \n    \n    \n    \n    Oracle server lifecycle\n    Oracle server lifecycle management is an adjunct of validator operations and comprises software installation and the configuration and (optionally) development of adaptors for data to data sources for currency pair price data.\n    The sequence of lifecycle events for an oracle server is:\n    \n    Join the oracle network. The validator’s oracle server is installed and configured: oracle server account created, data plugins configured to pull currency pair data from external data sources; oracle server configured to connect to the validator’s main client software.\n    Register as a validator. The validator’s node is registered as a validator by the submission of registration parameters, which include the oracle address.\n    Oracle server initialised. The server is initialised and begins retrieving price report data from its connected data sources transactions to its connected validator node.\n    Selection to consensus committee. Assuming stake bonded to validator and if selected to the consensus committee, the validator (a) participates in block validation, (b) participates in oracle voting rounds by oracle server submitting oracle vote transactions to the oracle contract with cryptographic commits and reveals of price report submissions.\n    Runtime plugin management. The validator operator manages and updates data source plugins in accordance with currency pair changes and own operational requirements.\n    \n    \n    \n    Interfaces\n    The oracle server provides interfaces for:\n    \n    Oracle Contract Interfaces and JSON-RPC APIs - see Autonity Interfaces Reference\n    Plugin interface - a standard interface implemented by data adaptors developed to pull data from external data sources on demand.\n    Command line options for oracle server configuration and interaction - see Command-line options Reference."
  },
  {
    "objectID": "concepts/asm/index.html",
    "href": "concepts/asm/index.html",
    "title": "Auton Stabilization Mechanism (ASM)",
    "section": "",
    "text": "This section describes the Auton Stabilization Mechanism (ASM) and protocol. The Auton Stabilization Mechanism provides functions to compute the target value for the Auton Auton (ATN) and methods to drive the Auton’s actual market price towards the target through the supply of the Auton and Newton (NTN).\n    Autonity implements a Collateralized Debt Position or CDP-based stabilization mechanism. Auton tokens are minted and burned exclusively as a result of changing collateralized debt positions.\n    Autons are minted when users take out CDPs. Users deposit collateral in the form of Newtons (NTN) to borrow Auton at interest.\n    Autons are burned when a CDP is repaid by depositing ATN to the ASM’s smart contract. The NTN collateral is removed and returned to circulation.\n    CDPs are created with defined collateralization and liquidation ratios which limit the risk that the debt cannot be adequately covered by the sale of the collateral.\n    Changes in supply and demand for Auton are absorbed by dynamically adjusting CDP incentives to increase and decrease Auton borrowing costs when Auton price moves above or below its Stabilization Target the Auton Currency Unit (ACU)."
  },
  {
    "objectID": "concepts/asm/index.html#overview",
    "href": "concepts/asm/index.html#overview",
    "title": "Auton Stabilization Mechanism (ASM)",
    "section": "",
    "text": "This section describes the Auton Stabilization Mechanism (ASM) and protocol. The Auton Stabilization Mechanism provides functions to compute the target value for the Auton Auton (ATN) and methods to drive the Auton’s actual market price towards the target through the supply of the Auton and Newton (NTN).\n    Autonity implements a Collateralized Debt Position or CDP-based stabilization mechanism. Auton tokens are minted and burned exclusively as a result of changing collateralized debt positions.\n    Autons are minted when users take out CDPs. Users deposit collateral in the form of Newtons (NTN) to borrow Auton at interest.\n    Autons are burned when a CDP is repaid by depositing ATN to the ASM’s smart contract. The NTN collateral is removed and returned to circulation.\n    CDPs are created with defined collateralization and liquidation ratios which limit the risk that the debt cannot be adequately covered by the sale of the collateral.\n    Changes in supply and demand for Auton are absorbed by dynamically adjusting CDP incentives to increase and decrease Auton borrowing costs when Auton price moves above or below its Stabilization Target the Auton Currency Unit (ACU)."
  },
  {
    "objectID": "concepts/asm/index.html#asm-identifiers-and-accounts",
    "href": "concepts/asm/index.html#asm-identifiers-and-accounts",
    "title": "Auton Stabilization Mechanism (ASM)",
    "section": "ASM identifiers and accounts",
    "text": "ASM identifiers and accounts\n    The ASM functions with two identities for cryptographic security: the CDP owner and the stabilization protocol contract.\n    Stabilization Contract calls to mint and burn Auton as CDPs are interacted with to borrow and repay Auton are restricted to the Stabilization Contract address, the ‘stabilizer’ protocol address.\n    \n    CDP identifiers\n    The CDP owner’s account address is used as a unique identifier for the CDP itself as well as the CDP owner.\n    The identity is in the form of an Ethereum formatted account address and is used to:\n    \n    unambiguously identify the CDP on-chain\n    by the CDP owner as the msg.sender address in all CDP interactions: to open, repay debt, and withdraw collateral from the CDP\n    by a Liquidator to identify the CDP being liquidated in a liquidation scenario."
  },
  {
    "objectID": "concepts/asm/index.html#stabilization-protocol",
    "href": "concepts/asm/index.html#stabilization-protocol",
    "title": "Auton Stabilization Mechanism (ASM)",
    "section": "Stabilization protocol",
    "text": "Stabilization protocol\n    ASM roles, core concepts, and the lifecycle of a CDP from opening to closure.\n    \n    Stabilization roles\n    There are three roles in the ASM:\n    \n    Borrower (CDP owner): a user taking out a CDP to borrow Auton, deposing collateral in return. There is no limit on the number of open CDP’s a borrower can own at any one time. Borrower’s must have an account on the Autonity network.\n    Liquidator (Keeper): a user or agent that liquidates a CDP that has brobecome under collateralized, repaying the CDP’s outstanding debt and receiving remaining collateral token in return. Liquidator’s must have an account on the Autonity network.\n    Stabilizer (ASM Protocol): the stabilizer is the protocol account address used for Auton mint and burn operations by the Stabilization Contract)\n    \n    \n    \n    ASM elements\n    The ASM is composed of 3 system elements implemented as smart contract logic: ACU, Supply Control, Stabilization. ASM contracts are deployed by the protocol at genesis.\n    \n    ACU\n    The Auton Currency Unit (ACU) is a currency basket from which an index value is computed. This index value is then used as the stabilization target for Auton price, see Stabilization.\n    The ACU currency basket is composed of 7 free-floating currencies:\n    \n    AUD - Australian Dollar\n    CAD - Canadian Dollar\n    EUR - Euro\n    GBP - British Pound Sterling\n    JPY - Japanese Yen\n    SEK - Swedish Krona\n    USD - United States Dollar\n    \n    Each currency’s quantity in the basket is computed to provide a currency basket with minimal total variance with respect to its underlying currencies. The index value then has minimal volatility with respect to variance from individual currency fluctuations.\n    The index value of ACU can be computed at any time in terms of exchange rates. The index value is computed from price data for each of the basket currencies. Price data is sourced from off-chain by the validator oracle network and retrieved from the Oracle Contract on-chain.\n    The value is recomputed at the end of each oracle voting round after new price data for the basket currencies has been computed by the oracle network.\n    Public functions can be called to return the ACU value, the currency pair symbols in the basket, and the basket quantities, see ACU Contract Interface.\n    Modifying the currency basket is restricted to the governance account. See the Governance and Protocol Only Reference, modifyBasket().\n    \n    \n    \n    Supply control\n    The Supply Control contract controls the supply of Auton in circulation on the network. The contract is called by the Stabilization contract to mint and burn Auton as CDP’s are opened and Auton borrowed and repaid. See the Governance and Protocol Only Reference, mint() and burn().\n    Public functions to return the total supply of Auton and the amount of Auton available for minting can be called, see Supply Control Contract Interface.\n    \n    \n    Stabilization\n    The Stabilization Contract maintains a record of CDPs and calls the Supply Control Contract to mint and burn Auton as collateral token is deposited or withdrawn and borrowing repaid. For each CDP, the Stabilization Contract records:\n    \n    timestamp: the timestamp of the last borrow or repayment.\n    collateral: the collateral deposited with the Stabilization Contract.\n    principal: the principal debt outstanding as of timestamp.\n    interest: the interest debt that is due at the timestamp.\n    \n    The stabilization mechanism operates by dynamically adjusting CDP incentives.\n    Users post Collateral Token to borrow ATN against collateral at the Borrow Rate. The Auton Borrow Rate goes up (down) depending on whether ATN/ACU is below (above) the target exchange rate for ATN/ACU to:\n    \n    Increase ATN borrowing (more supply) when ATN/ACU is above target\n    Decrease ATN borrowing (less supply) when ATN/ACU is below target.\n    \n    CDP collateral token is currently restricted to the Autonity staking token NTN but may be extended to other protocol assets.\n    Modifying the stabilization configuration for CDP collateral and debt thresholds is restricted to the governance account. See the Governance and Protocol Only Reference, setLiquidationRatio(), setMinCollateralizationRatio(), and setMinDebtRequirement().\n    Public functions can be called for:\n    \n    CDP ownership - borrow and repay Auton, withdraw and deposit Collateral Token\n    CDP cost discovery - collateral price, borrow limit, minimum debt requirement, and interest due\n    CDP liquidation - if a CDP is liquidatable and to liquidate.\n    \n    See Stabilization Contract Interface.\n    \n    \n    \n    ASM configuration\n    ASM parameter settings:\n    \n    ACU:\n    \n    quantities = [21_300, 18_700, 14_300, 10_400, 1_760_000, 18_000, 141_000], the basket quantity corresponding to each symbol.\n    scale = 5, the scale used to represent quantities and the ACU value as a fixed-point integer.\n    symbols = [\"AUD-USD\", \"CAD-USD\", \"EUR-USD\", \"GBP-USD\", \"JPY-USD\", \"USD-USD\", \"SEK-USD\"], the symbols comprising the currency basket.\n    \n    Supply Control:\n    \n    initial allocation = 2^256 - 1, the total supply of Auton available for minting.\n    \n    Stabilization:\n    \n    borrow interest rate = 50_000_000_000_000_000 (0.05e18), the annual continuously-compounded interest rate for borrowing.\n    liquidation ratio = 1_800_000_000_000_000_000 (1.8e18): the minimum ACU value of collateral required to maintain 1 ACU value of debt.\n    min collateralization ratio = 2_000_000_000_000_000_000 (2.0e18): the minimum ACU value of collateral required to borrow 1 ACU value of debt.\n    min debt requirement = 1_000_000 (megaton) : the minimum amount of debt required to maintain a CDP.\n    target price = 1_000_000_000_000_000_000 (1.0e18): the ACU value of 1 unit of debt.\n    \n    \n    \n    \n    \n    Protocol primitives\n    Essential primitives of ASM are: collateral, exchange rate price data, ACU, and the CDP.\n    \n    Collateral\n    Auton borrowing is collateralized by depositing collateral token into a CDP. The amount and value of collateral backing a CDP is determined by collateralization and liquidation ratios set in the ASM configuration. Failure by a borrower to maintain these ratios results in a CDP becoming liquidatable. In a liquidation scenario a liquidator is able to assume the debt position, repay outstanding debt, and receive the position’s remaining collateral in return.\n    Autonity’s native protocol asset Newton (NTN) is used as the collateral token.\n    \n    \n    Exchange rate price data\n    ASM sources price data via Autonity’s oracle network, retrieving the data on-chain by contract interactions with the Oracle Contract.\n    Oracle price data is used for two purposes:\n    \n    for the ACU currency basket symbols to compute the ACU value\n    for CDP borrowing to compute the value of Collateral Token (NTN) in ATN and determine the borrow limit.\n    \n    Oracle price data is computed per the Oracle protocol, updated periodically in voting rounds.\n    \n    \n    ACU\n    Auton price has the Auton Currency Unit (ACU) as the Stabilization Target to which it mean-reverts. ACU is an index value computed from a basket of free-floating currencies. Use of a currency basket minimises exposure to an individual currency’s FX exchange risk. The index value is computed from the basket, weighted pro rata to each currency’s share i.e. quantity in the basket. Basket quantities are set at network genesis and may be modified by governance.\n    ASM then functions to maintain Auton-to-ACU value, ‘mean reverting’ to this value by the CDP stabilization mechanism.\n    ACU value is kept current by protocol recomputing the value at the end of each oracle voting round when price data for all the basket currencies is available. See the Protocol Only Reference functions modifyBasket() update() for more detail.\n    \n    \n    CDP\n    The CDP functions to manage Auton borrowing and stabilize Auton price by adjusting the CDP borrowing cost. CDP’s are operated within strict parameterization constraints:\n    \n    CDP Ownership:\n    \n    A borrower (CDP Owner) can have only 1 open CDP at a time.\n    A borrower opens a CDP by depositing collateral &gt;= the minimum debt requirement for a CDP. A borrower can then within CDP constraints:\n    borrow ATN against collateral\n    repay ATN to partially or completely repay the CDP\n    withdraw collateral\n    \n    Minimum debt requirement:\n    \n    A CDP must be &gt;= a minimum amount of debt. This ensures the position is economically viable, i.e. the transaction and interest costs of opening and servicing, or liquidating, a position is viable.\n    \n    Borrow interest rate:\n    \n    Interest on debt is charged at an annual continuously-compounded interest rate.\n    Adjusting the borrow rate is the primary economic lever by which the CDP-based stabilization mechanism incentivises increase or decrease in ATN borrowing and ‘mean-revert’ ATN to ACU value.\n    Repayments to a CDP are used to cover accrued interest before debt principal.\n    \n    Borrow limit:\n    \n    The amount of Auton that can be borrowed against collateral deposited to a CDP is determined by the ATN value of that deposited collateral, forming a borrow limit.\n    The CDP Owner can borrow Auton to an amount &lt;= the borrow limit.\n    The amount of Auton borrowed in a CDP is the principal of the debt position. Principal cannot exceed the borrow limit.\n    \n    Collateralization:\n    \n    A CDP must maintain adequate collateral value at all times. A minimum collateralization ratio sets the minimum ACU value of collateral required to borrow 1 ACU value of debt. This ratio must be strictly greater than 1.0.\n    Collateral must be an ERC 20 token. The accepted collateral token is the protocol asset Newton.\n    \n    Liquidation ratio:\n    \n    A CDP must maintain adequate collateral value at all times. A liquidation ratio sets the minimum ACU value of collateral required to maintain 1 ACU value of debt.\n    The liquidation ratio must be strictly less than the minimum collateralization ratio.\n    \n    Liquidation Condition:\n    \n    A CDP is liquidatable when the CDP’s collateralisation ratio falls below the liquidation ratio:\n    If the liquidation condition is met, the only permitted operations on the CDP are:\n    \n    For the Borrower, the CDP Owner, to pay back Auton until and repay the CDP or bring the position back within the liquidation ratio\n    For a Liquidator to liquidate the position.\n    \n    \n    \n    \n    \n    \n    CDP lifecycle\n    The sequence of lifecycle events for a CDP is:\n    \n    CDP is opened.\n    \n    Borrower determines their borrowing and collateral requirements. To do this, the borrower can call Stabilization Contract functions, see collateralPrice(), minimumCollateral().\n    Borrower opts to open a CDP, becoming a CDP Owner. The CDP Owner then approves the Stabilization Contract to spend Collateral Token (NTN) on their behalf for the amount of collateral to be deposited:\n    \n    Calls the Collateral Token Contract (i.e. Autonity Protocol Contract) to approve() the Stabilization Contract address as a spender on their behalf and set the allowance() of collateral token that the Stabilization Contract can spend.\n    Calls the Stabilization Contract to deposit Collateral Token to a CDP, calling the contract’s [deposit()(/reference/api/asm/stabilization/#deposit) to deposit collateral.\n    \n    Stabilization Contract creates the CDP, using the ERC20 allowance mechanism to execute the collateral deposit. A CDP object is created, and the CDP attributes are populated.\n    \n    CDP is maintained and serviced. The CDP Owner maintains the CDP, opting to increase or decrease borrowing and deposited collateral within CDP primitive constraints. The CDP Owner may:\n    \n    Borrow: CDP Owner borrows Auton from CDP against collateral. Constraint checks are applied:\n    \n    the amount borrowed must not exceed the borrow limit for the deposited collateral value\n    the principal debt must meet the minimum debt requirement\n    the borrowing does not decrease the CDP collateralization ratio below the minimum collateralization ratio.\n    The Stabilization Contract calls the Supply Control Contract to mint the borrowed Auton amount to the CDP Owner.\n    \n    Repay: CDP Owner pays back some or all borrowed Auton in a CDP to (a) service the debt, or (b) maintain the CDP within constraints and prevent a CDP becoming liquidatable. Constraint checks are applied:\n    \n    Payment is only accepted if outstanding debt after the payment meets the minimum debt requirement\n    The Stabilization Contract uses the payment to cover outstanding accrued interest before outstanding debt principal, transfering the interest proceeds to the contract’s Internal Balance Sheet. If a payment surplus remains after covering outstanding interest, then the contract reduces the CDP principal and calls the Supply Control Contract to burn the amount of Auton principal debt paid back.\n    \n    Withdraw: CDP Owner withdraws collateral token from the CDP. Constraint checks are applied:\n    \n    the withdrawal must not reduce collateral below the CDP’s liquidation ratio, making the CDP meet the liquidation condition and so become liquidatable\n    the withdrawal must not reduce the remaining collateral below the CDP’s minimum collateralization ratio.\n    The Stabilization Contract transfers the withdrawn amount of collateral to the CDP Owner account address.\n    \n    \n    CDP is liquidated.\n    \n    A Liquidator determines that a CDP has or will meet the liquidation condition and so become liquidatable. To do this, the liquidator can call Stabilization Contract CDP View functions to view CDP state.\n    Liquidator opts to liquidate a CDP. The liquidator calls the Stabilization Contract liquidate() function to repay the CDP and claim the collateral. Constraint checks are applied:\n    The liquidate transaction payment amount will pay all the CDP debt outstanding, principal and accrued interest.\n    As a reward, the liquidator will receive the collateral that is held in the CDP. Any payment surplus remaining after covering the CDP’s debt is refunded to the liquidator."
  },
  {
    "objectID": "concepts/asm/index.html#asm-economics",
    "href": "concepts/asm/index.html#asm-economics",
    "title": "Auton Stabilization Mechanism (ASM)",
    "section": "ASM economics",
    "text": "ASM economics\n    ASM economics are multi-dimensional:\n    \n    For the protocol:\n    \n    Protocol asset price stability: the stabilization mechanism mean-reverts Auton to the ACU stabilization target over time, smoothing Auton price movement.\n    Supply and demand elasticity: Auton supply increases and decreases according to demand, the CDP borrow rate providing the economic lever to adjust CDP incentives.\n    Protocol revenue from borrow interest earned on CDP’s.\n    \n    For the borrower:\n    \n    CDP’s give access to collateralized borrowing for Auton with flexibility to increase and decrease borrowing and collateral amounts within constraints. Borrowers can offset flexibility against opportunity costs of borrow interest, staking reward potential if deposited Newton collateral were earning staking rewards, and liquidation risk.\n    \n    For the liquidator:\n    \n    Liquidation returns from remaining collateral after settlement of debt and interest outstanding."
  },
  {
    "objectID": "concepts/staking/index.html",
    "href": "concepts/staking/index.html",
    "title": "Staking",
    "section": "",
    "text": "Autonity implements the Tendermint Proof of Stake consensus protocol, enhanced by a liquid staking and Penalty-Absorbing Stake (PAS) model. PoS consensus secures the network by an economic incentivisation scheme that rewards honest behaviour with revenue from transaction fees and punishes dishonest behaviour by slashing penalties that may confiscate a portion of bonded stake or otherwise impact the staking rewards a validator would earn while participating in consensus.\n    Stake in an Autonity network is represented as the Newton stake token. Any network participant holding Newton becomes a stakeholder and is able to participate in securing the network and earn a share of staking rewards proportionate to their stake in return. As default, Newton is in an unbonded and unlocked state and can be transferred to other stakeholders. On bonding, Newton is locked and no longer transferrable; Liquid Newton is minted for delegated stake in equal proportion to the stake locked. In this liquid staking model the Liquid Newton receives the staking reward entitlements due to the bonded stake it represents; Liquid Newton is transferrable. To redeem stake, the converse to bonding occurs. Liquid Newton for delegated stake is burned (so it is no longer tradable) and after the expiry of a locking (unbonding) period the bonded Newton is redeemed.\n    Staking is open - any network participant is able to purchase stake token and bond stake by delegation to validators.\n    Staking rewards are distributed to delegated stake that is actively backing consensus. That is, to the subset of validator nodes participating in the consensus committee. Stake delegators to committee member validators receive a share of those rewards in proportion pro rata to their share of the stake bonded to the committee.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Note that in Autonity’s Penalty-Absorbing Stake (PAS) model, validator self-bonded stake does not result in minting of liquid newton. Validator revenue is derived from commission, block proposal, staking rewards on self-bonded stake, and slashing rewards. See validator economics."
  },
  {
    "objectID": "concepts/staking/index.html#overview",
    "href": "concepts/staking/index.html#overview",
    "title": "Staking",
    "section": "",
    "text": "Autonity implements the Tendermint Proof of Stake consensus protocol, enhanced by a liquid staking and Penalty-Absorbing Stake (PAS) model. PoS consensus secures the network by an economic incentivisation scheme that rewards honest behaviour with revenue from transaction fees and punishes dishonest behaviour by slashing penalties that may confiscate a portion of bonded stake or otherwise impact the staking rewards a validator would earn while participating in consensus.\n    Stake in an Autonity network is represented as the Newton stake token. Any network participant holding Newton becomes a stakeholder and is able to participate in securing the network and earn a share of staking rewards proportionate to their stake in return. As default, Newton is in an unbonded and unlocked state and can be transferred to other stakeholders. On bonding, Newton is locked and no longer transferrable; Liquid Newton is minted for delegated stake in equal proportion to the stake locked. In this liquid staking model the Liquid Newton receives the staking reward entitlements due to the bonded stake it represents; Liquid Newton is transferrable. To redeem stake, the converse to bonding occurs. Liquid Newton for delegated stake is burned (so it is no longer tradable) and after the expiry of a locking (unbonding) period the bonded Newton is redeemed.\n    Staking is open - any network participant is able to purchase stake token and bond stake by delegation to validators.\n    Staking rewards are distributed to delegated stake that is actively backing consensus. That is, to the subset of validator nodes participating in the consensus committee. Stake delegators to committee member validators receive a share of those rewards in proportion pro rata to their share of the stake bonded to the committee.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Note that in Autonity’s Penalty-Absorbing Stake (PAS) model, validator self-bonded stake does not result in minting of liquid newton. Validator revenue is derived from commission, block proposal, staking rewards on self-bonded stake, and slashing rewards. See validator economics."
  },
  {
    "objectID": "concepts/staking/index.html#liquid-staking",
    "href": "concepts/staking/index.html#liquid-staking",
    "title": "Staking",
    "section": "Liquid staking",
    "text": "Liquid staking\n    Autonity implements a liquid staking model, bringing benefits of:\n    \n    Capital efficiency: rewards from staking combined with the liquidity benefits of bonded stake that is transferable\n    Composability: liquid stake tokens can be used in other protocols (e.g., as collateral)\n    \n    \n    Liquid Newton\n    Liquid Newton is minted for delegated Newton stake bonded to a validator. On registration each validator has an ERC20 Liquid Newton contract created and deployed autonomously by the Autonity Protocol Contract (which maintains a registry of all Liquid Newton token contracts deployed).\n    It is important to note that stake bonded by the validator operator to its own validator - self-bonded stake - does not result in minting of Liquid Newton. This is part of Autonity’s Penalty-Absorbing Stake (PAS) model.\n    Liquid Newton is validator-specific because there is a separate ERC20 token for each registered validator. Liquid Newton for a given validator is fungible, but Liquid Newton tokens of different validators are not fungible with each other.\n    When delegated stake is bonded to a validator, Liquid Newton is minted for the Newton staked and the staked Newton is locked. The amount of Liquid Newton minted is subject to the amount of delegated stake the validator has at the time the bonding is applied. This conversion rate between Liquid Newton and Newton is maintained by a validator’s Liquid Newton contract as the reference price for Newton bonding and unbonding operations. The rate is determined by the ratio of issued liquid tokens over the total amount of stake tokens bonded to the validator.\n    As consequence, the Liquid Newton minted is subject to any accountability and omissions penalties applied to the validator resulting in a stake slashing event:\n    \n    If at the time of bonding a validator’s delegated stake amount has not been reduced by a stake slashing event, then Liquid Newton is minted 1:1 for the delegated Newton staked.\n    However, if the validator’s existing delegated stake amount is less than the supply of issued Liquid Newton, then Liquid Newton is minted in proportion to the validator’s delegated stake remaining, resulting in a &gt;1:1 issuance of Liquid Newton for Newton staked.\n    \n    This tokenomic mechanism ensures that a validator’s Liquid Newton tokens remain fungible as they are issued over time: the amount of Liquid Newton issued on bonding has a value matching that of the Newton being bonded.\n    The Liquid Newton has staking reward entitlement rights, is freely transferable, and represents the Liquid Newton holder’s share of the total stake bonded to the validator (i.e. the holder’s share of the validator’s Liquid Newton pool).\n    When stake is unbonded it is subject to an unbonding period and the holder’s Liquid Newton is redeemed in proportion to its share of the Liquid Newton pool minus any slashing penalties applied.\n    For example, if a validator had suffered a slashing penalty equivalent to 1% of its stake pool, then stake redemption value after slashing would be 99% of the original stake amount.\n    \n    \n    Fundamental operations\n    Liquid Newton has fundamental operations to transfer ownership and redeem for Newton stake token.\n    The Liquid Newton holder can transfer ownership of the token by sending to another network participant using the Liquid Newton contract’s ERC20 transfer() function. Upon receipt of Liquid Newton the holder becomes a delegator to the associated validator and has a claim to staked Newton.\n    Redemption of Liquid Newton for Newton stake token is by unbonding. The Liquid Newton holder can unbond stake from a validator and redeem Newton at any time subject to the unbonding period set for the chain. On unbonding the bonded stake remains locked for the duration of an unbonding period during which it is not transferrable and remains subject to any slashing penalties applied to the validator in that period. Stake redemption takes place at the end of the epoch in which the unbonding period falls. At this point the validator’s stake pool is reduced by the unbonded amount and Newton is returned to the staker.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    It’s important to note that Liquid Newton is validator-specific and as such is not 1:1 fungible with Liquid Newton bonded to a different validator. A validator may or may not have had slashing penalties applied and the redemption value of Liquid Newton may vary across validators according to their fault slashing history.\n    \n    \n    \n    \n    \n    Transferring Liquid Newton\n    For how to transfer Liquid Newton from a stake delegation to another account see the guide Transfer Liquid Newton."
  },
  {
    "objectID": "concepts/staking/index.html#penalty-absorbing-stake-pas",
    "href": "concepts/staking/index.html#penalty-absorbing-stake-pas",
    "title": "Staking",
    "section": "Penalty-Absorbing Stake (PAS)",
    "text": "Penalty-Absorbing Stake (PAS)\n    Autonity implements a penalty absorbing stake (PAS) model where a validator’s self-bonded stake is slashed before delegated stake when applying slashing penalties for accountability events.\n    Slashing priority is simply:\n    \n    Self-bonded stake is slashed as first priority until exhausted. If the validator has unbonding stake, then the unbonding stake is slashed before bonded stake.\n    Delegated stake is slashed as second priority when the slashing amount exceeds the amount of self-bonded stake available. If the delegator has unbonding stake, then the unbonding stake and bonded stake are slashed pro rata with equal priority.\n    \n    In the PAS model self-bonded stake has a different risk profile to delegated stake because it provides loss absorbing capital in the case of a slashing event. For this reason, Liquid Newton is only minted for delegated stake to ensure validator Liquid Newton has a uniform risk profile.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    By self-bonding stake, a validator puts “skin in the game” because this constitutes a public commitment to the operational integrity of the validator node by its operator. Potential stake delegators can use the amount of self-bonded stake of a validator as a decision factor when conducting due diligence before staking."
  },
  {
    "objectID": "concepts/staking/index.html#staking-rewards",
    "href": "concepts/staking/index.html#staking-rewards",
    "title": "Staking",
    "section": "Staking rewards",
    "text": "Staking rewards\n    Staking rewards are a distribution of fee revenue entitlement to all holders of bonded stake actively backing consensus. Reward distribution takes place pro-rata to the share of total stake bonded to validators in the consensus committee. The fee revenue comes from the base fees charged for computing transactions included in blocks committed to the system ledger. The optional priority fee of a transaction is not included in the rewards pool but awarded to the block proposer according to the EIP 1559 transaction fee mechanism.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    For more detail on EIP 1559 and the distinction between base fee and priority fee, see Transaction fees in the System model.\n    \n    \n    \n    Staking rewards are collected by the protocol and accumulate in a protocol account as blocks are processed throughout a block epoch. The fees are out of circulation until epoch end, at which point the protocol distributes them to validator committee members. Rewards are then distributed to validator self-bonded and delegated stake holders pro rata to their share of the validator’s total bonded stake. After this distribution, the rewards become claimable by stake delegators. Delegators then claim rewards in a “pull” model, at the frequency they choose.\n    As rewards are distributed, due fees are deducted from fee revenue by the protocol:\n    \n    Protocol treasury fee. A percentage of staking rewards is deducted for community funding. The fee goes to the Autonity Treasury account (See below), sent at epoch end when the epoch rewards are distributed to committee validators. The percentage value is set at genesis. See treasuryFee parameter of the config.autonity object in the Protocol section.\n    Validator commission fees. The percentage commission rate charged by a validator to stakers delegating to the validator; essentially, the validator’s service fee for providing a staking service to delegators. The fee is deducted from the validator’s portion of the fee revenue before staking rewards are apportioned to the stake delegators pro rata to their share of bonded stake. The percentage value is set at validator registration. See the delegationRate parameter of the config.autonity object in the Protocol section.\n    \n    The remaining fee revenue is then distributed to stake delegators.\n    \n    Reward distribution\n    The priority fee reward is distributed to the validator proposing a block when the block is finalized.\n    Stake delegation rewards are distributed to validator committee members at the end of each epoch. On finalization of the last block in the epoch rewards become claimable by stake delegators.\n    \n    \n    Claiming rewards\n    Fees accumulate until claimed by delegators in a pull-based model. Staking rewards are manually retrieved by calling the validator specific Liquid Newton contract. This incurs transaction costs, so stake delegators should allow fees to accumulate until they exceed the gas cost of claiming them.\n    For details on how to claim and the functionality for claiming staking rewards, see:\n    \n    How to Claim Staking Rewards."
  },
  {
    "objectID": "concepts/staking/index.html#staking-accounts",
    "href": "concepts/staking/index.html#staking-accounts",
    "title": "Staking",
    "section": "Staking accounts",
    "text": "Staking accounts\n    The protocol makes use of different accounts for fee revenue collection and distribution.\n    \n    Staker account\n    The account address submitting a bond or unbonding request. A staker can bond stake across as many validators as it chooses. The msg.sender address of the request is the account that receives the staker’s due share of staking reward entitlements, and determines if the stake is delegated or self-bonded:\n    \n    \n    \n    Stake Delegation Type\n    Sending Address\n    \n    \n    \n    \n    delegated\n    msg.sender can be any network account except the validator treasury account\n    \n    \n    self-bonded\n    msg.sender is a validator treasury account\n    \n    \n    \n    \n    \n    Validator treasury account\n    The validator operator’s account address. The treasury is used as the account:\n    \n    Identifying the validator operator entity itself.\n    For submitting transactions to protocol contracts to register and operate the validator’s node and oracle server.\n    Receiving staking rewards from the protocol’s reward distribution mechanism for distribution to the validator’s stake delegators.\n    Receiving slashing rewards distributed by the accountability and fault detection protocol for reporting provable faults committed by an offending validator failing to follow consensus rules.\n    \n    See the treasury parameter of the config.autonity.validators object in the Protocol parameter reference.\n    \n    \n    Autonity treasury account\n    The Autonity Protocol’s treasury account for receiving treasury fees. See treasury parameter of the autonity.treasury object in the Protocol parameter reference.\n    ### Autonity Protocol Contract account\n    The Autonity Protocol’s contract account for holding staking rewards (serving as a ‘rewards pool’) until reward distribution occurs at epoch end.\n    The Autonity Contract account is generated automatically on deployment of the Autonity Protocol Contract at network genesis. See Protocol Contract Addresses for the address value."
  },
  {
    "objectID": "concepts/staking/index.html#temporal-constraints",
    "href": "concepts/staking/index.html#temporal-constraints",
    "title": "Staking",
    "section": "Temporal constraints",
    "text": "Temporal constraints\n    Slashing, unbonding and bonding operations are applied by protocol at specific time points. This is to ensure voting power changes are applied before committee selection for the next epoch, and to provide guarantees for network security. (I.E. slashing penalties can be applied, stake does not change during a committee ensuring stake cannot decrease while it is in power.)\n    Constraints:\n    \n    The committee is selected for an epoch duration.\n    Voting power changes are applied at epoch end before the committee for the next epoch is selected. These are adjustments to bonded stake amounts for validators caused by:\n    \n    Slashing stake for accountability and omissions faults.\n    Staking transitions from unbonding and bonding operations.\n    \n    \n    \n    epoch\n    A period of time measured as a number of blocks in which there is no change in consensus committee membership.\n    \n    \n    epochPeriod\n    The period of time for which a consensus committee is elected and defined as a number of blocks. The epoch period can be any integer number &gt; 0, but must be shorter than the unbonding period. Without this constraint unbonding could take place before slashing penalties and staking transitions are applied.\n    The duration of the epoch period is set at genesis by the epochPeriod parameter, see the Protocol parameter reference. The setting can be changed by governance calling the setEpochPeriod() function.\n    At each epoch rollover there is an evaluation of the bonded stake. As the last block of an epoch is finalized then:\n    \n    Voting power changes affected by staking transitions are applied.\n    The committee selection algorithm is run to choose members of the consensus committee for the upcoming epoch.\n    \n    Bonding and unbonding requests submitted during an epoch are processed and committed to state in the next available block, but the effect of such staking transitions is applied at epoch end.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Consensus committee member selection takes place at epoch end for computation and transactional efficiency.\n    Further, in an interoperability scenario where state is shared across chains, rather than submit a state proof of a new validator set every block, we only need to send a checkpoint of the validator set every epoch.\n    \n    \n    \n    \n    \n    unbondingPeriod\n    The period of time bonded stake must wait before Newton is redeemed to the staker after processing a stake redeem (unbond()) transaction, defined as a number of blocks. The unbonding period can be any integer number &gt; 0, but must be longer than the epoch period. There is no requirement for the unbonding period to be a multiple of the epoch period, just larger.\n    Stake remains at risk during the unbonding period; it is locked and in a non-transferrable state. This locking period is a protocol measure that gives the consensus protocol’s accountability and omissions mechanism time to identify and prove faults and apply penalties to bonded stake before stake is unlocked and redeemed. Byzantine behaviour cannot escape penalties by unbonding before a fault is detected.\n    The duration of the unbonding period is set at genesis by the unbondingPeriod parameter, see the Protocol parameter reference. The setting can be changed by governance calling the setUnbondingPeriod() function.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    In an unbonding scenario with an epoch period of 30 blocks, an unbonding period of 120 blocks, and an unbonding request issued at block 15 in the epoch. At block 15 the unbonding request is processed and then tracked in memory. At the end of that epoch, block 30, the validator’s voting power is reduced and the unbonded amount is added to the unbonding pool. The unbonding period expires at block 135. At the end of the epoch in which the unbonding period falls, block 150, the Newton that is due is returned to the stake delegator.\n    Stake remains at risk during the unbonding period. The amount of Newton returned to the delegator may be less than the original unbonded amount if the validator has been slashed between submitting the unbond request at block 15 and Newton redemption at block 150."
  },
  {
    "objectID": "concepts/staking/index.html#staking-transitions",
    "href": "concepts/staking/index.html#staking-transitions",
    "title": "Staking",
    "section": "Staking transitions",
    "text": "Staking transitions\n    Staking transitions are changes to stake bonded to validators caused by stake bonding and unbonding operations submitted by stake delegators.\n    Bonding and unbonding requests submitted during an epoch are processed and committed to state in the next available block, but the effect of such staking transitions is only applied at epoch end. Until epoch end, staking transitions are maintained in memory in BondingRequest and UnbondingRequest data structures. They can be read by listening for and viewing NewBondingRequest and NewUnbondingRequest events emitted by the bond() and unbond() functions of the Autonity Protocol Contract.\n    In Autonity’s AFD protocol, slashable faults are likewise processed throughout an epoch. Any changes to delegated stake that are caused by stake slashing are applied to unbonding and bonded stake at the epoch end according to Autonity’s Penalty-Absorbing Stake (PAS) model. This takes place before staking transitions are applied.\n    As noted in Protocol assets, Newton and Liquid Newton token can be in different states. Bonded and unbonding stake is liable to slashing penalties:\n    \n    Newton whilst locked in states bonded and unbonding\n    Liquid Newton in states locked and unlocked\n    \n    Whilst stake is unbonding, the protocol tracks the relative ownership of stake in the delegated and self-bonded unbonding pools via a “share” mechanism, so that the PAS slashing priority may be correctly applied to the unbonding stake, and the correct amount of delegated or self-bonded stake may be released at the end of the unbonding period.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Metadata providing the total amount of shares and unbonding stake is returned as part of the response when querying for a validator. See the getValidator() response object which contains fields for:\n    \n    delegated stake unbonding pool: unbondingStake and unbondingShares\n    self-bonded unbonding pool: selfUnbondingStake and selfUnbondingShares\n    \n    The shares and unbonding stake amounts for each unbonding request are stored in the UnbondingRequest object. See the NewUnbondingRequest event emitted by the unbond() for the object fields.\n    \n    \n    \n    \n    Bonding\n    Stake token is bonded to an active validator through a bonding operation. Once bonded, stake token is locked and cannot be transferred to other stakeholders. If bonded stake token belongs to the validator then it is self-bonded, otherwise the token is delegated. The voting power of a validator is determined by the amount of stake bonded to it.\n    On bonding Newton, the stake token is locked on execution of the bond() function and Liquid Newton is minted for delegated stake. Minting Liquid Newton is an autonomous protocol-only function. The resulting voting power change is tracked and the staking transition is applied at epoch end. From this point the stake is actively bonded and able to earn staking rewards. Note that a bond allocation cannot be changed after submission and before the bonding is applied at epoch end.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Alice sends bond() tx at time T, a block in an epoch. Newton is locked at T. The bonding request is tracked in memory for application at the end of the epoch. At this point, the validator’s bonded stake is increased, and Liquid Newton is issued to Alice in the validator’s Liquid Newton ERC20 contract. Actual bonding is then executed at T + remainder of the epoch. Liquid Newton issuance is delayed and not tradable while bonding is pending.\n    \n    \n    \n    Staking rewards are earned when a nominated validator is a consensus committee member. Bonding across more than one validator is allowed. The committee size is limited and staking rewards are limited to the number of validators in the current committee for the epoch.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Stake can only be bonded to a registered validator in an active state. A bonding request to an inactive validator (i.e. one in a paused, jailed, or jailbound state will revert). See Validator pausing, Validator jailing, and Validator lifecycle.\n    \n    \n    \n    \n    \n    Delegation\n    See Bonding above.\n    \n    \n    Unbonding\n    Stake is unbonded from a validator through an unbonding operation. Unbonding is subject to an unbonding period during which it remains locked. The unbonding period applies irrespective of whether the nominated validator is a member of the consensus committee or not.\n    Unbonding is triggered by a staker submitting an unbond() transaction. Unbonding can begin as soon as the unbond transaction request has been finalized. On processing the transaction, the bonded stake token moves from bonded to the intermediate state of unbonding. The stake is still locked during the unbonding period. The unbonding request is captured and tracked in memory. The staking transition is applied in two steps:\n    \n    at the end of the epoch in which the unbonding request was issued: the validator’s total bonded stake (and consequently voting power decreases by the unbonded amount when the unbonding is applied at the end of the epoch\n    at the end of the epoch in which the unbonding period expires: NTN for the unbonding stake amount are released to the delegator\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Alice submits an unbond() tx that is processed and included in a block at time T, where an UnbondingRequest object for the necessary voting power change is also created. At T+1, the unbonding period begins.\n    The unbonding request is tracked in memory for application at the end of the epoch in which T was processed, when the validator’s bonded stake amount and voting power is reduced as follows: - the designated amount of Liquid Newton amount is unlocked and burnt if the stake being unbonded is delegated - the amount of stake to reduce the unbonding pool by and Alice’s share of the unbonding pool is calculated - the amount of Newton bonded to the validator is reduced by the unbonding amount, consequently reducing the validator’s voting power\n    Then, at the end of the epoch in which the unbonding period (T+1 + unbonding period) expires, Newton redemption (i.e. ‘release’) occurs and the Newton that is due is minted to Alice’s Newton account.\n    Note that the amount of Newton released to Alice may be less than the original unbonded amount if the validator has been slashed between T and the end of the epoch in which the unbonding period expires."
  },
  {
    "objectID": "concepts/staking/index.html#slashing",
    "href": "concepts/staking/index.html#slashing",
    "title": "Staking",
    "section": "Slashing",
    "text": "Slashing\n    Bonded stake is subject to economic slashing penalties if misbehavior by the staked validator node is detected by the accountability and fault detection (AFD) protocol. The AFD protocol detects infractions of consensus rules by validators participating in consensus as consensus committee members.\n    \n    Economic penalties\n    Slashing penalties are applied by autonomous protocol action at epoch end as voting power cannot change mid epoch.\n    Economic penalties vary in severity and are applied according to the type of fault detected and the risk created for network security.\n    See concept Accountability and fault detection and slashing penalties for protocol logic and penalty computation.\n    \n    \n    Consequences for stake redemption\n    Bonding stake to a validator enters the staker in to a risk mutualization model shared with the validator, i.e. if the validator is penalized then the stake delegator may lose stake as consequence. This risk is realized when unbonding. Note, though, that Autonity’s Penalty-Absorbing Stake (PAS) model mitigates the risk to delegated stake.\n    As described in Liquid Newton, a conversion rate between Liquid Newton and Newton is maintained by the protocol’s tokenomics to ensure that a validator’s Liquid Newton tokens remain 1:1 fungible. As consequence, a staker can redeem staked Newton in full unless there has been a slashing event. In this circumstance, the stake redemption will be affected.\n    To illustrate:\n    \n    100 Newton is bonded at time T:\n    \n    100 Liquid Newton are issued, backed by 100 Newton\n    If a slashing penalty of 20 is applied to the validator at T + 1, then bonded stake is reduced to 80 and the 100 Liquid Newton issued are now backed by 80 Newton\n    The 100 Liquid Newton have a redemption value of 80 Newton\n    \n    An additional 100 Newton are bonded post slashing at time T + 2:\n    \n    125 LNTN are issued, i.e. current LNTN supply * new bonding amount / current bonded stake\n    \n    \n    The LNTN issuance ratio has increased in light of the reduced bonded stake amount. This compensates for the lower redemption value of LNTN given the reduction in bonded stake, and maintains the fungibility of the validator’s LNTN token.\n    To exemplify redemption in this scenario for a validator V:\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Time\n    Event\n    Amount\n    Liquid Newton Issued\n    Liquid Newton Supply\n    Newton Redeemed\n    Bonded Stake Amount\n    \n    \n    \n    \n    T\n    Bond Event\n    100 NTN\n    100\n    100\n    \n    100\n    \n    \n    T+1\n    Slashing Event\n    20 NTN\n    \n    100\n    \n    80\n    \n    \n    T+2\n    Bond Event\n    100 NTN\n    125\n    225\n    \n    180\n    \n    \n    T+3\n    Unbond Event\n    100 LNTN\n    \n    125\n    80\n    100\n    \n    \n    T+4\n    Unbond Event\n    125 LNTN\n    \n    0\n    100\n    0\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    In a trading context, if 100 Liquid Newton is purchased after this slashing event, then on redemption 80 Newton would be received. If the market price for Liquid Newton has dropped you would be purchasing it at a discount."
  },
  {
    "objectID": "concepts/client/index.html",
    "href": "concepts/client/index.html",
    "title": "Autonity Go Client (AGC)",
    "section": "",
    "text": "AGC is the reference implementation of the Autonity Protocol and the main client software run by participants in an Autonity network. It is a fork of Geth. For the current geth rebase version see Codebase."
  },
  {
    "objectID": "concepts/client/index.html#features",
    "href": "concepts/client/index.html#features",
    "title": "Autonity Go Client (AGC)",
    "section": "Features",
    "text": "Features\n    \n    Core logic\n    \n    Autonity Protocol Contract, the core Autonity Protocol contract providing operations for: protocol governance, staking, validator registration, consensus committee selection, and staking rewards distribution. See Autonity Protocol Contract.\n    Autonity Accountability Contract, the accountability and fault detection protocol contract providing operations for: returning accountability history and status, handling submitted accountability events, and computing accountability and slashing penalties. See Autonity Accountability Contract and concept Accountability and fault detection.\n    Autonity Oracle Contract, the oracle protocol contract providing operations for: computing median price data, and managing the currency-pair symbols for which price data is provided by the Autonity oracle network. See Autonity Oracle Contract and concepts Oracle Server and Oracle network.\n    EVM, the deterministic virtual machine providing the state transition function for computing global state\n    Consensus, Autonity implementation of the Tendermint BFT consensus protocol managing state replication and block production with dynamic committee selection. See Blockchain Consensus\n    P2P Networking, transport and wire protocols providing reliable broadcast for blockchain and consensus state synchronisation between participants. See Communication Layer\n    Core, the core Autonity Go Client codebase managing interactions with the blockchain ledger and EVM.\n    \n    \n    \n    State storage\n    Each participant maintains a local state database synchronised to world state, using a LevelDB k-v store. See also System model and the Ledger object.\n    \n    \n    Interfaces\n    The client provides interfaces for:\n    \n    Autonity Contract Interfaces and JSON-RPC APIs - see Autonity Interfaces Reference\n    RPC calls from the Autonity Utility Tool aut. aut provides a command-line interface to Autonity-specific queries and operations, as well as much of the base Ethereum functionality.\n    Command line options for client configuration and interaction - see Command-line options Reference\n    Metrics and logging, see Command-line options. For go-metrics, see the Autonity GitHub /metrics/README."
  },
  {
    "objectID": "concepts/validator/index.html",
    "href": "concepts/validator/index.html",
    "title": "Validator",
    "section": "",
    "text": "This section describes the role of validators, prerequisites for becoming a validator, and the validator lifecycle (registration, pausing, reactivation).\n    A validator is an Autonity full node with bonded stake that is eligible for selection to an Autonity Network’s consensus committee. As a member of the consensus committee its primary function is to ensure the integrity of system state.\n    To fulfil this purpose the validator participates in consensus computation with other members of the consensus committee:\n    \n    Proposing, voting, and validating new blocks in accordance with the rules of Autonity’s implementation of the Tendermint consensus mechanism.\n    Reporting infractions of consensus rules by committee members in the accountability and fault detection protocol.\n    Submitting price reports and voting on aggregated median price data for selected currency pairs in oracle protocol voting rounds.\n    \n    It has responsibilities to:\n    \n    Propose blocks of ordered transactions as the leader of a consensus round.\n    Validate that proposed blocks contain only valid state transitions.\n    Vote in consensus rounds, exchanging consensus messages with committee members as the consensus protocol executes.\n    Maintain system state by committing new blocks to state as a consensus round completes.\n    Propagate new blocks to the network at the end of a consensus round, sending the full block if round leader otherwise sending a new block announcement.\n    Provide bonded stake to the Proof of Stake consensus mechanism, providing locked stake for network security economics.\n    Participate in the accountability and fault detection protocol, detecting and submitting accountability events committed by other committee members. See concept accountability and fault detection protocol.\n    Participate in the oracle protocol, inputting raw price data and voting for aggregated median price data for currency pairs provided by the Autonity network during oracle voting rounds. See concept oracle network.\n    \n    As an entity contributing bonded stake to secure the network a validator active in the consensus committee is economically incentivised toward correct behaviour and disincentivised from Byzantine behaviour by stake slashing and penalty mechanisms implemented by an accountability and fault detection protocol. Consensus committee members are incentivised by staking rewards, receiving a share of the transaction fee revenue earned for each block of transactions committed to system state, pro rata to their share of bonded stake securing the system in that block. Consensus committee members are incentivised to report Byzantine behaviour by other committee members by slashing rewards for reporting accountability faults resulting in a penalty.\n    \n    \n    To operate as a validator node, the operator must operate Autonity oracle server software as an adjunct to its Autonity full node software.\n    Prerequisites for becoming a validator node operator are:\n    \n    A validator enode URL. A node joined to the network.\n    An oracle server configured to collect external price data from off-chain data providers, and connected to the operator’s validator node for on-chain submission of price reports.\n    A treasury account. An EOA account that is the validator node operator’s online identity and which:\n    \n    Is the msg.sender() account used by the operator to submit state affecting transactions that govern the validator lifecycle.\n    Will receive the validator’s share of staking rewards."
  },
  {
    "objectID": "concepts/validator/index.html#overview",
    "href": "concepts/validator/index.html#overview",
    "title": "Validator",
    "section": "",
    "text": "This section describes the role of validators, prerequisites for becoming a validator, and the validator lifecycle (registration, pausing, reactivation).\n    A validator is an Autonity full node with bonded stake that is eligible for selection to an Autonity Network’s consensus committee. As a member of the consensus committee its primary function is to ensure the integrity of system state.\n    To fulfil this purpose the validator participates in consensus computation with other members of the consensus committee:\n    \n    Proposing, voting, and validating new blocks in accordance with the rules of Autonity’s implementation of the Tendermint consensus mechanism.\n    Reporting infractions of consensus rules by committee members in the accountability and fault detection protocol.\n    Submitting price reports and voting on aggregated median price data for selected currency pairs in oracle protocol voting rounds.\n    \n    It has responsibilities to:\n    \n    Propose blocks of ordered transactions as the leader of a consensus round.\n    Validate that proposed blocks contain only valid state transitions.\n    Vote in consensus rounds, exchanging consensus messages with committee members as the consensus protocol executes.\n    Maintain system state by committing new blocks to state as a consensus round completes.\n    Propagate new blocks to the network at the end of a consensus round, sending the full block if round leader otherwise sending a new block announcement.\n    Provide bonded stake to the Proof of Stake consensus mechanism, providing locked stake for network security economics.\n    Participate in the accountability and fault detection protocol, detecting and submitting accountability events committed by other committee members. See concept accountability and fault detection protocol.\n    Participate in the oracle protocol, inputting raw price data and voting for aggregated median price data for currency pairs provided by the Autonity network during oracle voting rounds. See concept oracle network.\n    \n    As an entity contributing bonded stake to secure the network a validator active in the consensus committee is economically incentivised toward correct behaviour and disincentivised from Byzantine behaviour by stake slashing and penalty mechanisms implemented by an accountability and fault detection protocol. Consensus committee members are incentivised by staking rewards, receiving a share of the transaction fee revenue earned for each block of transactions committed to system state, pro rata to their share of bonded stake securing the system in that block. Consensus committee members are incentivised to report Byzantine behaviour by other committee members by slashing rewards for reporting accountability faults resulting in a penalty.\n    \n    \n    To operate as a validator node, the operator must operate Autonity oracle server software as an adjunct to its Autonity full node software.\n    Prerequisites for becoming a validator node operator are:\n    \n    A validator enode URL. A node joined to the network.\n    An oracle server configured to collect external price data from off-chain data providers, and connected to the operator’s validator node for on-chain submission of price reports.\n    A treasury account. An EOA account that is the validator node operator’s online identity and which:\n    \n    Is the msg.sender() account used by the operator to submit state affecting transactions that govern the validator lifecycle.\n    Will receive the validator’s share of staking rewards."
  },
  {
    "objectID": "concepts/validator/index.html#validator-identity-accounts-and-keypairs",
    "href": "concepts/validator/index.html#validator-identity-accounts-and-keypairs",
    "title": "Validator",
    "section": "Validator identity, accounts and keypairs",
    "text": "Validator identity, accounts and keypairs\n    The validator makes use of different accounts and private/public key pairs for validator lifecycle management (registration, pausing, reactivation), validator identity, staking rewards, consensus participation and cryptographic security.\n    \n    P2P node keys: autonityKeys\n    The private/public key pair of the validator node.\n    The private key is used:\n    \n    By a node for negotiating an authenticated and encrypted connection between other network nodes at the devp2p layer in the RLPx Transport Protocol.\n    To generate the proof of enode ownership required for validator registration. The proof is generated using the genEnodeProof command-line option of the Autonity Go Client.\n    \n    The public key is used:\n    \n    As the identifier or ‘node ID’ of the node (in RLPx and node discovery protocols).\n    As the PUBKEY component of the enode URL as a hex string.\n    To verify the signature of consensus level network messages.\n    To derive an ethereum format account that is then used to identify the validator node. See validator identifier.\n    \n    ::: {.callout-note title=“Note” collapse=“false”}The private key can be used by Autonity’s bootnode utility to derive the hex string used in the enode URL. (See Networking Options nodekey and nodekeyhex in Autonity command-line options and, for reference, the ethereum stack exchange article how to produce enode from node key.):::\n    \n    \n    Validator enode URL\n    The enode URL is the network address of the peer node operated by the validator. It provides the network location of the node client for p2p networking.\n    The enode URL format is described in the ethereum Developers docs.\n    It takes the form:\n    enode://PUBKEY@IP:PORT\n    The PUBKEY component is the public key from the P2P node key. The PUBKEY is static. The IP and PORT COMPONENTS may change over time.\n    The PUBKEY component is used to derive an ethereum format account address that is used as the validator identity in validator registration, staking, and accountability and omissions operations - see validator identifier.\n    \n    \n    Validator identifier\n    A unique identifier for the validator used as the validator identity in validator lifecycle management (registration, pausing, reactivation), staking, and accountability and omissions operations. It provides an unambiguous relationship between validator identity and node. For example, it is used to identify the validator in a bond stake function call.\n    The identity is created as an ethereum format account address, derived on registration by protocol logic from the PUBKEY component of the validator node’s enode URL. It is stored in the nodeAddress field in the Validator data struct maintained in state.\n    Note that the identifier is the validator node’s on-chain identity and is distinct from the treasury account which is the validator operator’s account.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    An account address rather than the PUBKEY of the enode url is used to make use of the address datatype in function calls.\n    \n    \n    \n    \n    \n    Treasury account\n    The treasury account is the Autonity Network account used by a validator to submit transactions for validator lifecycle management transactions and to receive its share of staking rewards. It uses a different private/public key pair with respect to the p2p node key. This is because those keys may have different security requirements, as well as because multiple validators could use the same treasury account.\n    \n    \n    Oracle identifier\n    A unique identifier for the Autonity Oracle Server providing price data reports to the validator node.\n    The identity is created as an ethereum format account address and provided as a validator registration parameter. For more information see concept oracle network and oracle identifier."
  },
  {
    "objectID": "concepts/validator/index.html#validator-lifecycle",
    "href": "concepts/validator/index.html#validator-lifecycle",
    "title": "Validator",
    "section": "Validator lifecycle",
    "text": "Validator lifecycle\n    Validator lifecycle management comprises registration, participation in the consensus committee, jailing for accountability faults, pausing, and reactivation.\n    The sequence of lifecycle events for a validator is:\n    \n    Join the network. The validator’s main client software is admitted to the P2P network as a peer node, syncing state on connection.\n    Configure oracle server and data sources. Pre-validator registration, the validator installs the oracle server software and configures data sources for price data provision.\n    Register as a validator. The validator’s node is registered as a validator by the submission of registration parameters.\n    Stake bonding. Stake is bonded to the validator, either by the validator itself or by delegation from a stake token holder. Once the validator has an amount of stake bonded to it, then it is eligible for inclusion in the committee selection process.\n    Selection to consensus committee. In the last block of an epoch, the committee selection process is run and a validator may be selected to the consensus committee for the next epoch. Whilst a member of the consensus committee it is responsible for participating in (a) block validation, proposing and voting on new blocks, and (b) oracle price data submission and voting.\n    Jailed for accountability fault. If a validator is found guilty by the accountability and fault detection protocol of failing to adhere to consensus rules as a member of the consensus committee, then jailing may be applied. In this state the validator is jailed and excluded from consensus committee selection for a computed duration.\n    Depending on the gravity of the fault committed, jailing may be temporary or permanent and the validator will enter a jailed or jailbound state:\n    6.a. Temporary jailing: jailed state. The validator is impermanently jailed for a number of blocks. The block height at which the jail period ends is recorded in the validator’s state as the jailReleaseBlock property. After expiry of the jail period the validator may be re-activated to resume an active state.\n    6.b. Permanent jailing: jailbound state. In this state the validator is permanently jailed and becomes jailbound. Permanent jailing is only applied in the case where a validator is found guilty by the accountability and fault detection protocol of a fault with a 100% stake slashing penalty as a member of the consensus committee.\n    Pause as a validator. The validator’s node enters a paused state in which it is no longer included in the committee selection process. The validator is paused from active committee participation until re-activated. Stake is not automatically unbonded.\n    Re-activate as a validator. The validator’s node transitions from a paused or jailed state to resume an active state in which it is eligible for inclusion in the committee selection process.\n    \n    Validator registration can take place at genesis initialisation or after genesis. In the genesis scenario, event steps 1-4 happen automatically as the network is initialised and the validator is included in the genesis run of the committee selection process. After genesis, all lifecycle steps are discrete and initiated by the validator node operator entity.\n    \n    Eligibility for selection to consensus committee\n    A validator becomes eligible for selection to the consensus committee when:\n    \n    It is registered and has an active state. Registration is complete: the validator’s registration parameters and state are recorded in the validators data structure maintained by the Autonity Protocol Contract.\n    It has non-zero bonded stake. The amount of stake bonded to the validator, recorded in the validators data structure, is greater than 0.\n    \n    Eligible validators are included in the committee selection algorithm. The algorithm is run at block epoch end to choose the committee for the upcoming epoch.\n    \n    \n    Jailing and exclusion from consensus committee\n    A validator may be found guilty by the accountability and fault detection protocol of failing to adhere to consensus rules when a member of the consensus committee. In this case, depending on the type of fault committed, jailing for a computed number of blocks may be applied as part of a slashing penalty.\n    On entering a jailed state a validator is ignored by the consensus committee selection algorithm and cannot be elected as a consensus committee member. The duration of validator jailing may be temporary or permanent depending on how serious the committed accountability fault has been. If temporary, the validator enters a jailed state. If permanent, the validator enters a jailbound state.\n    For further detail see Validator jailing on this page."
  },
  {
    "objectID": "concepts/validator/index.html#stake-bonding-and-delegation",
    "href": "concepts/validator/index.html#stake-bonding-and-delegation",
    "title": "Validator",
    "section": "Stake bonding and delegation",
    "text": "Stake bonding and delegation\n    Validators are staked with Autonity’s Newton stake token. A genesis validator must bond stake at genesis. After genesis, a validator can bond their own Newton and have Newton staked to them by delegation from other Newton token holders at any time.\n    Autonity implements a Penalty-Absorbing Stake (PAS) model and a liquid staking model.\n    In this model:\n    \n    Penalty-Absorbing Stake (PAS): self-bonded stake is slashed before delegated stake, ensuring the validator has “skin in the game” and incentivising reliable and honest validator operations and behaviour.\n    Liquid staking: delegated stake has Liquid Newton minted to the staker in proportion to the amount of Newton staked to a validator.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Note that: - Liquid Newton is not minted for self-bonded stake. For rationale see Penalty-Absorbing Stake (PAS). - Staking rewards accrue to all bonded stake active in the current consensus committee; delegated and self-bonded stakers earn staking rewards pro rata to their share of the validator’s total bonded stake.\n    \n    \n    \n    Account addresses owning liquid newton and receiving staking reward revenue are:\n    \n    EOA accounts that have bonded delegated stake to a validator node, or have been recipients of a liquid newton transfer.\n    Contract accounts that have been recipients of a liquid newton transfer from an EOA or a contract account.\n    \n    For clarity, these are the msgSender() addresses of the account submitting registerValidator() and bond() transactions to the Autonity Network.\n    Autonity implements an ‘active epoch’ staking model, applying staking transitions for bonding and unbonding at the end of each block epoch.\n    Stake is bonded and redeemed by Newton holders submitting transaction requests to the Autonity Protocol Contract. These requests are recorded in state on submission as BondingRequest and UnbondingRequest data structures in the Autonity Protocol Contract state, but there is a temporal delay in effect. Voting power cannot change mid-epoch and so staking transitions are applied at epoch end before the next committee selection is run.\n    Stake is bonded by submitting a bonding request transaction to the bond() function and redeemed by the converse, to the unbond() function. In the bonding scenario, liquid newton is minted for delegated stake and the Validator’s total bonded stake amount updated in the final block of the epoch. Stake redemption by contrast is an incremental process: liquid newton for delegated stake is burned immediately on processing of the unbond() function call, the validator’s total bonded stake amount is updated at epoch end, the newton is issued (i.e. minted) to the staker at the end of the unbonding period. If the unbonding request is included in block T, then actual unbonding is then executed at T + unbondingPeriod + remainder of the epoch in which the unbonding period falls. At this point, the staker’s due newton is minted to them."
  },
  {
    "objectID": "concepts/validator/index.html#validator-economics",
    "href": "concepts/validator/index.html#validator-economics",
    "title": "Validator",
    "section": "Validator economics",
    "text": "Validator economics\n    Validator economic returns are determined by the amount of stake bonded to them, their participation in the consensus committee, commission rate, and any slashing penalties applied for accountability and omissions.\n    Staking reward revenue is proportionate to the validator’s share of the stake active in a consensus round in which it participates. Staking rewards are distributed to consensus committee members pro rata to the amount of stake they have at stake. Validators can earn from:\n    \n    Staking rewards earned from their own self-bonded stake.\n    Commission charged on delegated stake per the delegation rate they charge as commission.\n    The priority fee ‘tip’ that may be specified in a transaction and which is given to the block proposer as an incentive for including the transaction in a block.\n    Slashing rewards earned for reporting slashed faults in the accountability and fault detection protocol.\n    \n    Staking reward revenue potential is determined by the frequency with which a validator is an active member of the consensus committee. This is driven by:\n    \n    The amount of stake the validator has bonded to it.\n    The committee size and number of registered validators.\n    The frequency with which the validator proposes blocks.\n    The amount of transaction revenue earned from transactions included in blocks committed when the validator is a member of the committee.\n    The validator’s commission rate. The percentage amount deducted by a validator from staking rewards before rewards are distributed to the validator’s stake delegators. The rate can be any value in the range 0 - 100%. At registration all validators have commission set to a default rate specified by the Autonity network’s genesis configuration. (See Reference Genesis, delegationRate.) After registration the validator can modify its commission rate - see Validator commission rate change on this page.\n    \n    Bonded stake may be slashed and/or staking rewards may be reduced or forfeited by slashing penalties applied to the validator for accountable faults. The extent of the fine varies according to the severity of the fault committed. See Concept accountability and fault detection protocol and slashing economics."
  },
  {
    "objectID": "concepts/validator/index.html#validator-registration",
    "href": "concepts/validator/index.html#validator-registration",
    "title": "Validator",
    "section": "Validator registration",
    "text": "Validator registration\n    A validator is registered at or after genesis by submitting registration parameters to the Autonity Network. Prerequisites for registration are:\n    \n    The validator has a node address (an enode URL).\n    The validator has a connected oracle server.\n    The validator has a funded account on the network.\n    \n    A validator’s registration is recorded and maintained as a state variable in a Validator data structure. (See registerValidator()).\n    \n    Genesis registration\n    At genesis the process is:\n    \n    Registration parameters for the genesis validator set are listed in the network’s genesis configuration file (Seevalidators struct):\n    \n    treasury - the account address that will receive staking rewards the validator earns.\n    enode - the enode URL of the validator node.\n    oracleAddress - the identifier address of the validator node’s connected oracle server.\n    bondedStake - the amount of stake the validator is bonding at genesis.\n    delegationRate - the amount of commission that the validator will charge on staking rewards earned from delegated stake. This is a global value set for all validators, specified by the delegationRate parameter in the genesis configuration file.\n    \n    Example:\n    {\n \"treasury\": \"0xd0A5fB6A3CBD7cB0328ae298598527E62bE90A0F\",\n \"enode\": \"enode://bdbae1dede11147d0f1de2b6339a25fae9d46edfbeb48b3441d8dfff5d396bcb0b99f2ade05bf37239451f9a  dc60015f7a7b744321ea9a845b7c3a1f1ebd73e3@127.0.0.1:5003\",\n \"oracleAddress\":\"0x636d3D9711F0f3907313dC5E2Aa08e73c0608A03\",\n\"bondedStake\": 10000\n},\n    Genesis of the Autonity Network is initialised and for each validator:\n    \n    The registerValidator() function is called. The registration metadata is recorded in a Validator state variable data structure. A Liquid Newton ERC20 contract is deployed for the Validator and recorded in the Liquid Newton Contract Registry maintained by the Autonity Protocol Contract.\n    A RegisteredValidator event is emitted by the Autonity Protocol Contract.\n    The bond() function is called. The bondedStake amount is bonded to the validator’s address and a corresponding amount of Liquid Newton minted to the validator’s treasury account address. This is recorded in a Staking state variable data structure ready to be applied to the genesis state.\n    \n    \n    The validator is registered and eligible for selection to the genesis consensus committee.\n    Note that genesis registration requires the validator self-bond stake. The chain will not deploy if bondedStake for a genesis validator is null. This constraint guarantees genesis validators have stake and are eligible for selection to the consensus committee. This mitigates the risk of having no consensus committee for the genesis block and so a chain halt at initialisation!\n    \n    \n    Post-genesis registration\n    After genesis the process is:\n    \n    Prospective validator submits a registration request transaction to the Autonity Protocol Public APIs, calling the registerValidator() function to submit the Validator registration parameters enode URL, oracleAddress oracle identifier, and a proof of node ownership generated from the private key of the validator node’s P2P node key and the validator’s oracle server key. The transaction msgSender() address is used for the validator’s treasury parameter value. The registration metadata is recorded in a Validator state variable data structure. A Liquid Newton ERC20 contract is deployed for the Validator and recorded in the Liquid Newton Contract Registry maintained by the Autonity Protocol Contract.\n    A RegisteredValidator event is emitted by the Autonity Protocol Contract.\n    To bond stake to the validator, the staker submits a bonding request transaction to the Autonity Protocol Public APIs, calling the bond() function with its validator address (enode) and the bonded stake amount. This is recorded in a Staking state variable data structure ready to be applied at epoch end\n    \n    The validator is registered and eligible for selection to the consensus committee.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Note that registration after genesis allows a validator to register with zero bonded stake. The validator bonds stake after registration to become eligible for committee selection."
  },
  {
    "objectID": "concepts/validator/index.html#validator-accountability",
    "href": "concepts/validator/index.html#validator-accountability",
    "title": "Validator",
    "section": "Validator accountability",
    "text": "Validator accountability\n    Validators may be held accountable by the Accountability and fault detection protocol (AFD) for failing to adhere to consensus rules when a member of the consensus committee.\n    Depending on the severity of the accountability fault committed, a validator may suffer: stake slashing according to autonity’s Penalty-Absorbing Stake (PAS) model, the loss of staking rewards earned as a member of the current consensus committee, and validator jailing.\n    Accountability is applied at the end of each epoch when the AFD protocol processes slashable faults and for each offending validator:\n    \n    Computes the slashing amount and jailing punishment, a count of blocks for which the validator is ‘in jail’ and excluded from selection to the consensus committee.\n    Applies the slashing amount fine.\n    Applies validator jailing if applicable, changing the validator’s state from active to one of jailed or jailbound.\n    Emits a SlashingEvent event detailing: validator identifier address, slashing amount, jail release block: the block number at which the jail period expires or 0 if the validator is permanently jailed and in a jailbound state."
  },
  {
    "objectID": "concepts/validator/index.html#validator-jailing",
    "href": "concepts/validator/index.html#validator-jailing",
    "title": "Validator",
    "section": "Validator jailing",
    "text": "Validator jailing\n    A validator can be jailed by protocol as a penalty for failing to adhere to consensus rules when serving as a member of the consensus committee. If a slashing penalty imposes jailing, this will be applied at epoch end when the penalty is processed.\n    On jailing the validator is transitioned by protocol from an active to a jailed or jailbound state. Jailing is either temporary or permanent:\n    \n    On temporary jailing the validator enters a jailed state and is impermanently jailed for a number of blocks, the jail period. To get out of jail and resume an active state, the validator operator must reactivate their validator. This can be done at any point after expiry of the jail period. Returned to an active state, the validator is again eligible for selection to the consensus committee.\n    On permanent jailing the validator enters a jailbound state and is permanently jailed. It becomes jailbound and cannot get out of jail. Permanent jailing is only applied in the case where a validator is found guilty by the accountability and fault detection protocol of a fault with a 100% stake slashing penalty as a member of the consensus committee.\n    \n    Note that:\n    \n    On jailing a validator is ignored by the committee selection algorithm run at the epoch end.\n    New stake delegation transactions bonding stake are reverted until the validator resumes an active state. Pending stake delegation requests (bonding, unbonding) submitted before a jailing event are still applied.\n    The Validator’s Liquid Newton remains transferrable and redeemable for Newton while the validator is jailed.\n    The information that the validator is being jailed and barred from active validator duty is visible to delegators."
  },
  {
    "objectID": "concepts/validator/index.html#validator-pausing",
    "href": "concepts/validator/index.html#validator-pausing",
    "title": "Validator",
    "section": "Validator pausing",
    "text": "Validator pausing\n    A validator can pause from active committee participation by submitting a pause request to the Autonity Network. Once the pause request has been processed the validator’s state changes from active to paused. In this state:\n    \n    It is ignored by the committee selection algorithm run at the epoch end.\n    New stake delegations are not accepted.\n    That the validator is pausing from active validator duty is visible to potential delegators (from event data).\n    \n    Note that:\n    \n    Pending stake delegation requests (bonding, unbonding) submitted before the pause request was processed are still applied.\n    The Validator’s Liquid Newton remains transferrable and redeemable for Newton while a pause request is ‘pending’ application at effective block and after pausing has been ‘applied’.\n    Unbonding of stake from the validator is not automated and has to be initiated by the staker.\n    \n    The process is:\n    \n    The validator operator entity submits a pause request transaction to the Autonity Protocol Public APIs, calling the pauseValidator() function, submitting the transaction from the account used to register the validator (validator treasury account) and passing in the validator identifier address.\n    Transaction processed and committed to state:\n    \n    The validator’s state is changed from active to paused.\n    A PausedValidator event is emitted detailing: validator operator entity treasury address, validator identifier address, effective block height at which pausing takes effect: projected block number for epoch end.\n    \n    Pause request tracked for execution until effective block height: epoch end.\n    Validator pausing is applied at epoch end before the next committee selection is run.\n    \n    The validator is paused and ignored by the committee selection algorithm. Stake delegation transactions bonding stake are reverted until the validator resumes an active state.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Pausing has no impact on unbonding constraints. For example, if a validator pauses at time T and a staker immediately detects the PausedValidator event and submits an unbond transaction at time T+1, the unbonding period begins to count at T+1. Unbonding is then executed at T+1 + unbondingPeriod + remainder of the epoch in which unbondingPeriod falls."
  },
  {
    "objectID": "concepts/validator/index.html#validator-re-activation",
    "href": "concepts/validator/index.html#validator-re-activation",
    "title": "Validator",
    "section": "Validator re-activation",
    "text": "Validator re-activation\n    A validator can re-activate and resume active committee participation by submitting an activate request to the Autonity network. Once the activate request has been submitted the validator’s state changes from its inactive state (paused or jailed) to active. In this state:\n    \n    It is again included by the committee selection algorithm run at the epoch end.\n    New stake delegations are accepted.\n    That the validator is resuming active validator duty is visible to potential delegators.\n    \n    Note that:\n    \n    New stake delegation requests bonding stake to the validator submitted after the activate request was processed no longer revert and are accepted.\n    \n    The process is:\n    \n    The validator operator entity submits an activate request transaction to the Autonity Protocol Public APIs, calling the activateValidator() function, submitting the transaction from the account used to register the validator (validator treasury account) and passing in the validator identifier address.\n    Transaction processed and committed to state:\n    \n    The validator’s state is changed from its inactive state (paused or jailed) to active.\n    An ActivatedValidator event is emitted detailing: validator operator entity treasury address, validator identifier address, effective block height at which re-activation takes effect: projected block number for epoch end.\n    \n    \n    The validator is active, able to accept new stake delegations, and once again eligible for selection to the consensus committee."
  },
  {
    "objectID": "concepts/validator/index.html#validator-commission-rate-change",
    "href": "concepts/validator/index.html#validator-commission-rate-change",
    "title": "Validator",
    "section": "Validator commission rate change",
    "text": "Validator commission rate change\n    A validator operator can modify its validator commission rate from the global default rate set for the validator on initial registration (see Reference Genesis, delegationRate) by submitting a commission rate change request to the Autonity Network.\n    Commission rate changes are subject to the same temporal unbonding period constraint as staking transitions. This gives the stake delegator protection from validator commission rate changes intra-epoch.\n    The process is:\n    \n    The validator operator entity submits a commission rate change request transaction to the Autonity Protocol Public APIs, calling the changeCommissionRate() function, submitting the transaction from the account used to register the validator (validator treasury account) and passing in the validator identifier address and the new commission rate in basis points (bps).\n    Transaction processed and committed to state:\n    \n    The commission rate change request is tracked in memory and the unbonding period lock constraint begins.\n    The rate change is applied at the end of the epoch in which the unbonding period expires as the last block of the epoch is finalised.\n    A CommissionRateChange event is emitted detailing: validator identifier address, new rate value.\n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    A stake delegator can use the CommissionRateChange event to listen for upcoming commission rate changes. The effective block of the commission rate change can then be calculated from data points: the changeCommissionRate transaction commit block number, and the network unbondingPeriod and epochPeriod values."
  },
  {
    "objectID": "concepts/system-model/index.html",
    "href": "concepts/system-model/index.html",
    "title": "System model",
    "section": "",
    "text": "An Autonity network is a distributed blockchain system comprised of peer nodes running client software executing the Autonity Protocol. It is a permissionless network: nodes can leave and join the network on demand. On connecting to an Autonity network a node becomes a participant of the distributed system and one of the processes comprising the system’s distributed virtual machine. Each participant maintains a local copy of the system’s distributed ledger, maintains synchrony with network time, and as a validator participates in consensus computation of system state. Autonity is an eventually synchronous distributed system utilising Tendermint BFT consensus protocol, the Ethereum EVM, and reliable networking protocols to synchronise time and replicate state across the system."
  },
  {
    "objectID": "concepts/system-model/index.html#participants",
    "href": "concepts/system-model/index.html#participants",
    "title": "System model",
    "section": "Participants",
    "text": "Participants\n    A participant is a network node connected to an Autonity distributed system and forming part of the system’s distributed virtual machine. Participants run a peer node running main client software implementing the Autonity Protocol, i.e. the Autonity Go Client (AGC) software, communicate with one another over networking protocols in Autonity’s communication layer, execute state transitions in the EVM Ethereum runtime environment, and have read and write access to the system ledger. Each participant maintains an up-to-date copy of system state in a ledger object.\n    Participants are secured and uniquely identified by public key cryptography. Each participant has a public and private keypair (node key) for signing the messages it broadcasts at the communication layer. This message signature allows cryptographic verification of message sender identity by recipient participants.\n    Each participant node has:\n    \n    A keypair - the node key. The private key is used to sign messages in the communication layer. The public key is used to uniquely identify the participant:\n    \n    Public keys are accessible to other participants and a participant can identify other participants by their public key.\n    It is used to derive participant identifier and network address.\n    \n    A unique network address (the enode URL).\n    If a participant is registered as a validator, then an address derived determinstically from the node key public key is used as the validator identifier address.\n    \n    Participants can register as validators and have stake bonded to them as described in the Validator section. Consequently the set of participants can be subdivided into divisions or subclassed as:\n    \n    The set of possible validator participants, and, for those validators selected to the consensus committee,\n    The set of committee members. Validators in the consensus committee also participate in the oracle network.\n    \n    The committee is dynamically maintained and selection is a deterministic function of the protocol - see Committee member selection.\n    A committee member participates in Tendermint Consensus instances, voting for and deciding on proposed blocks. Blocks endorsed by two-thirds or more of the committee’s voting power are appended to the blockchain. The validator votes for a block are recorded in the block header committedSeals field.\n    System actors submit calls and state affecting transactions to the system by RPC to Autonity Interfaces provided by Autonity Go Client nodes."
  },
  {
    "objectID": "concepts/system-model/index.html#networking",
    "href": "concepts/system-model/index.html#networking",
    "title": "System model",
    "section": "Networking",
    "text": "Networking\n    An Autonity system has a full mesh network topology. Each participant is connected to every other participant by a direct TCP/IP connection. This gives a reliable and eventually synchronous channel for message broadcast between peers.\n    Eventual synchrony is a model described by a Global Stabilisation Time (GST) and a Delta time. If a message is sent by a participant at time _t, then the message is received by time max{t,GST} + Delta, Delta &gt; 0 and unknown by all the participants. Client logic verifies if a received message has been sent to a participant before forwarding, preventing duplicate message sends. The Tendermint algorithm assumes that at GST + Delta, all the consensus messages sent at GST should have been received by committee members.\n    The principal message primitives of the networking communication layer are:\n    \n    Transaction: valid transaction messages submitted to clients from the external environment, broadcast for processing.\n    Block announcement: notification of a new block sent by consensus committee members.\n    Consensus, Tendermint consensus messages sent by and forwarded between committee members during consensus rounds.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Transaction calls execute against local state and are not broadcast to the network, per standard Ethereum.\n    \n    \n    \n    \n    P2P networking protocols\n    Peer to peer gossiping is separated into two channels: ethereum wire protocol for transaction gossiping, and a dedicated consensus channel for consensus gossiping during Tendermint BFT consensus rounds. These run on different TCP ports, defaults of 30303 and 20203 respectively.\n    \n    \n    Separate channels for transaction and consensus gossiping\n    Gossiping separation improves network scalability and robustness as consensus is shielded from transaction volume growth, whilst the separation of concerns allows each gossiping channel to be managed independently (e.g. socket buffering). For example, a validator node operator can setup their IP and port configuration to prioritise a robust network for the consensus channel.\n    Autonity implements Tendermint BFT consensus as an independent consensus protocol running alongside the ethereum wire protocol. Logically, this can be considered as a separate Autonity Consensus Network (ACN) layer. By default, the consensus protocol is configured to use port 20203 and assumes the IP to be the same as the Ethereum wire protocol IP. If a validator wishes to use a different IP and/or port combination for the consensus network, they can specify this information in the enode URL\n    The standard Ethereum enode URL is composed of:\n    \n    protocol (or scheme): the enode URL scheme enode://\n    username: the node ID, the public key of the node’s autonitykeys, a hex string\n    hostname: the IP address and TCP listening port of the node, i,e. the ethereum wire protocol, separated from the username by an @: ip:port\n    (optionally) query parameter ?discport: the UDP (discovery) port if different to the TCP port\n    \n    Autonity simply uses the standard URL scheme to specify the consensus channel ip:port in the query parameter:\n    \n    (optionally) acn=ip:port: IP and port information for the consensus channel is added as a query parameter.\n    \n    Valid enode url query parameter forms for specifying non-default consensus channel ip:port could be:\n    \n    ...@127.0.0.1:30303?acn=127.0.0.1:20203: ip and port\n    ...@127.0.0.1:30303?discport=30301&acn=127.0.0.1:20203: ip and port\n    ...@127.0.0.1:30303?acn=127.0.0.1: ip only\n    ...@127.0.0.1:30303?discport=30301&acn=127.0.0.1: ip only\n    ...@127.0.0.1:30303?acn=:20203: port only\n    ...@127.0.0.1:30303?discport=30301&acn=:20203: port only\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Separate transaction and consensus gossiping channels is a logical and physical segregation as each type of traffic is on a separate socket. Although CPU and memory resources remain shared, the design ensures that gossiping of consensus traffic is not delayed due to transaction traffic on the same socket queue.\n    The design allows validator node operators the flexibility to configure distinct networks (not necessarily different hosts) to set the network quality for consensus and transaction traffic.\n    Ideally, operators should opt for a higher-bandwidth network for transactions and a network with a higher reliability guarantee for consensus traffic."
  },
  {
    "objectID": "concepts/system-model/index.html#system-state",
    "href": "concepts/system-model/index.html#system-state",
    "title": "System model",
    "section": "System state",
    "text": "System state\n    Autonity inherits Ethereum’s state model, ledger trie structures, and transaction state machine. Per Ethereum the state of the system incrementally evolves from genesis state as blocks are decided and appended to the ledger, each individual transaction forming a valid arc between state transitions to an account. The world (or global) state of the system comprises the mapping between accounts and their states, recorded in the distributed ledger maintained by participants. Per Ethereum, a participant can compute the current world state of each account on the system at any time by using the ledger and EVM, and applying in order the sequence of transactions from genesis block to current block height.\n    At network genesis the ledger state comprises the Autonity Protocol Contracts and the genesis block state as set in the genesis configuration file. The genesis block contains the initial set of participant validators and smart contracts, both with their states. The initial smart contracts are: Autonity Protocol Contract, Autonity Oracle Contract, genesis validator liquid newton contracts, and optionally additional contracts deployed using the alloc structure in the genesis file. Initial smart contract state is Autonity Protocol and Oracle Contract parameterisation and genesis validator liquid newton contract bonded stake.\n    \n    The Ledger Object\n    Each participant maintains a local copy of the system state in a local ledger object, the participant’s state database. Per Ethereum, the blockchain state is persisted as a directed rooted tree using a modified Merkle Patricia tree (trie) structure in RLP serialisation, each tree node linked by a cryptographic hash. (See Ethereum Yellow Paper Appendix B Recurisve Length Prefix, Appendix D Modified Merkle Patricia Tree).\n    The ledger is an append-only immutable data structure with the property that new data can be appended and existing data is immutable. Blocks are appended to the chain over time at the interval set by the protocol (block period), each block pointing back toward the root, the genesis block. A block once committed is an immutable object whose state cannot be changed. It cannot be altered - cf. finality. Immutability is assured by the cryptographically verifiable tree structure of the ledger object; it allows any previous state to be retrieved and recomputed.\n    Ledger integrity is assured cryptographically by the hash tree, by block validity constraints according to the Autonity Protocol, and by deterministic consensus computation before block commit - i.e. append - to the ledger.\n    \n    \n    The Blockchain Object\n    Autonity modifies the inherited Ethereum blockchain structure, extending the block header data structure to add fields for managing block production by the committee-based Tendermint BFT Consensus mechanism.\n    \n    Block Header\n    Fields inherited from Ethereum:\n    \n    \n    baseFeePerGas, minimum price per unit of gas for your transaction to be included in the block.\n    difficulty, a scalar value corresponding to the difficulty level of this block. Can be calculated from the previous block’s difficulty level and the timestamp\n    extraData, an arbitrary byte array containing data relevant to this block. This must be 32 bytes or fewer\n    gasLimit, a scalar value equal to the current limit of gas expenditure per block\n    gasUsed, a scalar value equal to the total gas used in transactions in this block\n    hash, the Keccak 256-bit hash of the current block’s header.\n    logsBloom, the Bloom filter composed from indexable information (logger address and log topics) contained in each log entry from the receipt of each transaction in the transactions list\n    miner, the address of the block proposer\n    mixHash, a 256-bit hash which, combined with the nonce, proves that a sufficient amount of computation has been carried out on this block\n    nonce, a 64-bit value which, combined with the mixHash, proves that a sufficient amount of computation has been carried out on this block\n    number, a scalar value equal to the number of ancestor blocks. The genesis block has a number of zero.\n    parentHash, the Keccak 256-bit hash of the parent block’s header.\n    receiptsRoot, the Keccak 256-bit hash of the root node of the trie structure populated with the receipts of each transaction in the transactions list portion of the block\n    sha3Uncles, the SHA3 hash of the uncle parents of the block. This always has the value ‘0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347’\n    size, a scalar value corresponding to the current block byte size\n    stateRoot, the Keccak 256-bit hash of the root node of the state trie after transactions execution and finalization.\n    timestamp, a scalar value equal to the reasonable output of Unix’s time() at this block’s inception.\n    totalDifficulty, a scalar value corresponding to the difficulty of computing blocks in the chain to the current block\n    transactionsRoot, the Keccak 256-bit hash of the root node of the trie structure populated with each transaction in the transactions list portion of the block\n    \n    New Autonity Fields:\n    \n    committedSeals, array of signed committee member precommit votes for the block\n    committee, array of the consensus committee members for the following block. Each item in the array is recorded as an RLP-encoded pair of committee member properties (address, votingPower).\n    proposerSeal, the block proposer’s signed block proposal\n    round, a scalar value corresponding to the number of consensus rounds initiated for the block. Initial value of 0.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If you want to determine how many validators voted for a block with regard to the total committee membership, check if there is a delta between the count of seals in this block and the committee members in the preceding block.\n    \n    \n    \n    \n    \n    Block content\n    The block content structure is unmodified per standard Ethereum:\n    \n    transactions: a list of the transactions comprising the block. Recorded as an array of Keccak 256-bit hashes of the signed transaction.\n    uncles: unused.\n    \n    \n    \n    Example block\n    aut block height | aut block get | jq .\n{\n  \"baseFeePerGas\": 5000,\n  \"committedSeals\": [\n    \"0x19e8bdb5827723327a9fcfc305aa2825076ff14340ac7ddc56610fd2a49765036c9283746580661314534ca5c22ed0ec194d5e263f266d779d5a8b4493c2527801\",\n    \"0x1aca00d74bcbe6a893860dee0311a764e23e577bf5bb7266c7e7f74f066d7a18767623df78bc988e7f7030fd64a2355672f1bd721a24b6cd02cf39dab57511e001\",\n    \"0xfe6918b694abd11df39eeb0d81d1a5e338a3b414900c8ba1104ed29ca056c4123be24a7c45e23d1f4521c1a5521a19eb92d34713f5c2a70d7dec77d70ce3956c00\"\n  ],\n  \"committee\": [\n    {\n      \"address\": \"0x0be4ee22d794c640366352ef6ce666e52229886d\",\n      \"votingPower\": \"0x21e19e0c9bab2402710\"\n    },\n    {\n      \"address\": \"0x21bb01ae8eb831fff68ebe1d87b11c85a766c94c\",\n      \"votingPower\": \"0x21e19e0c9bab2402710\"\n    },\n    {\n      \"address\": \"0x4827c61c0bdf17578a0879d1aab75abebc4898fe\",\n      \"votingPower\": \"0x2710\"\n    },\n    {\n      \"address\": \"0x8cc985ded2546e9675546db6bcf34f87f4a16c56\",\n      \"votingPower\": \"0x21e19e0c9bab2402710\"\n    }\n  ],\n  \"difficulty\": 1,\n  \"extraData\": \"0x\",\n  \"gasLimit\": 30000000,\n  \"gasUsed\": 104740,\n  \"hash\": \"0xf9c37be33aa458e472c7ee017d03a4b3fe782c170eafd05334535092fd01bce0\",\n  \"logsBloom\": \"0x00200000000000000000000080000000000000000000000000000008000000000000000000000000000100000000000000000000000000000000000000200000200000000000000000000008000000200000000000000000000402000000000000000000000000000000000000000000000000020200002000000010000200000000000080000000000000080000000040000000000000080008004000000000020000000000000000000000000000200000000000000000000000010000000000000002000000000000000000100000800000000000001000000000000000000010000000000000000000000080000000000000000000000000000000000000\",\n  \"miner\": \"0x0be4Ee22d794c640366352Ef6CE666E52229886d\",\n  \"mixHash\": \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\",\n  \"nonce\": \"0x0000000000000000\",\n  \"number\": 4017598,\n  \"parentHash\": \"0x58653bcfa028c2a19194b1b9bec3a7e5a167595b0a4c7eae10531f88ab0bd097\",\n  \"proposerSeal\": \"0xf282a6230a12f3c913193ca57f99793dce8f5c14a0c5ed51163735430eb9487e394a53a4b8b4f075ff41a93d85d7af235121b2edd35e7941313b713bc7a30bc301\",\n  \"receiptsRoot\": \"0x91118225d50963cf4b0626d78bcb017ca6763ff683e2d4220bf161485f297bce\",\n  \"round\": \"0x0\",\n  \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",\n  \"size\": 1302,\n  \"stateRoot\": \"0x2351f09ed0c16f0bb7ace91f1b75223a885895573348667435304eed6e43b7f9\",\n  \"timestamp\": 1689680235,\n  \"totalDifficulty\": 4017598,\n  \"transactions\": [\n    \"0x29cd30370da131cdb79e8e0e1ca95e33be21fb3da78ba37009cbc8433a24a7da\"\n  ],\n  \"transactionsRoot\": \"0x97f1cfbdf36cfe329d50fb218093e2267356f8139ec09654a7b30515b1129278\",\n  \"uncles\": []\n}\n    \n    \n    \n    Transactions\n    Transactions are standard Ethereum transaction structures. Autonity supports both legacy (type 0) and EIP 1559 (type 2) transaction types. Use of the EIP 1559 type 2 transaction to take advantage of the economic benefits provided by the EIP 1559 fee market mechanism is recommended.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    For an explanation of how specifying gas in transactions differs between legacy and EIP 1559 transaction types, see Ethereum developer docs “Gas and Fees” - https://ethereum.org/en/developers/docs/gas/.\n    \n    \n    \n    Generated and signed by accounts on the network, transactions are submitted to the system via participant node client API’s. The client performs standard Ethereum pre-flight checks to the transaction before broadcasting it to the network.\n    Transactions are used to transfer value between individual account state, invoke calls on smart contracts, and to add new smart contracts to an Autonity network.\n    \n    Requests, transactions and calls\n    Transactions are submitted as requests over the JSON-RPC remote procedure call (RPC) protocol to read and write to system state. Requests to protocol contract functions are made as Ethereum transactions and calls executed in Autonity’s Ethereum runtime. The on-chain operation executed by smart contract logic may be a transaction that is a write operation resulting in a change to system state or a read-only call that queries system state. Execution of a contract function may result in one contract invoking another contract, resulting in a message call between contracts. For example, a bonding request submitted to the Autonity Protocol contract results in a state change to the validator’s liquid newton contract ledger when staking transitions are applied at epoch end.\n    \n    \n    Request\n    User interactions with contracts originate in the external environment and are always initiated by an external user - i.e. an EOA. They are received at the Autonity System boundary as an RPC to an Autonity Go Client. Requests adhere to the REST constraints for Web service design and are stateless and self-contained, the JSON-RPC request object containing all necessary parameters. Requests use the JSON-RPC 2.0 Specification protocol. On-chain contract interactions between smart contracts are by contract logic invoking message calls.\n    \n    \n    Transactions and calls\n    The on-chain operation resulting from a request message may be a transaction or a call:\n    \n    a write operation executed by a transaction passing in parameters. This executes and records transaction outcome in state. It is made by a Web3 ‘sendTransaction’ to a contract function that results in a change to contract state. As such, a transaction represents a valid arc between two states (See Ethereum Yellow Paper, 2. The Blockchain Paradigm). A processed transaction is recorded in a block in the distributed ledger\n    a read-only operation executed by a call passing in parameters. This simulates an outcome without recording it in state and may be by a Web3 ‘call’ to a contract function that returns a result according to parameters passed in, or by a call to a read-only contract function\n    \n    While both are signed by the EOA and execute contract functions there are important distinctions:\n    \n    Call\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Computation cost\n    Execution scope\n    State-affecting\n    Synchronicity\n    Execution guarantee\n    \n    \n    \n    \n    No gas cost\n    Executed against local node ledger object\n    No: if state-inspecting it reads local node state only; simulates execution - no state transition recorded\n    Synchronous: the result is returned immediately\n    Result returned immediately\n    \n    \n    \n    \n    \n    Transaction\n    \n    \n    \n    Computation cost\n    Execution scope\n    State-affecting\n    Synchronicity\n    Execution guarantee\n    \n    \n    \n    \n    Gas spent per transaction. Legacy type 0 transactions use the gasPrice parameter - see Transactions. EIP1559 type 2 transactions use the base fee model - see Autonity EIP 1559 configuration. See also Ethereum Yellow Paper, 4.2. The Transaction; 5. Gas and Payment)\n    Propagated and executed across all nodes in the peer-to-peer network\n    Yes: causes global state transition\n    Asynchronous: state transition applied on commit to block and dependent upon factors such as gasPrice / base fee, the time for which it remains in the pending pool, Autonity System’s block mining interval\n    State transition applied subject to transaction validity being verified by consensus computation. The transaction hash is returned. A subsequent call is required to return the transaction data or, if emitted by the state-affecting function, event data\n    \n    \n    \n    For the Ethereum Web3 modules supported by Autonity, see Reference Autonity Interfaces. For official Web3 docs, see https://readthedocs.org/projects/web3js/.\n    \n    \n    \n    Transaction\n    Transactions result in a change to a contract’s state and:\n    \n    have a type (see EIP 2718) and are legacy (type ‘0’) or EIP 1559 (type ‘2’)\n    are signed by the message sender\n    identify the recipient\n    pass in parameters for the requested function, which may include an amount if the transaction is executing a transfer of value, e.g. a ‘mint’, ‘burn’ or ‘transfer’\n    have a data structure that varies according to their type and have a legacy transaction structure or a type 2 transaction payload ( see EIP 1559\n    provide information about the fees the sender is willing to pay for each step in transaction computation and influencing the priority with which the transaction is processed by the participant nodes computing in the Autonity System’s decentralised virtual machine\n    return a transaction receipt hash asynchronously on verification of the transaction by consensus computation.\n    \n    \n    \n    Call\n    Calls are non state-affecting and simulate an outcome without recording it in state. Calls are made to pure or view contract functions that execute according to parameters passed in, but are distinct in that whereas a pure function does not read state, a view function reads local state only. I.e. of the node to which the call was submitted.\n    Calls to a contract:\n    \n    are signed by the message sender\n    pass in parameters for the requested function, which will return requested state or a simulation of execution outcome according to the passed in parameters\n    return a value synchronously.\n    \n    \n    \n    Message call\n    A contract may interact with another contract by a call, sending a message, resulting in the recipient contract executing code.\n    A message call is executed in the EVM at runtime and will:\n    \n    implicitly identify the original sender\n    identify the target contract account\n    may contain a value if the call is executing a transfer of value\n    may contain data taken as input by the receiving contract\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Although often referred to as an ‘internal transaction’, a message call is not strictly a transaction. A transaction is always signed. A message call is not because it is initiated by a contract account and not an account held by an external system user, i.e. externally owned account (EOA).\n    \n    \n    \n    \n    \n    \n    Transaction fees\n    Fees for processing transactions on an Autonity network are paid in the protocol coin auton, the native balance of an Autonity account.\n    Autonity uses Ethereum’s EIP-1559 transaction fee mechanism for pricing gas in transaction fee markets\n    \n    EIP 1559 Transaction fee mechanism (TFM)\n    EIP 1559 fee markets accommodate demand volatility by a variable block size and dynamic adjustment of the minimum price for each unit of gas used to compute a transaction on the network. The TFM functions by targeting usage of an average percentage of available block capacity over time. Mean-reverting to this target is achieved by adjusting gas price each block according to the delta between actual gas used versus targeted gas usage in the preceding block.\n    The minimum gas price is set as a base fee, which may remain static, increase, or decrease according to actual consumption. Change in the base fee is a function of the actual gas used in computing the preceding block and the expected target gas consumption of the parent block. A base fee change denominator bounds the amount the fee is allowed to change between blocks. This smooths volatility in price movements away from and back to the target usage over block time. The target is derived by dividing the parent block gas limit by an elasticity multiplier to project a desired block usage as a percentage of the block capacity. The surpus block capacity gives elasticity, a buffer zone, that can accommodate volatility in transaction demand. Surplus block capacity absorbs the increased throughput and adjustment of base fee every block responds to market demand for the blockchain’s computational and storage resources by adjusting base fee per gas unit cost accordingly:\n    \n    increasing when blocks are above the gas target\n    decreasing when blocks are below the gas target.\n    \n    To incentivise inclusion of a transaction in a block, EIP 1559 allows a transaction to include an optional priority fee or ‘tip’ as a reward incentive to the block proposer for including the transaction in a block.\n    \n    \n    Autonity EIP 1559 configuration\n    Autonity maintains the Ethereum protocol settings for EIP 1559:\n    \n    block gas target = 15M, the pre EIP 1559 block gas limit\n    block gas limit = 30M, double the preceding block gas limit accommodating 50% elasticity\n    base fee change denominator = 8, limiting possible change in base fee to 12.5% each block.\n    elasticity multiplier = 2, setting targeted block usage at 50% of the block limit.\n    \n    Autonity modifies EIP 1559 by:\n    \n    specifying a minimum base fee. Setting a minimum base fee imposes a floor to the minimum gas price cost per unit of gas used to process a transaction on the network. This floor ensures base fee cannot revert to 0 in a period of network inactivity, maintaining the inherent security properties of gas economics. The value is set at genesis. See minBaseFee parameter in the Protocol section\n    the base fee is not burned as in EIP 1559. The base fees collected for each block are added to the rewards pool for distribution as staking rewards at epoch end.\n    the priority fee rewards are given to the block proposer per EIP 1559. In current state, the priority fee is paid to the proposing validator entity’s account every block.\n    \n    \n    \n    \n    Accounts - EOA and contract\n    An account is the unique identifier for referring to an external system user, a participant node, or a smart contract deployed on the system:\n    \n    External users require an Ethereum account based on public-key cryptography to access and call functionality of the Autonity Protocol contracts and other decentralised application contracts deployed on the system.\n    Participant and validator nodes, oracle servers, and their operators have unique accounts as described in Participants, Validator identity, accounts and keypairs, and Oracle identity, accounts and keypairs\n    Smart contracts deployed on the system ledger are uniquely identified by their contract account addresses and have a state. Smart contracts native to Autonity and forming part of an Autonity system are described in concept Architecture: Autonity Protocol Contract, Autonity Oracle Contract.\n    \n    As an Ethereum-based blockchain system, Autonity account addresses are in Ethereum format - a 42 character hexadecimal string derived from the last 20 bytes of the account’s public key and prepended by 0x. Keccak-256 and the Elliptic Curve Digital Signature Algorithm (ECDSA) are used for generating (and verifying) cryptographic signatures over the secp256k1 Elliptic Curve (EC). The use of public-key cryptography based on elliptic curves allows the system to efficiently secure user’s data via asymmetric encryption and provides pseudonymity to the user’s identity via the public key. The private key gives the owner control over transfer and ownership of the Autonity system’s native protocol coins (Auton, Newton, Liquid Newton) to another account. In the wider Ethereum ecosystem this private key may be referred to as a user’s ‘Ethereum private key’. The private key is used to sign all transactions and calls submitted to an Autonity system by users from the external environment via an EOA.\n    The key elements of an Ethereum account are:\n    \n    Private-public key pair: A private-public key pair is generated by the key generation algorithm of the digital signature scheme used (i.e. ECDSA over secp256k1). The key pair allows the account holder to carry out signing operations with the private key (also referred to as “secret key”). Furthermore, the associated public key allows verification of the various digital signatures generated by account holders, and thus allows to keep the system secure.\n    Address: The address is the unique identifier for a user’s account on the ledger. It is derived from the account’s public key.\n    Ethereum keystore file: The Ethereum keystore is the file format for storing and working with encrypted private keys. For a definition of the keystore file format see the Ethereum wiki page Web3 Secret Storage Definition.\n    \n    The steps for creating an account are described in the How To Create an account.\n    There are two types of Account object maintained in the Autonity system state, Externally Owned Accounts (EOA) and Contract Accounts.\n    \n    Externally Owned Account (EOA)\n    EOA’s: represent accounts belonging to external users with a private key, are funded with gas to pay for transaction costs, and do not have smart contract code. All transactions and calls submitted from the external environment to smart contracts in an Autonity system are submitted by externally owned accounts and signed using the submitting user’s private key.\n    \n    \n    Contract Account\n    Contract Account’s: deployed smart contracts are also account objects. However, while these accounts have a balance, they are initialised with code and do not have an associated private key. As opposed to EOA’s, interactions with a contract account are governed by its EVM code. Such code is either triggered by transactions from EOA’s or message calls from other contract accounts. A contract account can call other contracts by message calls, but such message calls are not signed by a private key.\n    Contract accounts native to an Autonity system are described in Autonity Protocol Contract and Autonity Oracle Contract.\n    \n    \n    References\n    \n    Ethereum uses the Keccak-256 cryptographic hash function developed by the Keccak Team - see “The Keccak SHA-3 Submission”. This differs slightly to the NIST standardised Sha-3 hash function published as FIPS 202.\n    Elliptic Curve Digital Signature Algorithm (ECDSA) for generating (and verifying) cryptographic signatures over the secp256k1 Elliptic Curve (EC). See SEC 2: Recommended Elliptic Curve Domain Parameters.\n    For more information on transaction signing with ECDSA, see the Ethereum Yellow Paper, Appendix F. Signing Transactions.\n    For an overview of EOA vs. Contract account, see Clearmatics “Zeth Protocol Specification”, Section 1.2.1."
  },
  {
    "objectID": "concepts/consensus/committee/index.html",
    "href": "concepts/consensus/committee/index.html",
    "title": "Consensus Committee",
    "section": "",
    "text": "The consensus committee is the set of validator nodes participating in the consensus protocol for a block epoch. It is responsible for proposing new blocks, voting on block proposals to affirm the validity of proposed blocks and decide if committed to state, and notifying new blocks to peer nodes to replicate the new state.\n    A new consensus committee is selected at every block epoch in an autonomous process executed by the Autonity Protocol. The selection algorithm ranks registered validators according to the amount of their bonded stake, selecting those with the highest stake to fill the available committee member slots. Ranking by stake serves to maximise the amount of stake securing the network in an epoch.\n    For performance optimisation, due to the constraints of BFT consensus algorithms, the maximum committee size is set as a protocol parameter. It is set at genesis, but can be changed during runtime to optimise the trade-off between performance of the consensus round and democratising access to participate in consensus."
  },
  {
    "objectID": "concepts/consensus/committee/index.html#overview",
    "href": "concepts/consensus/committee/index.html#overview",
    "title": "Consensus Committee",
    "section": "",
    "text": "The consensus committee is the set of validator nodes participating in the consensus protocol for a block epoch. It is responsible for proposing new blocks, voting on block proposals to affirm the validity of proposed blocks and decide if committed to state, and notifying new blocks to peer nodes to replicate the new state.\n    A new consensus committee is selected at every block epoch in an autonomous process executed by the Autonity Protocol. The selection algorithm ranks registered validators according to the amount of their bonded stake, selecting those with the highest stake to fill the available committee member slots. Ranking by stake serves to maximise the amount of stake securing the network in an epoch.\n    For performance optimisation, due to the constraints of BFT consensus algorithms, the maximum committee size is set as a protocol parameter. It is set at genesis, but can be changed during runtime to optimise the trade-off between performance of the consensus round and democratising access to participate in consensus."
  },
  {
    "objectID": "concepts/consensus/committee/index.html#committee-member-selection",
    "href": "concepts/consensus/committee/index.html#committee-member-selection",
    "title": "Consensus Committee",
    "section": "Committee member selection",
    "text": "Committee member selection\n    The Consensus Committee for an upcoming epoch is chosen by an autonomous protocol-only function. The algorithm is run as the last block of the current epoch is finalised to choose the committee for the upcoming epoch. Committee members are selected by ranking according to the stake bonded to them.\n    The selection algorithm:\n    \n    Determines the set of eligible validators: registered validators with bonded stake &gt; 0.\n    Ranks these candidates by the amount of stake bonded.\n    Selects those with the highest amount of stake to fill the available committee member slots.\n    \n    At genesis of an Autonity Network committee selection is run against the set of validators specified in the genesis configuration to determine the genesis consensus committee. (See Genesis Reference). Post genesis, the set of validators eligible for selection becomes dynamic as new validators are registered and become active, existing validators pause and are removed from future committee selection until active again, and voting power changes are applied as stake is bonded and unbonded.\n    The committee set is recorded in every block header in the committee field."
  },
  {
    "objectID": "concepts/consensus/committee/index.html#proposer-selection",
    "href": "concepts/consensus/committee/index.html#proposer-selection",
    "title": "Consensus Committee",
    "section": "Proposer selection",
    "text": "Proposer selection\n    The proposer for each consensus instance is computed by the protocol using a stateless weighted round robin (WRR) selection algorithm. The proposer is chosen from the committee by weighted random sampling, weighting the probability of a committee member’s selection by the amount of its voting power. The selection mechanism is deterministic and will always select the same address, given the same block height, round, and committee in Autonity Contract state.\n    The selection algorithm:\n    \n    Calculates the total voting power of the current consensus committee, summing the voting power of each committee member.\n    Calculates a deterministic seed for selecting the index position of the block proposer from the list of committee members:\n    \n    The index position is calculated by the modulo of an integer value (derived from keccak256 hashing of the proposed block’s height and consensus round number) and the total voting power of the committee. I.e. index = value % total_voting_power.\n    \n    Selects the proposer by selecting the committee member at the index position from the committee list."
  },
  {
    "objectID": "concepts/consensus/committee/index.html#committee-size",
    "href": "concepts/consensus/committee/index.html#committee-size",
    "title": "Consensus Committee",
    "section": "Committee size",
    "text": "Committee size\n    The committeeSize is set as a default value in the Autonity Contract but can be changed after network genesis by governance. See Reference section Autonity Contract Interface function setCommitteeSize().\n    The consensus committee size is theoretically constrained due to the overhead of the signature verification of each committee member required by the BFT consensus protocol’s implementation.\n    In this version of Autonity the optimal size is in the range of 50-100 committee members."
  },
  {
    "objectID": "concepts/consensus/committee/index.html#voting-power-changes",
    "href": "concepts/consensus/committee/index.html#voting-power-changes",
    "title": "Consensus Committee",
    "section": "Voting power changes",
    "text": "Voting power changes\n    Transactions to bond and unbond stake to a validator are submitted at any point in an epoch but do not affect committee membership or stake reward distribution in the current epoch. Staking transitions and the resulting change in voting power are applied at epoch end before the committee selection algorithm is run to select the committee for the upcoming epoch."
  },
  {
    "objectID": "concepts/consensus/committee/index.html#committee-functions",
    "href": "concepts/consensus/committee/index.html#committee-functions",
    "title": "Consensus Committee",
    "section": "Committee functions",
    "text": "Committee functions\n    Consensus committee members are responsible for proposing and voting on new blocks in consensus rounds. For every round a new leader is selected by the protocol, responsible for proposing a new block and initiating a consensus round in which committee members propose a new block. On approval of a new block, the leader is responsible for propagating the new block to the P2P network and broadcasting it on the Autonity Communication Layer. The other consensus committee members coincidentally broadcast notification of the new block, facilitating rapid state machine replication by giving notification of the new block to sync request if not already held in local state."
  },
  {
    "objectID": "concepts/consensus/committee/index.html#audit-trail",
    "href": "concepts/consensus/committee/index.html#audit-trail",
    "title": "Consensus Committee",
    "section": "Audit trail",
    "text": "Audit trail\n    Committee membership and pending staking transitions can be audited by reading Autonity Protocol Contract state:\n    \n    making an RPC call to getCommittee() to return the current committee members\n    subscribing to NewBondingRequest and NewUnbondingRequest events to return pending bonding and unbonding requests to be applied at finalisation of the current epoch’s last block\n    \n    Historic data can be retrieved by querying system state:\n    \n    Block header committee field.\n    Block transactions for bond and unbond requests."
  },
  {
    "objectID": "concepts/consensus/index.html",
    "href": "concepts/consensus/index.html",
    "title": "Consensus",
    "section": "",
    "text": "Autonity implements the Tendermint Proof of Stake consensus protocol for computing and agreeing state transitions. Key concepts of the consensus mechanism explained in this section are:\n    \n    Byzantine fault tolerant consensus algorithm providing finality for transactions and ledger integrity\n    The role of the consensus committee on the Autonity network, dynamic committee selection, and the mechanism by which committee membership is computed."
  },
  {
    "objectID": "concepts/consensus/index.html#overview",
    "href": "concepts/consensus/index.html#overview",
    "title": "Consensus",
    "section": "",
    "text": "Autonity implements the Tendermint Proof of Stake consensus protocol for computing and agreeing state transitions. Key concepts of the consensus mechanism explained in this section are:\n    \n    Byzantine fault tolerant consensus algorithm providing finality for transactions and ledger integrity\n    The role of the consensus committee on the Autonity network, dynamic committee selection, and the mechanism by which committee membership is computed."
  },
  {
    "objectID": "concepts/consensus/pos/index.html",
    "href": "concepts/consensus/pos/index.html",
    "title": "Tendermint BFT consensus",
    "section": "",
    "text": "Autonity manages blockchain state machine replication by the deterministic Tendermint Byzantine-fault tolerant consensus algorithm. Autonity implements Tendermint BFT consensus as an independent consensus protocol running alongside the ethereum wire protocol at the P2P Networking level of the communication layer.\n    Tendermint is Proof-of-Stake (PoS) based and provides state machine replication by a repeated consensus model where each new block is proposed and agreed by a sequential consensus instance proposed and agreed by consensus committee members.\n    Tendermint provides Byzantine fault tolerance for up to 1/3 of voting power. That is, if the voting power of faulty participants is bounded by f, and the total voting power of the system equals N, then N=3f+1 is required for correct system operation, allowing up to 1/3 of nodes with fault. A fault is a failure to correctly participate in consensus. Faults can be Byzantine (i.e. malicious) behaviour failing to follow protocol or technical failure to participate in consensus.\n    \n    Dynamic committee selection\n    The consensus committee is dynamic, selected from the validators registered on the Autonity system. For each block epoch period a new committee is selected by protocol logic. Selection is weighted by the relative size of the validator’s bonded stake amount, maximising consensus stake. The sum of bonded stake in a committee is the amount of stake securing the system’s replication against Byzantine faults. A committee member’s individual voting power is a function of the amount of stake bonded to it, i.e. to its share of the consensus stake.\n    To learn more about the committee and the selection algorithm see Consensus Committee.\n    \n    \n    Consensus round and internal state\n    In each consensus instance a consensus round of three voting steps is executed as a sequential exchange of cryptographically signed (i.e. ‘sealed’) messages broadcast between committee members:\n    \n    Proposal. A block proposer is selected from the committee. The proposer validates and orders a set of transactions to create a suggested new block and broadcasts this proposal to the committee.\n    Prevote. Each committee member validates suggested block correctness and broadcasts a Prevote to approve or reject the proposal.\n    Precommit. Each committee member waits to receive a BFT quorum (2f+1 aggregate voting power) of Prevote messages to recognise the proposal as a possible decided block, and broadcasts a Precommit to approve or reject the proposal.\n    \n    If the committee member receives 2f+1 Precommits, then by protocol the block proposal is decided and:\n    \n    The block is broadcast to the network. The block proposer broadcasts the new block, its block header containing the block proposal and precommit message seals and an array of the committee members that voted for the block. Other committee members broadcast a (new) block announcement.\n    The block is committed to the ledger. Participants that receive the new block check validity by verifying the seals. Participants that receive an announcement sync to retrieve the block, verifying by computing block state as it appends the block to the chain.\n    \n    If quorum is not reached at Prevote or Precommit stages or there is timeout, then the round terminates and a new consensus instance begins."
  },
  {
    "objectID": "concepts/index.html",
    "href": "concepts/index.html",
    "title": "Concepts",
    "section": "",
    "text": "This section describes core concepts of the Autonity Protocol and blockchain architecture."
  },
  {
    "objectID": "concepts/protocol-assets/index.html",
    "href": "concepts/protocol-assets/index.html",
    "title": "Protocol assets",
    "section": "",
    "text": "Autonity has two native coins: the Auton and the Newton. Auton is the utility coin used by transaction senders for paying gas fees within the autonity protocol and newton is the coin used for staking the network. Autonity implements a liquid staking model and on staking newton to the network a validator-specific Liquid Newton token is minted to the staker."
  },
  {
    "objectID": "concepts/protocol-assets/newton/index.html",
    "href": "concepts/protocol-assets/newton/index.html",
    "title": "Newton",
    "section": "",
    "text": "Newton is the native staking instrument of Autonity. Its primary function is staking the network, and it is the stake token used in Autonity’s Proof-of-Stake consensus mechanism. Newton is divisible up to 18 decimal places (the smallest unit is 10^-18 or 0.000000000000000001). The symbol of Newton is NTN.\n    A newton stake token can be in one of three states:\n    \n    unbonded, the default state in which it is unlocked and transferrable by the stake holder.\n    bonded, the bound state in which it is locked and cannot be transferred by the stake holder.\n    unbonding, the intermediate state between bonded and unbonded in which the token is locked and non-transferrable until unbonding has completed and the token reverts to an unbonded state.\n    \n    Newton is bonded by the owner staking the token to a validator in a bonding operation. If the validator account belongs to the owner, then the newton is self-bonded, otherwise the token is delegated. The total amount of stake bonded to a validator determines its voting power. Total and self-bonded stake amounts are tracked in the validator’s state on chain (see getValidator()). The bonded token may earn staking rewards if the validator is in the consensus committee, payable in auton at the end of the block epoch.\n    Newton is unbonded by the staker in an unbonding operation. Unbonded tokens are subject to an unbonding delay, at the end of which it is redeemed and the staked Newton tokens are transferred back to the owner’s account.\n    As Newton is bonded and redeemed a corresponding equivalent amount of Liquid Newton is minted and burned to the staker’s account for delegated stake per Autonity’s liquid staking model."
  },
  {
    "objectID": "concepts/protocol-assets/auton/index.html",
    "href": "concepts/protocol-assets/auton/index.html",
    "title": "Auton",
    "section": "",
    "text": "Auton is the native coin of an account on an Autonity network. It is the protocol coin in which an account balance is denominated and is used by transaction senders for paying gas fees in the Autonity blockchain. Auton is divisible up to 18 decimal places (the smallest unit is 10^-18 or 0.000000000000000001). Its main characteristics are:\nThe unit measures of Auton and their correspondence to Ether are in the table beneath."
  },
  {
    "objectID": "concepts/protocol-assets/auton/index.html#unit-measures-of-auton",
    "href": "concepts/protocol-assets/auton/index.html#unit-measures-of-auton",
    "title": "Auton",
    "section": "Unit Measures of Auton",
    "text": "Unit Measures of Auton\n    Unit measures - Autonity and Ethereum correspondences\n    \n    \n    \n    Power\n    Number Name\n    Autonity Name\n    Ethereum Name\n    \n    \n    \n    \n    1018\n    quintillion\n    auton\n    ether\n    \n    \n    1015\n    quadrillion\n    petaton (pton)\n    milliether (finney)\n    \n    \n    1012\n    trillion\n    teraton (tton)\n    microether (szabo)\n    \n    \n    109\n    billion\n    gigaton (gton)\n    nanoether (gwei)\n    \n    \n    106\n    million\n    megaton (mton)\n    picoether (mwei)\n    \n    \n    103\n    thousand\n    kiloton (kton)\n    femtoether (kwei)\n    \n    \n    100\n    one\n    ton\n    wei"
  },
  {
    "objectID": "concepts/protocol-assets/liquid-newton/index.html",
    "href": "concepts/protocol-assets/liquid-newton/index.html",
    "title": "Liquid Newton",
    "section": "",
    "text": "Liquid Newton is the liquid staking token of Autonity. Liquid Newton is minted and burned for delegated stake as stakeholders bond and redeem Newton stake token to validators in an Autonity system. Liquid Newton is validator-specific and represents the holder’s share of the total delegated stake bonded to a validator. Liquid Newton has the staking rewards entitlement rights due to delegated stake when the staked validator is participating in the consensus committee. The Liquid Newton of a validator has its own market price and is not fungible across validators. Liquid Newton is divisible up to 18 decimal places (the smallest unit is 10^-18 or 0.000000000000000001).\n    A Liquid Newton token can be in one of two states:\n    \n    unlocked, the default state in which it is unlocked and the stake holder can transfer ownership by sending to another account.\n    locked, the bound state after unbonding in which it is locked during the unbonding period and cannot be transferred by the stake holder.\n    \n    The amount of liquid newton minted to a staker is governed autonomously by the validator’s liquid newton contract. This contract maintains a conversion rate between liquid newton and newton for bonding and unbonding operations. The rate is determined by the ratio of issued liquid tokens over the total amount of delegated stake tokens bonded to the validator. This ensures that a validator’s Liquid Newton tokens remain fungible over time:\n    \n    On bonding, the amount of liquid newton minted has value matching that of the newton being bonded.\n    On unbonding, the liquid newton unbonded is burnt and newton redeemed in proportion to the holder’s share of the liquid newton pool according to the conversion rate.\n    \n    A validator may or may not have had slashing penalties applied and as such the redemption value of Liquid Newton may vary across validators according to their history."
  },
  {
    "objectID": "concepts/architecture/index.html",
    "href": "concepts/architecture/index.html",
    "title": "Architecture",
    "section": "",
    "text": "Autonity is an EVM-based blockchain which extends the Ethereum protocol to add Autonity-specific functionality to optimise the creation and maintenance of decentralised markets. This section documents the details of these Autonity extensions. An understanding of the core Ethereum principles is assumed.\n    Autonity inherits from Ethereum:\n    \n    The blockchain structure comprising the distributed ledger of the system.\n    Peer-to-peer networking protocols forming the communication layer of the system for message broadcast between network peer nodes.\n    The EVM and smart contract technology comprising the application level of the system.\n    \n    Autonity extends Ethereum at three logical layers:\n    \n    Protocol smart contracts: the Autonity protocol is deployed in part via protocol smart contracts:\n    \n    Autonity Protocol Contract implementing protocol primitives for governance, tokenomics, liquid staking, and staking rewards distribution.\n    Liquid Newton contracts for validator-specific liquid stake tokens.\n    Accountability Contract implementing protocol primitives for accountability and fault detection, enforcing adherence to the Tendermint consensus rules by committee members, implementing slashing penalties and a Penalty-Absorbing Stake (PAS) model.\n    Autonity Oracle Contract implementing protocol primitives for computing median price data from external price data and managing the set of currency pairs for which Autonity’s oracle network provides price data.\n    \n    Autonity Protocol smart contracts are part of the client binary. Liquid Newton smart contracts are deployed on validator registration.\n    Consensus layer: blockchain consensus provided by the Proof of Stake Tendermint BFT protocol. Blocks are proposed by validators and selected by the committee for inclusion in the blockchain, with finality. The consensus mechanism enables dynamic consensus committee selection using a stake-weighting algorithm, maximising the amount of stake securing the system.\n    Communication layer: peer-to-peer networking is modified to enable the gossiping of transaction and consensus information among validators and participant nodes in separate channels. See P2P networking protocols."
  },
  {
    "objectID": "concepts/architecture/index.html#overview",
    "href": "concepts/architecture/index.html#overview",
    "title": "Architecture",
    "section": "",
    "text": "Autonity is an EVM-based blockchain which extends the Ethereum protocol to add Autonity-specific functionality to optimise the creation and maintenance of decentralised markets. This section documents the details of these Autonity extensions. An understanding of the core Ethereum principles is assumed.\n    Autonity inherits from Ethereum:\n    \n    The blockchain structure comprising the distributed ledger of the system.\n    Peer-to-peer networking protocols forming the communication layer of the system for message broadcast between network peer nodes.\n    The EVM and smart contract technology comprising the application level of the system.\n    \n    Autonity extends Ethereum at three logical layers:\n    \n    Protocol smart contracts: the Autonity protocol is deployed in part via protocol smart contracts:\n    \n    Autonity Protocol Contract implementing protocol primitives for governance, tokenomics, liquid staking, and staking rewards distribution.\n    Liquid Newton contracts for validator-specific liquid stake tokens.\n    Accountability Contract implementing protocol primitives for accountability and fault detection, enforcing adherence to the Tendermint consensus rules by committee members, implementing slashing penalties and a Penalty-Absorbing Stake (PAS) model.\n    Autonity Oracle Contract implementing protocol primitives for computing median price data from external price data and managing the set of currency pairs for which Autonity’s oracle network provides price data.\n    \n    Autonity Protocol smart contracts are part of the client binary. Liquid Newton smart contracts are deployed on validator registration.\n    Consensus layer: blockchain consensus provided by the Proof of Stake Tendermint BFT protocol. Blocks are proposed by validators and selected by the committee for inclusion in the blockchain, with finality. The consensus mechanism enables dynamic consensus committee selection using a stake-weighting algorithm, maximising the amount of stake securing the system.\n    Communication layer: peer-to-peer networking is modified to enable the gossiping of transaction and consensus information among validators and participant nodes in separate channels. See P2P networking protocols."
  },
  {
    "objectID": "concepts/architecture/index.html#protocol-contracts",
    "href": "concepts/architecture/index.html#protocol-contracts",
    "title": "Architecture",
    "section": "Protocol contracts",
    "text": "Protocol contracts\n    The Autonity Protocol Contracts are deployed by the node when it is initialised and run for the first time.\n    \n    Protocol contract addresses\n    The protocol contract account addresses are computed at contract creation according to the standard Ethereum protocol rules for contract account creation when deploying a contract: a function of the deployer address, and the count of transactions sent from that account: the account nonce.\n    These values are constant and predictable:\n    \n    the null or ‘zero’ account address 0x0000000000000000000000000000000000000000 is used as the deployer address.\n    the account nonce increments by 1 linear to the order of deployment, beginning at 0.\n    \n    Consequently, the Autonity Protocol Contract addresses for a network are deterministic and will always be the same.\n    The order of deployment and computed addresses is:\n    \n    \n    \n    \n    \n    \n    \n    \n    Account nonce\n    Contract\n    Address\n    \n    \n    \n    \n    0\n    Autonity Protocol Contract\n    0xBd770416a3345F91E4B34576cb804a576fa48EB1\n    \n    \n    1\n    Accountability Contract\n    0x5a443704dd4B594B382c22a083e2BD3090A6feF3\n    \n    \n    2\n    Oracle Contract\n    0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D\n    \n    \n    3\n    ACU Contract\n    0x8Be503bcdEd90ED42Eff31f56199399B2b0154CA\n    \n    \n    4\n    Supply Control Contract\n    0x47c5e40890bcE4a473A49D7501808b9633F29782\n    \n    \n    5\n    Stabilization Contract\n    0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f\n    \n    \n    \n    \n    \n    Autonity Protocol Contract\n    The contract implements many of the Autonity protocol extensions, including primitives for governance, staking, validators, consensus committee selection, and staking reward distribution.\n    The contract stores protocol parameters that specify the economic, consensus, and governance settings of an Autonity network. Protocol parameters are initialised at network genesis in the genesis state provided by the client’s config for connecting to public Autonity networks, or a custom genesis configuration file if running a local development network.\n    Many of the Autonity Protocol Contract functions can be called by all participants, such as those for bonding and unbonding stake, and for reading protocol parameters. Some functions are restricted to the governance operator account, such as those related to governance of network parameters.\n    All functions are documented in the Reference Autonity Interfaces: public API’s under Autonity Contract Interface, governance under Governance and Protocol Only Reference.\n    \n    Governance\n    Autonity system governance is executed:\n    \n    At genesis, when the blockchain is initialised with the genesis state.\n    After genesis by the operator governance account, by calling the restricted functions of the protocol contract.\n    \n    Governance operations are used to modify protocol parameterisation set in the genesis system state and enable an Autonity network to evolve dynamically over time. System protocol parameters modifiable by governance include:\n    \n    Governance operator account address.\n    Minimum base fee for submitting transactions to the network.\n    Consensus committee size and block epoch period.\n    Stake delegation unbonding period.\n    Protocol treasury account address for community funds and the treasury fee.\n    The set of currency pairs for which median price data is provided by the oracle network.\n    \n    For all parameter definitions and the subset of modifiable parameters see the Protocol Parameter reference.\n    \n    \n    State finalization\n    The Autonity Protocol Contract manages state finalization, maintaining system state. Contract logic triggers block finalization:\n    \n    invoking the Accountability Contract to apply slashing penalties for proven faults by the Autonity Accountability Contract\n    at epoch end:\n    \n    distributing staking rewards to Autonity protocol treasury, committee member validators, and stake delegators\n    applying staking transitions for stake bonding and unbonding\n    applying pending validator commission rate changes\n    selecting a new consensus committee for the following epoch\n    invoking the Oracle Contract to select oracle voters for the following epoch\n    \n    invoking the Oracle Contract for the computation of median price data at the end of an oracle voting round.\n    \n    To learn more about the finalization logic see the protocol only finalize() functions in the Governance and Protocol Only Reference.\n    \n    \n    Staking\n    The Autonity Protocol Contract manages liquid staking, maintaining the ledger of newton stake token in the system and triggering the deployment of validator-specific liquid newton contracts. The contract implements logic to:\n    \n    Maintain the ledger of newton stake token in the system, implementing the ERC20 token contract interface.\n    Facilitate liquid staking by triggering the deployment of validator-specific liquid newton ERC20 contracts as validators are registered on the system.\n    Provide stakeholders operations to bond and unbond stake from validators, managing newton staking transitions and liquid newton emission and redemption.\n    Provide stakeholders standard ERC20 token operations for accessing the newton stake token ledger and metadata.\n    Manage staking transitions, tracking bond and unbond requests until staking transitions are applied at the end of the epoch.\n    Trigger application of stake slashing penalties, calling the Autonity Accountability Contract which applies stake slashing at epoch end for accountable faults.\n    \n    To learn more about the concept see Staking.\n    \n    \n    Validators\n    The Autonity Protocol Contract implements logic to manage validator registration and lifecycle on the system:\n    \n    Provides public contract functions to register new validators and query for existing registered validators.\n    Trigger the deployment of validator-specific liquid newton ERC20 contracts as validators are registered on the system.\n    Provide lifecycle management functions, allowing validator operators to manage their validator and its lifecycle: pause and reactive validator, change commission rate.\n    \n    To learn more about the concept see Validators.\n    \n    \n    Committee selection\n    Computing the committee is a protocol only function. As the last block of an epoch is finalized, this function is executed to determine the committee for the following epoch.\n    The committee is selected from the registered validators maintained in the system state by the Autonity contract. Validators are ranked by bonded stake, with those having the highest stake being selected for the available committee membership slots. This stake weighting maximises the amount of stake securing the system in each new committee. Each block header records the consensus committee members who voted to approve the block.\n    To learn more about the concept see Consensus and Committee.\n    \n    \n    Reward distribution\n    Validators and stake delegators are incentivised by the distribution of staking rewards to stake bonded to the active consensus committee. Rewards are paid in Auton.\n    Rewards accumulate from transaction fees collected by the transaction fee mechanism as blocks are finalized by the committee:\n    \n    Block priority fees are distributed to block proposers at time intervals matching block generation times.\n    Block base fees are added to the rewards pool and distributed at the end of the epoch.\n    \n    The rewards pool is held in a protocol account until reward distribution occurs as the final block of an epoch is committed to state. Consensus committee members are rewarded proportionally to their share of the bonded stake (the ‘voting power’) securing the committee.\n    When distribution occurs:\n    \n    A percentage determined by the protocol treasuryFee parameter is deducted and transferred to the protocol treasury account for community funds.\n    Rewards are distributed to the treasury account of each committee member (validator) on a pro rata basis, depending on their share of the bonded stake in the consensus committee.\n    A percentage determined by the validator delegationRate parameter is deducted and transferred to the validator treasury account as a commission fee. The initial delegation rate is set globally for all validators in the network, specified by the delegationRate protocol parameter in the genesis configuration file. It can be modified by individual validators after registration.\n    Rewards are distributed to stake delegator accounts pro rata according to their share of the stake bonded to the validator.\n    Rewards accumulate until claimed by stake delegators\n    \n    To learn more about the concept see Staking rewards and distribution and Staking accounts.\n    \n    \n    \n    Autonity Accountability Contract\n    The contract implementing the accountability and fault detection (AFD) protocol extensions, including primitives for misbehaviour accusations, proving innocence against an accusation, proven faults, slashing, and jailing.\n    The contract stores static slashing protocol configuration parameters used to compute slashing penalties. Contract functions are called by validators whilst participating in the AFD protocol to:\n    \n    Return a committee member’s proven faults\n    Determine if a new accusation can be made and is slashable\n    Submit accountability events.\n    \n    Function calls to compute accountability each block and apply slashing penalties at epoch end are restricted to protocol.\n    All functions are documented in the Reference Autonity Interfaces: public API’s under Accountability Contract Interface, governance under Governance and Protocol Only Reference.\n    \n    Accountability event handling\n    The Autonity Accountability Contract implements logic for handling accountability events submitted by committee members on-chain:\n    \n    Accusations of misbehaviour for a committee member failing to follow consensus rules correctly.\n    Proofs of innocence submitted in defence against accusations. They must be presented within the constraints of a innocence window measured in blocks to be valid. An accusation successfully defended gets deleted.\n    Promotion of accusations to faults where feasible after expiry of the innocence window.\n    Direct submission of unforgeable faults. They lead to slashing without possibility of being defended by proof of innocence.\n    \n    \n    \n    Slashing penalty computation\n    The Autonity Accountability Contract manages the computation of slashing penalties for proven faults at epoch end. A slashing model is implemented where a committee member is only slashed for the highest severity fault committed in an epoch. The contract implements logic to:\n    \n    Calculate slashing amount based on static (set in the contract, see slashing protocol configuration parameters) and dynamic factors specific to the epoch circumstances. See slashing amount calculation.\n    Apply slashing according to Autonity’s Penalty-Absorbing Stake (PAS) model: validator self-bonded stake is slashed first until exhausted, then delegated stake.\n    \n    To learn more about the concept see Accountability and fault detection.\n    \n    \n    \n    Autonity Oracle Contract\n    The contract implementing the Oracle protocol extensions, including primitives for computing median price data, and managing the set of currency pairs for which Autonity provides price data.\n    The contract stores protocol parameters that specify the currency pairs for which the oracle provides median price data and the interval over which an oracle round for submitting and voting on price data runs, measured in blocks. Per the Autonity Protocol Contract, Oracle protocol parameters are initialised at network genesis.\n    Contract functions for returning price data, currency pairs provided, and the oracle network voters can be called by all participants. Function calls to govern (i.e. manage) the set of currency pairs provided by the oracle are restricted to the governance operator account.\n    All functions are documented in the Reference Autonity Interfaces: public API’s under Oracle Contract Interface, governance under Governance and Protocol-Only Reference.\n    \n    Median price computation\n    The Autonity Oracle Contract manages the computation of median price data for currency pair price reports submitted by validator-operated oracle servers. The contract implements logic to:\n    \n    Aggregate price report data submitted on-chain by validator-operated oracle servers and compute median prices for the currency pairs provided by the oracle network in voting rounds.\n    Manage the set of currency pair symbols for which the oracle network must provide price report data.\n    Provide contract operations for data consumers to determine the currency pair data provided and retrieve historical and latest computed median price data.\n    \n    To learn more about the concept see Oracle network.\n    \n    \n    Voting rounds\n    The Autonity Oracle Contract implements logic to manage submission of price data reports and calculation of median price over voting rounds by protocol only functions:\n    \n    Set oracle voters based on validators in the consensus committee and update the voter set as the consensus committee is re-selected at the end of an epoch.\n    Manage oracle voting rounds, triggering the initiation of a new voting period at the end of a round.\n    \n    \n    \n    Voter selection\n    Participation in the oracle protocol is a validator responsibility and validators in the consensus committee are automatically selected to vote on median price computation by a protocol-only function. As the last block of an epoch is finalized, this function is executed to determine the oracle voters for the following epoch.\n    Consensus committee membership is computed by the Autonity Protocol Contract; see committee selection.\n    \n    \n    \n    ASM ACU Contract\n    The contract implementing the Auton Currency Unit (ACU) element of the Auton Stabilization Mechanism. It computes the value of the ACU, an optimal currency basket of 7 free-floating fiat currencies. Value is computed for the basket currencies using median price data from the Oracle Contract. The basket quantity corresponding to each symbol is set to give ACU maximum stability.\n    The contract provides primitives for computing the ACU value and managing the basket currency symbols and quantities (i.e. weighting). The contract stores protocol parameters that specify the currency pairs for the basket, the quantities of those currencies in the basket, and the scale of precision for the ACU value. Per the Autonity Protocol Contract, ACU protocol parameters are initialised at network genesis.\n    Contract functions for returning ACU value, basket symbols, and basket quantities can be called by all participants. Function calls to govern (i.e. manage) the basket composition and value scale are restricted to the governance operator account.\n    All functions are documented in the Reference Autonity Interfaces: public API’s under ACU Contract Interface, governance under Governance and Protocol-Only Reference.\n    \n    ACU value computation\n    The Autonity ACU Contract manages the computation of the ACU value, i.e. price, for the ASM. The contract implements logic to:\n    \n    Compute the ACU value from the currency basket using the latest median price data for the symbols computed by the Oracle Contract.\n    Manage the ACU basket currency pair symbols, quantities, and ACU value scale precision.\n    Provide contract operations for data consumers to determine the ACU value, and basket symbols and quantities.\n    \n    To learn more about the concept see Auton Stabilization Mechanism (ASM).\n    \n    \n    \n    ASM Supply Control Contract\n    The contract implementing the Auton supply control element of the Auton Stability Mechanism. The contract controls the supply of Auton on an Autonity network by minting and burning invoked by the ASM Stabilization Contract.\n    The contract provides primitives for managing the available supply of Auton in an Autonity network. The contract stores the protocol parameter setting the network’s available Auton supply. Per the Autonity Protocol Contract, ACU protocol parameters are initialised at network genesis.\n    The contract function for returning the available supply of Auton for minting can be called by all participants. Function calls to mint and burn Auton are restricted to invocation by the protocol Stabilization Contract.\n    All functions are documented in the Reference Autonity Interfaces: public API’s under Supply Control Contract Interface, mint and burn under Governance and Protocol-Only Reference.\n    \n    Auton supply control\n    The Autonity Supply Control Contract manages the Auton supply. The contract implements logic to:\n    \n    Mint and burn of Auton to take Auton in and out of circulation.\n    \n    To learn more about the concept see Auton Stability Mechanism (ASM).\n    \n    \n    \n    ASM Stabilization Contract\n    The contract implementing the CDP-based stabilization mechanism for the Auton. Auton is borrowed against Collateral Token using a Collateralized Debt Position (CDP) mechanism. The Stabilization Contract manages CDP’s throughout the lifecycle, from initial borrowing through repayment and liquidation scenarios. Collateral Token is deposited into a CDP to borrow Auton. Auton is brought in and out of circulation on an Autonity network as CDP’s are opened and closed.\n    The contract provides primitives for stabilization configuration, CDP calculations, and CDP lifecycle management. The contract stores protocol parameter setting the configuration of the stabilisation mechanism’s Collateralised Debt Position (CDP). Per the Autonity Protocol Contract, ACU protocol parameters are initialised at network genesis.\n    Contract functions can be called by all participants to:\n    \n    By CDP owners to take out CDP’s to borrow Auton, withdraw collateral, and repay CDP’s.\n    By prospective CDP owners to determine borrowing limits and collateral level requirements.\n    By CDP liquidators to determine if a CDP is liquidatable or not, and to liquidate CDP’s.\n    To view CDP data and retrieve stabilization configuration settings from system state.\n    \n    Function calls to govern (i.e. manage) the stabilization configuration are restricted to the governance operator account.\n    All functions are documented in the Reference Autonity Interfaces: public API’s under Stabilization Contract Interface, governance under Governance and Protocol-Only Reference.\n    \n    CDP ownership\n    The Autonity Stabilization Contract implements logic for a CDP owner to:\n    \n    Manage the lifecycle of a CDP through stages of initial borrowing, collateral withdrawal, and debt repayment.\n    Maintain the position in a non-liquidatable state by keeping CDP debt and collateral levels within stabilisation mechanism requirements for minimum debt and collateralization values.\n    Determine borrowing limits and collateral requirements for a new or existing CDP.\n    \n    To learn more about the concept see Auton Stability Mechanism (ASM).\n    \n    \n    CDP liquidation\n    The Autonity Stabilization Contract implements logic for a liquidator to:\n    \n    Determine if a CDP is liquidatable, i.e. if the CDP is under collateralized and the collateral value is less than the liquidation ratio requirement.\n    Liquidate a CDP that is undercollateralized.\n    \n    To learn more about the concept see Auton Stability Mechanism (ASM).\n    \n    \n    \n    Protocol contract upgrade\n    Autonity protocol contracts are upgradable by governance calling the upgrade() function on the upgradeManagerContract to provide new contract bytecode and abi for a designated protocol contract address.\n    Upgrade functions by replacing contract logic for a designated contract address. The contract address and replacement contract code is passed in as parameters to the upgrade() function call. The block finalize() function checks if a contract upgrade is available. The protocol will then update the contract code of the autonity contract during the block finalization phase. Contract code is replaced in the EVM and existing contract state is maintained."
  },
  {
    "objectID": "concepts/architecture/index.html#consensus-layer",
    "href": "concepts/architecture/index.html#consensus-layer",
    "title": "Architecture",
    "section": "Consensus layer",
    "text": "Consensus layer\n    The append of new blocks to the ledger with immediate finality is managed by the Proof-of-Stake based Tendermint BFT consensus mechanism. It enables dynamic committee selection and maximises stake securing the system by a stake-weighted algorithm for committee selection.\n    Individual blocks are proposed and agreed upon in a Tendermint consensus instance, where the process is dynamically repeated as new blocks are finalized. Consensus instances are computed by the consensus committee, a subset of validators whose bonded stake secures the network against Byzantine or malicious behaviour by committee members.\n    Committee selection is dynamic and stake-based, with a new committee elected for each epoch. The physical length of an epoch is set as a number of blocks appended to the ledger, and so the temporal duration of an epoch is dependent upon the minimum block period or ‘time interval’ at which blocks are generated by the protocol and appended to the ledger. This interval provides consistent block production to the chain and adherence to the interval is a block validity constraint. Both epoch length and block period are protocol parameters. The number of consensus instances executed in an epoch may be equal to or greater than the number of blocks in the epoch: a consensus round may timeout and fail to complete.\n    The consensus protocol makes use of:\n    \n    The communication layer for consensus round messaging and consensus state synchronisation in a dedicated consensus channel.\n    The Autonity Protocol Contract for committee selection logic.\n    \n    To learn more about the concept, see Consensus, System model, Networking and the protocol parameters reference."
  },
  {
    "objectID": "concepts/architecture/index.html#communication-layer",
    "href": "concepts/architecture/index.html#communication-layer",
    "title": "Architecture",
    "section": "Communication Layer",
    "text": "Communication Layer\n    Autonity uses a fully connected network topology with peer-to-peer communication based on Ethereum devp2p network protocols RLPx and wire protocol.\n    At the P2P level, Autonity separates transaction and consensus traffic on to separate channels on different TCP ports.\n    For transaction gossiping between nodes the Ethereum wire protocol is used for P2P propagation of block announcements and transactions. Each participant maintains a current record of peers in the network, updated as new participants join or leave the system. Participants establish an authenticated connection with one another over TCP by the RLPx transport protocol. For detail, see the Concept description System model, Networking.\n    For consensus gossiping a separate consensus protocol runs alongside the ethwire protocol for the execution of Autonity’s BFT Tendermint Consensus algorithm. This channel is used by committee members to broadcast consensus messages during Tendermint consensus rounds (propose, prevote and precommit). Validator messages sent during consensus rounds are cryptographically signed (sealed). A subset of these signatures are saved in the block header as cryptographic proof of the validator quorum that agreed on the block: the proposer seal, seal of the committee member proposing the block, and the committed seals, set of seals from the committee members that voted and agreed on the block.\n    To learn more about the separation of transaction and consensus gossiping traffic, see System model, Networking.\n    For how bootnode provision works, see the How to Run Autonity."
  },
  {
    "objectID": "concepts/oracle-network/index.html",
    "href": "concepts/oracle-network/index.html",
    "title": "Oracle network",
    "section": "",
    "text": "This section describes the oracle protocol, the role of validators in providing and agreeing median price data, and the lifecycle for oracle voting and currency pair management.\n    Autonity provides consensus-computed median price data for selected currency pairs as an L1 platform feature. The submission of price data for aggregation and voting is a validator responsibility and executed according to an oracle protocol. As consequence, validator nodes form an oracle network. When serving as a member of the consensus committee, validators must submit raw price data reports for currency pairs on-chain, and participate in the oracle protocol to agree an aggregated median price for the submitted price data in discrete voting rounds using a commit and reveal protocol. As voting rounds complete, the aggregated median price data computed and provided by the Autonity network is updated. As an epoch ends the set of oracle voters changes to accord with new consensus committee membership.\n    In the oracle protocol a validator has responsibilities to:\n    \n    Source raw price data for selected currency pairs from one-or-more external data sources off-chain.\n    Provide price data reports as input for the computation of aggregated median price data for currency pairs during oracle voting rounds.\n    Vote for aggregated median price data for currency pairs during oracle voting rounds.\n    Maintain the set of symbols for which raw price data is provided by the validator oracle, revising as required if the connected Autonity network updates its selected set of currency pairs.\n    \n    \n    \n    To operate as a validator node the operator must operate Autonity oracle server software as an adjunct to its Autonity full node software.\n    Prerequisites for participating in the oracle network as a validator node operator are:\n    \n    An Autonity Go Client full node installation, joined to an Autonity network.\n    An Autonity Oracle Server installation, configured to connect to your full node and external price data sources via plugin adaptors.\n    Plugin adaptors for connecting to external data provider sources to retrieve price data for the currency pairs required for your node’s connected Autonity network."
  },
  {
    "objectID": "concepts/oracle-network/index.html#overview",
    "href": "concepts/oracle-network/index.html#overview",
    "title": "Oracle network",
    "section": "",
    "text": "This section describes the oracle protocol, the role of validators in providing and agreeing median price data, and the lifecycle for oracle voting and currency pair management.\n    Autonity provides consensus-computed median price data for selected currency pairs as an L1 platform feature. The submission of price data for aggregation and voting is a validator responsibility and executed according to an oracle protocol. As consequence, validator nodes form an oracle network. When serving as a member of the consensus committee, validators must submit raw price data reports for currency pairs on-chain, and participate in the oracle protocol to agree an aggregated median price for the submitted price data in discrete voting rounds using a commit and reveal protocol. As voting rounds complete, the aggregated median price data computed and provided by the Autonity network is updated. As an epoch ends the set of oracle voters changes to accord with new consensus committee membership.\n    In the oracle protocol a validator has responsibilities to:\n    \n    Source raw price data for selected currency pairs from one-or-more external data sources off-chain.\n    Provide price data reports as input for the computation of aggregated median price data for currency pairs during oracle voting rounds.\n    Vote for aggregated median price data for currency pairs during oracle voting rounds.\n    Maintain the set of symbols for which raw price data is provided by the validator oracle, revising as required if the connected Autonity network updates its selected set of currency pairs.\n    \n    \n    \n    To operate as a validator node the operator must operate Autonity oracle server software as an adjunct to its Autonity full node software.\n    Prerequisites for participating in the oracle network as a validator node operator are:\n    \n    An Autonity Go Client full node installation, joined to an Autonity network.\n    An Autonity Oracle Server installation, configured to connect to your full node and external price data sources via plugin adaptors.\n    Plugin adaptors for connecting to external data provider sources to retrieve price data for the currency pairs required for your node’s connected Autonity network."
  },
  {
    "objectID": "concepts/oracle-network/index.html#oracle-identity-accounts-and-keypairs",
    "href": "concepts/oracle-network/index.html#oracle-identity-accounts-and-keypairs",
    "title": "Oracle network",
    "section": "Oracle identity, accounts and keypairs",
    "text": "Oracle identity, accounts and keypairs\n    The oracle server makes use of a single account and private/public key pair for oracle identity, oracle protocol participation, and cryptographic security.\n    \n    Oracle server key\n    The private/public key pair of the oracle server node.\n    The private key is used:\n    \n    By an oracle server for submitting price report transactions to the Oracle Contract on-chain.\n    To generate the proof of enode ownership required for validator registration. The proof is generated with the oracle server private key and the validator’s p2p node key using the genOwnershipProof command-line option of the Autonity Go Client.\n    \n    The public key is used:\n    \n    To derive an ethereum format account that is then used to identify the oracle server. See oracle identifier.\n    As the msg.Sender address used by the oracle server to submit transactions for oracle price report submissions by function call to the Oracle Contract on-chain.\n    \n    \n    \n    Oracle identifier\n    A unique identifier for the Autonity Oracle Server used as the oracle identity in validator registration, where it is provided as an oracleAddress parameter.\n    The identity is created as an ethereum format account address, generated by the entity operating the oracle server as part of the deployment process. It provides an unambiguous relationship between oracle server identity and the associated validator node for which the oracle server is a data provider.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The oracle identifier is stored in the oracleAddress field in the Validator data struct maintained in state.\n    Note that this identifier is the oracle server’s on-chain identity and is distinct from the nodeAddress which is the validator node identifier, and the treasury account which is the validator operator’s account. The identifier may be referred to as the oracle account."
  },
  {
    "objectID": "concepts/oracle-network/index.html#oracle-network",
    "href": "concepts/oracle-network/index.html#oracle-network",
    "title": "Oracle network",
    "section": "Oracle network",
    "text": "Oracle network\n    Validator nodes must participate in the oracle protocol when serving as a member of the consensus committee.\n    This results in a logical ‘oracle network’ of validator-operated oracles responsible for sourcing price data, submitting price reports on-chain, and participating in voting rounds to agree on aggregated median prices for the currency pairs provided by an Autonity network."
  },
  {
    "objectID": "concepts/oracle-network/index.html#oracle-protocol",
    "href": "concepts/oracle-network/index.html#oracle-protocol",
    "title": "Oracle network",
    "section": "Oracle protocol",
    "text": "Oracle protocol\n    The computation of median price data is governed by protocol logic and rules. The protocol has off- and on-chain operations. Price data is collected from external data providers by oracle servers run by validator operators and submitted on-chain to an oracle contract that computes aggregate median price data in voting rounds. Validators are responsible for providing source data from off-chain and voting to agree a median price on-chain when members of the consensus committee.\n    The protocol computes median price by aggregation:\n    \n    Off-chain aggregation. Oracle Server’s collect source price data for currency pairs from one or more sources. If data is taken from multiple sources, then aggregation is performed to consolidate price data into a standardised report format. This price report (or price data ‘sample’) is then pushed to the Oracle contract via a transaction submitted from the oracle server account.\n    On-chain aggregation. The Oracle contract aggregates the supplied price data reports to compute a reference exchange rate data through a voting mechanism using a commit-reveal protocol in voting rounds.\n    \n    The commit and reveal scheme is applied for security in price voting and results in a round lag between oracle price updates.\n    \n    Voting rounds\n    To coordinate the submission of source price data reports and computation of median price in the oracle network, oracle voting on median price computation takes place in voting rounds run over a fixed duration of blocks, the voting period (the duration in blocks of which is set as the protocol parameter votePeriod).\n    In the last block of each vote period the Oracle contract issues a NewRound event. The round event provides a tuple of round ID, block number, block timestamp, and vote period, which tells the oracle server that on the round with that ID a price report for that timestamp is required for submission by the oracle server. The block number indicates the block height at which the new round begins, while the vote period is the length measured in blocks of the new round.\n    The oracle server uses the metadata to estimate and manage data sampling for submission to the new round. The oracle server initiates a data sampling window 5 seconds before the required timestamp. It pre samples data from its configured data sources throughout the window range, then submits a price data report - i.e. ‘vote’ - as close as possible to the required timestamp.\n    \n    \n    Voter selection\n    Oracle voters are selected from the current consensus committee and are kept in sync with consensus committee changes by protocol as the committee changes with new epochs.\n    Voters are allowed to vote once each round. If a validator leaves the consensus committee then their vote is discarded; if a validator joins the consensus committee then their first vote is not taken into account.\n    \n    \n    Commit and reveal\n    A commit and reveal protocol is used for price voting. In each round the oracle voter submits a vote transaction providing:\n    \n    _commit: a cryptographic hash of the new price report submitted for the round\n    _reports: a reveal of the price report submitted for the previous round\n    _salt: a salt value used to generate the previous round’s commitment\n    \n    Protocol then uses the salt to verify the previous round’s commit matches the reveal for that commit provided by the voter in the current round. This introduces a time lag in oracle price updates: prices are submitted in round 1, revealed during round 2, with median price data computed at the end of round 2.\n    To exemplify oracle frequency of new median price data publication from genesis in a scenario of vote period set to 30 blocks:\n    \n    \n    \n    \n    \n    \n    \n    Time (Block Height)\n    Event\n    \n    \n    \n    \n    Genesis\n    Network genesis; initiation of first oracle voting round: R1\n    \n    \n    Block 1...29\n    Oracle voters submit price report vote, providing commit; reveal and salt null.\n    \n    \n    Block 30\n    R1 voting round ends. No previous round so no commits to reveal and no valid price submissions for median price computation for R1. New Round event emitted for R2.\n    \n    \n    Block 31\n    New Round begins: R2\n    \n    \n    Block 31...60\n    Oracle voters submit price report vote, providing commit for R2; reveal and salt for R1.\n    \n    \n    Block 60\n    R2 voting round ends. Commit and reveal; median price round data computed for R2. New Round event emitted for R3…\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If an oracle fails to vote in a round, or the reveal does not match the past commit, then the oracle voter is recorded as submitting an invalid price for the round.\n    \n    \n    \n    \n    \n    Currency pair management\n    The currency pair symbols for which the oracle network provides price data is set at network genesis in the genesis configuration file in the symbols field; see config.oracle object.\n    The currency pair symbols set for a network can be returned by a contract call using the getSymbols() function.\n    The pairs can be updated post-genesis by a governance-only function, `setSymbols().\n    Note that if currency pair symbols are changed there is a 2-round delay in applying the change after the symbol update round. This is because of the commit and reveal process for submitting and revealing price reports: oracles send commits for the new symbols in “symbol updated round + 1” and reveals for the new symbols in “symbol updated round + 2”.\n    To exemplify:\n    \n    \n    \n    \n    \n    \n    \n    Time (Block Height)\n    Event\n    \n    \n    \n    \n    Genesis\n    Symbols set in network genesis configuration\n    \n    \n    Round n - symbol updated round\n    Governance operation to update symbols. setSymbols function called and a NewSymbols event is emitted logging the new currency pair symbols and the round number at which oracles must begin providing price report submissions for the new symbol set - i.e. current round +1. Oracles provide commits and reveals for the old pre-update symbol set.\n    \n    \n    Round n+1\n    Oracles submit commits for the new symbol set and reveals for the old symbol set\n    \n    \n    Round n+2\n    Oracles submit commits and reveals for the new symbol set"
  },
  {
    "objectID": "concepts/oracle-network/index.html#oracle-data-consumers",
    "href": "concepts/oracle-network/index.html#oracle-data-consumers",
    "title": "Oracle network",
    "section": "Oracle data consumers",
    "text": "Oracle data consumers\n    Primary consumers of oracle data are:\n    \n    Auton Stabilization Mechanism\n    Smart contracts deployed on the Autonity L1 network can access median price data via the oracle contract interface."
  },
  {
    "objectID": "concepts/oracle-network/index.html#oracle-economics",
    "href": "concepts/oracle-network/index.html#oracle-economics",
    "title": "Oracle network",
    "section": "Oracle economics",
    "text": "Oracle economics\n    Participation in the oracle network is a validator responsibility and receives no specific reward beyond transaction fees for submitting oracle price vote transactions to the oracle contract. For validator revenue, see Validator economics in the validator concept page.\n    \n    Transaction fee refund\n    Oracle transactions are refunded if successfully committed.\n    The oracle account must be funded with a seed balance to cover at least one voting transaction.\n    The validator is registered and eligible for selection to the consensus committee.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Limiting the oracle vote transaction to 1 each Round prevents the refund funding a spam attack vector in a Byzantine behaviour scenario. Once 1 vote transaction from an oracle account has been successfully processed, any further vote transactions from that oracle account during the round are reverted."
  },
  {
    "objectID": "glossary/index.html",
    "href": "glossary/index.html",
    "title": "Glossary",
    "section": "",
    "text": "The binary-level interface between a smart contract and the Ethereum Virtual Machine (EVM). The ABI defines the contract interface and is used to call contract functions and for contract-to-contract interactions. The ABI is represented as JSON and compiled to bytecode for execution in the EVM. See the Contract ABI Specification in Solidity programming language docs for design and specification."
  },
  {
    "objectID": "glossary/index.html#application-binary-interface-abi",
    "href": "glossary/index.html#application-binary-interface-abi",
    "title": "Glossary",
    "section": "",
    "text": "The binary-level interface between a smart contract and the Ethereum Virtual Machine (EVM). The ABI defines the contract interface and is used to call contract functions and for contract-to-contract interactions. The ABI is represented as JSON and compiled to bytecode for execution in the EVM. See the Contract ABI Specification in Solidity programming language docs for design and specification."
  },
  {
    "objectID": "glossary/index.html#account",
    "href": "glossary/index.html#account",
    "title": "Glossary",
    "section": "account",
    "text": "account\n    An account is an object in the blockchain system state identified by a unique address. It has an intrinsic balance denominated in the native coin auton, transaction state, and if a contract account has EVM code and contract state storage.\n    There are 2 types of account:\n    \n    Externally owned accounts (EOA’s). These are owned and controlled by a private key held by an external user, have no associated EVM code, and submit transactions and calls to the blockchain\n    Contract accounts. These are controlled by their associated EVM code, execute that associated EVM code contract logic when a transaction is sent to the account, and may send message calls to other contract accounts as part of their EVM code execution."
  },
  {
    "objectID": "glossary/index.html#account-state",
    "href": "glossary/index.html#account-state",
    "title": "Glossary",
    "section": "account state",
    "text": "account state\n    A part of system state that is specific to an account address. Account state comprises: the account’s native coin balance (auton), the count of transactions sent from the account (nonce), and, if a contract account, a hash (storageRoot) of the associated account storage and hash (codeHash) of the associated EVM code."
  },
  {
    "objectID": "glossary/index.html#address",
    "href": "glossary/index.html#address",
    "title": "Glossary",
    "section": "address",
    "text": "address\n    A 64 character hex string providing the unique identifier of an account."
  },
  {
    "objectID": "glossary/index.html#auton",
    "href": "glossary/index.html#auton",
    "title": "Glossary",
    "section": "Auton",
    "text": "Auton\n    A native coin of an Autonity Network. Auton is the native coin in which an account balance is denominated and is the coin used for paying gas fees within the Autonity Protocol. See also Protocol assets, Auton."
  },
  {
    "objectID": "glossary/index.html#acu",
    "href": "glossary/index.html#acu",
    "title": "Glossary",
    "section": "Auton Currency Unit (ACU)",
    "text": "Auton Currency Unit (ACU)\n    A base-invariant, volatility-minimised index based on a currency basket of 7 free-floating fiat currencies.\n    The ACU is the Stabilization Target for Auton price stability used by the Auton Stabilization Mechanism (ASM)."
  },
  {
    "objectID": "glossary/index.html#asm",
    "href": "glossary/index.html#asm",
    "title": "Glossary",
    "section": "Auton Stabilization Mechanism (ASM)",
    "text": "Auton Stabilization Mechanism (ASM)\n    The protocol mechanism used to maintain Auton price stability. The Stabilization Mechanism is CDP, Auton borrowed against Newton collateral."
  },
  {
    "objectID": "glossary/index.html#cdp",
    "href": "glossary/index.html#cdp",
    "title": "Glossary",
    "section": "Collateralised Debt Position (CDP)",
    "text": "Collateralised Debt Position (CDP)\n    A smart contract based lending mechanism where collateral is deposited and locked in a smart contract to borrow another token-based asset. CDPs operate subject to collateral requirements and may be liquidated if the lender fails to maintain, i.e. breaches, the collateral conditions of the CDP.\n    CDPs are used by the Auton Stabilization Mechanism (ASM) to borrow Auton against Newton or Liquid Newton collateral."
  },
  {
    "objectID": "glossary/index.html#autonity-go-client-agc",
    "href": "glossary/index.html#autonity-go-client-agc",
    "title": "Glossary",
    "section": "Autonity Go Client (AGC)",
    "text": "Autonity Go Client (AGC)\n    Autonity Go Client is main client software for accessing and participating in an Autonity network. AGC implements the Autonity Protocol. All nodes of an Autonity network run AGC software. When connected to an Autonity network an AGC is a participant in that network.\n    For AGC features see Concept Client."
  },
  {
    "objectID": "glossary/index.html#autonity-network",
    "href": "glossary/index.html#autonity-network",
    "title": "Glossary",
    "section": "Autonity network",
    "text": "Autonity network\n    An instance of an Autonity blockchain peer-to-peer network, all peer nodes running Autonity Go Client main client software. Public Autonity networks are instantiated for specific purposes - e.g. testnet, mainnet.\n    Autonity network peers are connected in a full mesh network. Peers discover and connect to one another via Autonity’s communication layer protocols which are based on the Ethereum devp2p networking protocol."
  },
  {
    "objectID": "glossary/index.html#autonity-oracle-server-aos",
    "href": "glossary/index.html#autonity-oracle-server-aos",
    "title": "Glossary",
    "section": "Autonity Oracle Server (AOS)",
    "text": "Autonity Oracle Server (AOS)\n    Autonity Oracle Server (AOS) is software for participating in the Autonity oracle network. AOS retrieves exchange rate data for currency pairs from data providers, consolidates these data points into a standardised report, and submits to the Autonity Protocol’s oracle contract on-chain via the AOS operator’s validator node. Submitted data reports are then aggregated by the oracle contract which uses a voting mechanism to provide exchange rate reference data agreed by consensus.\n    Providing oracle reference data is a validator responsibility. Validator node operators must operate an AOS connected to their validator node.\n    For AOS features see Concept Oracle Server.\n    For AOS features see Concept Oracle Server."
  },
  {
    "objectID": "glossary/index.html#autonity-protocol",
    "href": "glossary/index.html#autonity-protocol",
    "title": "Glossary",
    "section": "Autonity Protocol",
    "text": "Autonity Protocol\n    A generalization of the Ethereum Protocol modified to incorporate proof-of-stake based Tendermint consensus, native tokenomics, deterministic finality, an oracle protocol, and liquid staking.\n    The Autonity Protocol uses Ethereum’s EVM-based state transition function. State transition is by transaction, the transaction associated with an economic cost for computation, and transactions affecting system state)."
  },
  {
    "objectID": "glossary/index.html#block",
    "href": "glossary/index.html#block",
    "title": "Glossary",
    "section": "block",
    "text": "block\n    A set of transaction’s validated by consensus and appended to the blockchain."
  },
  {
    "objectID": "glossary/index.html#blockchain",
    "href": "glossary/index.html#blockchain",
    "title": "Glossary",
    "section": "blockchain",
    "text": "blockchain\n    A decentralised system in which system state is maintained as a sequence of blocks in an append-only data structure maintained as a distributed ledger by consensus between peer nodes."
  },
  {
    "objectID": "glossary/index.html#block-height",
    "href": "glossary/index.html#block-height",
    "title": "Glossary",
    "section": "block height",
    "text": "block height\n    The distance of a block from the root block of the system’s blockchain, the genesis block. Block height is measured as the count of blocks from genesis block to current block."
  },
  {
    "objectID": "glossary/index.html#block-period",
    "href": "glossary/index.html#block-period",
    "title": "Glossary",
    "section": "block period",
    "text": "block period\n    The minimum period of time between blocks, measured in seconds. The block period delay ensures consistent block production over time."
  },
  {
    "objectID": "glossary/index.html#bond",
    "href": "glossary/index.html#bond",
    "title": "Glossary",
    "section": "bond",
    "text": "bond\n    The operation of bonding stake to a validator.\n    Stake can be delegated or self-bonded, the distinction being self-bonded stake is owned by the identity operating the validator and delegated stake is not."
  },
  {
    "objectID": "glossary/index.html#bytecode",
    "href": "glossary/index.html#bytecode",
    "title": "Glossary",
    "section": "bytecode",
    "text": "bytecode\n    Executable code passed to the EVM for execution. Bytecode - also known as EVM code - is compiled from the high-level programming language (Solidity) used to write smart contracts for execution in the Ethereum Virtual Machine (EVM)."
  },
  {
    "objectID": "glossary/index.html#byzantine-failure",
    "href": "glossary/index.html#byzantine-failure",
    "title": "Glossary",
    "section": "Byzantine failure",
    "text": "Byzantine failure\n    A failure of consensus due to participant behaviour that does not accord with the protocol."
  },
  {
    "objectID": "glossary/index.html#byzantine-fault-tolerance-bft",
    "href": "glossary/index.html#byzantine-fault-tolerance-bft",
    "title": "Glossary",
    "section": "Byzantine fault tolerance (BFT)",
    "text": "Byzantine fault tolerance (BFT)\n    The ability of a distributed system to operate and agree consensus according to protocol under Byzantine failure conditions.\n    Autonity implements Tendermint BFT consensus, an asynchronous consensus protocol that can require up to 1/3 of committee members being at fault. Tendermint requires 3f+1 of participant validators behave correctly and is tolerant of f faults."
  },
  {
    "objectID": "glossary/index.html#calldata",
    "href": "glossary/index.html#calldata",
    "title": "Glossary",
    "section": "calldata",
    "text": "calldata\n    Data committed to state by arguments to a smart contract deployed on the blockchain. ‘calldata’ is accessed by the Solidity .call() function. Calldata is non-executable - it is state not smart contract bytecode."
  },
  {
    "objectID": "glossary/index.html#consensus",
    "href": "glossary/index.html#consensus",
    "title": "Glossary",
    "section": "consensus",
    "text": "consensus\n    The computational process by which system state is agreed and replicated by validator nodes in a distributed system. Autonity implements a Proof of Stake (PoS) based consensus algorithm."
  },
  {
    "objectID": "glossary/index.html#consensus-algorithm",
    "href": "glossary/index.html#consensus-algorithm",
    "title": "Glossary",
    "section": "consensus algorithm",
    "text": "consensus algorithm\n    An algorithm used by distributed systems to ensure that peer nodes have consistent state with resilience to computer network or Byzantine behaviour. See Byzantine-fault tolerance."
  },
  {
    "objectID": "glossary/index.html#consensus-committee",
    "href": "glossary/index.html#consensus-committee",
    "title": "Glossary",
    "section": "consensus committee",
    "text": "consensus committee\n    The set of validator nodes participating in the consensus protocol for a block epoch period. The committee is responsible for proposing new blocks, voting on block proposals to affirm the validity of proposed blocks and decide if committed to state, and notifying new blocks to peer nodes to replicate the new state.\n    A new consensus committee is selected at every block epoch in an autonomous process executed by Autonity’s Proof of Stake (PoS) consensus protocol. The selection algorithm ranks registered validators according to the amount of their bonded stake, selecting those with the highest stake to fill the available committee member slots. Ranking by stake serves to maximise the amount of stake securing the network in an epoch."
  },
  {
    "objectID": "glossary/index.html#cryptocurrency",
    "href": "glossary/index.html#cryptocurrency",
    "title": "Glossary",
    "section": "cryptocurrency",
    "text": "cryptocurrency\n    A digital currency that provides a medium of exchange in a decentralised computer network. The record of transactions in the crypto(graphic) currency is verified and recorded in the network’s distributed ledger using cryptography."
  },
  {
    "objectID": "glossary/index.html#currency-pair",
    "href": "glossary/index.html#currency-pair",
    "title": "Glossary",
    "section": "currency pair",
    "text": "currency pair\n    Two currencies valued against one another with a quotation and pricing structure based on quoting one currency against the other. A currency pair consists of a base currency (listed first) and a quote currency (listed second). The currency pair expresses the amount of quote currency required to buy one unit of the base currency.\n    For example, in the currency pair JPY-USD 0.0074, 1 Japanese Yen will trade for 0.0074 US dollars."
  },
  {
    "objectID": "glossary/index.html#data-oracle",
    "href": "glossary/index.html#data-oracle",
    "title": "Glossary",
    "section": "data oracle",
    "text": "data oracle\n    An off-chain data feed service that provides data to a blockchain. An oracle data service is considered a secure and reliable source of information on the blockchain and may be used in on-chain logic execution. For example, a price data feed. See also Autonity Oracle Server (AOS)"
  },
  {
    "objectID": "glossary/index.html#decentralised-application-dapp",
    "href": "glossary/index.html#decentralised-application-dapp",
    "title": "Glossary",
    "section": "decentralised application (dApp)",
    "text": "decentralised application (dApp)\n    A software application deployed on to a blockchain p2p network. A dApp interacts with one or more smart contracts and is typically a combination of those contract(s) and a frontend for using that contract. The frontend graphical user interface (GUI) is typically built out using JavaScript, HTML, CSS technologies. User interactions with a dApp are by transactions and calls submitted to a network peer’s JSON RPC API using the web3.js library. Interactions may be mediated by a user via a GUI or application-level interactions."
  },
  {
    "objectID": "glossary/index.html#delegated",
    "href": "glossary/index.html#delegated",
    "title": "Glossary",
    "section": "delegated",
    "text": "delegated\n    Stake token bonded to a validator by a stakeholder. Delegated stake earns staking rewards and the staker is minted Liquid Newton for the Newton stake token bonded. The account submitting the stake delegation transaction (cf. bond) can be any network account except the validator treasury account.\n    Stake delegation transactions submitted from the validator treasury account result in self-bonded stake."
  },
  {
    "objectID": "glossary/index.html#delegation",
    "href": "glossary/index.html#delegation",
    "title": "Glossary",
    "section": "delegation",
    "text": "delegation\n    The process of bonding stake token to a validator by a stakeholder.\n    See related concepts: staking, delegated stake, self-bonded stake, and delegation rate."
  },
  {
    "objectID": "glossary/index.html#delegation-rate",
    "href": "glossary/index.html#delegation-rate",
    "title": "Glossary",
    "section": "delegation rate",
    "text": "delegation rate\n    The percentage commission of earned staking rewards that a validator charges as a commission on delegated stake."
  },
  {
    "objectID": "glossary/index.html#enode",
    "href": "glossary/index.html#enode",
    "title": "Glossary",
    "section": "enode",
    "text": "enode\n    The unique identifier of a node in the form of a URI. It provides the network address of a node on an Autonity network, giving the network location of the node client for p2p networking.\n    The enode URL is formed according the Ethereum enode url format which is described in the Ethereum Developers Docs, Networking layer."
  },
  {
    "objectID": "glossary/index.html#epoch",
    "href": "glossary/index.html#epoch",
    "title": "Glossary",
    "section": "epoch",
    "text": "epoch\n    A fixed number (i.e. epochPeriod) of consecutive blocks where the validator committee - as recorded in the state of the autonity contract - cannot change."
  },
  {
    "objectID": "glossary/index.html#epoch-period",
    "href": "glossary/index.html#epoch-period",
    "title": "Glossary",
    "section": "epoch period",
    "text": "epoch period\n    The period of time for which a consensus committee is elected, defined as a number of blocks. The epoch period can be any integer number &gt; 0, but must be shorter than the unbonding period. Without this constraint unbonding could take place before slashing penalties and staking transitions are applied."
  },
  {
    "objectID": "glossary/index.html#ethereum-virtual-machine-evm",
    "href": "glossary/index.html#ethereum-virtual-machine-evm",
    "title": "Glossary",
    "section": "Ethereum Virtual Machine (EVM)",
    "text": "Ethereum Virtual Machine (EVM)\n    The distributed state machine responsible for computing system state. The EVM provides the runtime environment for smart contract execution, computing valid state transitions as transactions are computed and smart contract bytecode executed.\n    Contract logic is executed by the EVM instruction set (opcodes) which define the allowed computation operations. The set of opcodes allows the EVM to be Turing complete. Strictly it is quasi Turing complete because the gas model constrains execution - transactions will revert before full execution if they run out of gas. The EVM provides an abstraction layer between the execution of application (smart contract) bytecode and the OS of the machine hosting the Autonity client software."
  },
  {
    "objectID": "glossary/index.html#finality",
    "href": "glossary/index.html#finality",
    "title": "Glossary",
    "section": "finality",
    "text": "finality\n    Finality is the quality of being in an end state that cannot be altered. In blockchain, finality refers to the point at which state transitions are immutable. Autonity’s Tendermint consensus is deterministic: finality for a block and the transactions within it is achieved at the point a block is appended (i.e. committed) to the blockchain. Each block creates a checkpoint in the chain and provides a guarantee that blocks before that checkpoint cannot be altered."
  },
  {
    "objectID": "glossary/index.html#genesis-block",
    "href": "glossary/index.html#genesis-block",
    "title": "Glossary",
    "section": "genesis block",
    "text": "genesis block\n    The first block of a blockchain containing the genesis state of the system and the root of the blockchain.\n    The genesis state is provided in the genesis state file. As root block, the genesis block has the block number index 0."
  },
  {
    "objectID": "glossary/index.html#genesis-state-file",
    "href": "glossary/index.html#genesis-state-file",
    "title": "Glossary",
    "section": "genesis state file",
    "text": "genesis state file\n    The JSON-formatted genesis configuration file that contains the data necessary to generate the genesis block of an Autonity network. Typically called genesis.json but can be given any custom name."
  },
  {
    "objectID": "glossary/index.html#gigaton",
    "href": "glossary/index.html#gigaton",
    "title": "Glossary",
    "section": "gigaton",
    "text": "gigaton\n    The denomination of Autonity’s auton cryptocurrency used to denominate Autonity gas prices. 1 gigaton = 1,000,000,000 ton. The Autonity equivalent of wei is ton and of gwei gigaton."
  },
  {
    "objectID": "glossary/index.html#incentivization-scheme",
    "href": "glossary/index.html#incentivization-scheme",
    "title": "Glossary",
    "section": "incentivization scheme",
    "text": "incentivization scheme\n    A cryptoeconomic mechanism where economic penalties are applied for incorrect actions or state transitions by network participants, enforced by cryptographic proofs of state or action."
  },
  {
    "objectID": "glossary/index.html#jailing",
    "href": "glossary/index.html#jailing",
    "title": "Glossary",
    "section": "jailing",
    "text": "jailing\n    A protocol action that excludes a validator from selection to the consensus committee for a designated period of time as a slashing penalty. Jailing may be temporary or permanent. See jail period and jailbound ."
  },
  {
    "objectID": "glossary/index.html#jailbound",
    "href": "glossary/index.html#jailbound",
    "title": "Glossary",
    "section": "jailbound",
    "text": "jailbound\n    A state in which a validator is permanently barred from selection to the consensus committee. A validator may only enter a jailbound state if a 100% slashing penalty is applied."
  },
  {
    "objectID": "glossary/index.html#jail-period",
    "href": "glossary/index.html#jail-period",
    "title": "Glossary",
    "section": "jail period",
    "text": "jail period\n    The period of time for which a validator is temporarily barred from selection to the consensus committee, defined as a number of blocks. The jail period is set as a protocol parameter.\n    The block height marking the end of a validator’s jail period is recorded in validator state as a non-zero value in the jailReleaseBlock property."
  },
  {
    "objectID": "glossary/index.html#key-pair",
    "href": "glossary/index.html#key-pair",
    "title": "Glossary",
    "section": "key pair",
    "text": "key pair\n    A pair of public and private cryptography keys used for signing and encryption. The private key is used to produce signatures that are publicly verifiable using the public key. The public key may also be used to encrypt messages intended for the private key holder who can decrypt them using the private key."
  },
  {
    "objectID": "glossary/index.html#liquid-newton",
    "href": "glossary/index.html#liquid-newton",
    "title": "Glossary",
    "section": "Liquid Newton",
    "text": "Liquid Newton\n    The liquid token representing Newton stake token delegated to a validator in an Autonity Network (see stake delegation). Unlike bonded Newton, Liquid Newton is transferrable and the holder receives due staking rewards. See also Protocol assets, Liquid Newton."
  },
  {
    "objectID": "glossary/index.html#liquid-staking",
    "href": "glossary/index.html#liquid-staking",
    "title": "Glossary",
    "section": "liquid staking",
    "text": "liquid staking\n    A staking model in which funds staked to a Proof of Stake network have a liquid representation of staked assets in the form of a token. For Autonity’s liquid staking model see Staking, Liquid staking."
  },
  {
    "objectID": "glossary/index.html#mesh-network",
    "href": "glossary/index.html#mesh-network",
    "title": "Glossary",
    "section": "mesh network",
    "text": "mesh network\n    A network topology where each node is connected to one or more other network nodes. All nodes in the mesh relay data and co-operate in the distribution of data across the network. A mesh topology can be full or partial.\n    In a full mesh topology each node is directly connected to every other node. In a partial mesh topology a node is directly connected to a subset of the other network nodes only."
  },
  {
    "objectID": "glossary/index.html#native-coin",
    "href": "glossary/index.html#native-coin",
    "title": "Glossary",
    "section": "native coin",
    "text": "native coin\n    A cryptocurrency that is inherent to a decentralised computer network.\n    Autonity tokenomics have the native coin Auton and ERC20 tokens Newton and Liquid Newton."
  },
  {
    "objectID": "glossary/index.html#newton",
    "href": "glossary/index.html#newton",
    "title": "Glossary",
    "section": "Newton",
    "text": "Newton\n    The stake token used to stake an Autonity network. Once Newton is staked it is locked and only redeemable by unbonding after an unbonding period. Newton can be in three states (bonded, unbonded, unbonding) as described in Protocol assets, Newton. See Proof of Stake (PoS)."
  },
  {
    "objectID": "glossary/index.html#node",
    "href": "glossary/index.html#node",
    "title": "Glossary",
    "section": "node",
    "text": "node\n    A participant running the Autonity Go Client software and able to connect to an Autonity network. See peer mesh network, peer-to-peer network."
  },
  {
    "objectID": "glossary/index.html#oracle-network",
    "href": "glossary/index.html#oracle-network",
    "title": "Glossary",
    "section": "oracle network",
    "text": "oracle network\n    The network of validator-operated oracles that submits price data from off-chain external data providers on-chain and votes on agreeing an aggregated median price data according to an oracle protocol.\n    The set of Autonity Oracle Server (AOS) instances run by validators nodes logically forms an “Autonity oracle network”.\n    Median price data is computed by protocol in voting rounds."
  },
  {
    "objectID": "glossary/index.html#participant",
    "href": "glossary/index.html#participant",
    "title": "Glossary",
    "section": "participant",
    "text": "participant\n    A peer node that is currently connected to other nodes in an Autonity network.\n    A participant is able to sync state, and broadcast and receive transactions, and potentially be a validator node."
  },
  {
    "objectID": "glossary/index.html#peer",
    "href": "glossary/index.html#peer",
    "title": "Glossary",
    "section": "peer",
    "text": "peer\n    A node which is currently connected to other nodes in a peer-to-peer network and is a participant in that network."
  },
  {
    "objectID": "glossary/index.html#peer-to-peer-network-p2p",
    "href": "glossary/index.html#peer-to-peer-network-p2p",
    "title": "Glossary",
    "section": "peer-to-peer network (p2p)",
    "text": "peer-to-peer network (p2p)\n    A distributed systems architecture in which the systems’ resources are pooled and shared across nodes that are peers of the network."
  },
  {
    "objectID": "glossary/index.html#penalty-absorbing-stake-pas",
    "href": "glossary/index.html#penalty-absorbing-stake-pas",
    "title": "Glossary",
    "section": "Penalty-Absorbing Stake (PAS)",
    "text": "Penalty-Absorbing Stake (PAS)\n    A stake slashing model whereby self-bonded stake is slashed before delegated stake when applying slashing penalties for accountability events.\n    In the PAS model self-bonded stake absorbs any slashing penalties before they are applied pro-rata to the remaining delegated stake."
  },
  {
    "objectID": "glossary/index.html#permissionless-network",
    "href": "glossary/index.html#permissionless-network",
    "title": "Glossary",
    "section": "permissionless network",
    "text": "permissionless network\n    A peer-to-peer network where access is open and public. Any node can connect to the network and become a peer."
  },
  {
    "objectID": "glossary/index.html#proof-of-stake-pos",
    "href": "glossary/index.html#proof-of-stake-pos",
    "title": "Glossary",
    "section": "Proof of Stake (PoS)",
    "text": "Proof of Stake (PoS)\n    A consensus algorithm where the blockchain is secured by economic value through bonding stake token to validators. Consensus committee members are chosen by a selection mechanism that maximises the amount of stake backing the committee and so the economic value securing the network.\n    If the protocol determines that a validator has failed to follow consensus rules, slashing penalties are applied according to Autonity’s accountability and fault detection protocol."
  },
  {
    "objectID": "glossary/index.html#self-bonded",
    "href": "glossary/index.html#self-bonded",
    "title": "Glossary",
    "section": "self-bonded",
    "text": "self-bonded\n    Stake token bonded to a validator where the validator is the stakeholder. The account submitting the stake delegation transaction (cf. bond) is the validator treasury account.\n    Self-bonded stake earns staking rewards, but unlike delegated stake does not have Liquid Newton minted for the Newton stake token bonded.\n    Stake delegation transactions submitted from other stakeholder accounts result in delegated stake."
  },
  {
    "objectID": "glossary/index.html#slashing",
    "href": "glossary/index.html#slashing",
    "title": "Glossary",
    "section": "slashing",
    "text": "slashing\n    A protocol action that reduces the amount of a validator’s bonded stake as a slashing penalty."
  },
  {
    "objectID": "glossary/index.html#slashing-penalty",
    "href": "glossary/index.html#slashing-penalty",
    "title": "Glossary",
    "section": "slashing penalty",
    "text": "slashing penalty\n    An economic penalty applied to a validator for misbehaviour. Examples of slashing penalty are: stake slashing, stake freezing, jailing."
  },
  {
    "objectID": "glossary/index.html#smart-contract",
    "href": "glossary/index.html#smart-contract",
    "title": "Glossary",
    "section": "smart contract",
    "text": "smart contract\n    The program code for encoding and executing decentralised application logic in the EVM. Smart contracts are written in a higher level programming language such as ‘Solidity’ and compiled to bytecode for execution in the EVM. A smart contract stores the application’s state."
  },
  {
    "objectID": "glossary/index.html#stake-token",
    "href": "glossary/index.html#stake-token",
    "title": "Glossary",
    "section": "stake token",
    "text": "stake token\n    The token used as economic value to secure a blockchain in Proof of Stake (PoS) consensus.\n    Autonity’s stake token is Newton."
  },
  {
    "objectID": "glossary/index.html#stakeholder",
    "href": "glossary/index.html#stakeholder",
    "title": "Glossary",
    "section": "stakeholder",
    "text": "stakeholder\n    A network participant that holds an amount of the Newton stake token."
  },
  {
    "objectID": "glossary/index.html#staking",
    "href": "glossary/index.html#staking",
    "title": "Glossary",
    "section": "staking",
    "text": "staking\n    The process by which stake is delegated to a validator node in a Proof of Stake (PoS) blockchain. Validators with bonded stake participate in transaction validation if a member of the consensus committee. Stake can be self-bonded or delegated."
  },
  {
    "objectID": "glossary/index.html#staking-rewards",
    "href": "glossary/index.html#staking-rewards",
    "title": "Glossary",
    "section": "staking rewards",
    "text": "staking rewards\n    Revenue earned by bonded stake when it is actively securing the network during consensus. Only stake bonded to members of the current consensus committee earn staking rewards."
  },
  {
    "objectID": "glossary/index.html#staking-wallet-account",
    "href": "glossary/index.html#staking-wallet-account",
    "title": "Glossary",
    "section": "staking wallet account",
    "text": "staking wallet account\n    The account used by a stakeholder for stake delegation. This is the account address used to submit transactions for operations to:\n    \n    bond and unbond Newton stake token to a validator in Autonity’s liquid staking model\n    transfer Liquid Newton to another account\n    claim rewards for stake delegation."
  },
  {
    "objectID": "glossary/index.html#state-database",
    "href": "glossary/index.html#state-database",
    "title": "Glossary",
    "section": "state database",
    "text": "state database\n    The local data store of a node used to persist the node’s local copy of system state."
  },
  {
    "objectID": "glossary/index.html#system-state",
    "href": "glossary/index.html#system-state",
    "title": "Glossary",
    "section": "system state",
    "text": "system state\n    The computational state of an Autonity system. State is computed according to the Autonity Protocol. System state is stored as key-value pairs, mapping between account addresses and account states in Ethereum’s modified Merkle Patricia trie data structure (See Merkle Patricia Tree, Ethereum Developer docs)."
  },
  {
    "objectID": "glossary/index.html#ton",
    "href": "glossary/index.html#ton",
    "title": "Glossary",
    "section": "ton",
    "text": "ton\n    The smallest denomination of Autonity’s auton native cryptocurrency. 1 auton = 1,000,000,000,000,000,000 ton (10^18). The ton is Autonity’s equivalent denomination to Ethereum’s wei. See also gigaton."
  },
  {
    "objectID": "glossary/index.html#transaction-fee-mechanism-tfm",
    "href": "glossary/index.html#transaction-fee-mechanism-tfm",
    "title": "Glossary",
    "section": "transaction fee mechanism (TFM)",
    "text": "transaction fee mechanism (TFM)\n    The protocol mechanism for pricing the cost of processing a transaction on a blockchain."
  },
  {
    "objectID": "glossary/index.html#unbond",
    "href": "glossary/index.html#unbond",
    "title": "Glossary",
    "section": "unbond",
    "text": "unbond\n    The operation of unbonding stake from a validator.\n    In Autonity’s liquid staking model stake can be unbonded at any time, but staked Newton is not redeemable until an unbonding period has elapsed."
  },
  {
    "objectID": "glossary/index.html#unbonding-period",
    "href": "glossary/index.html#unbonding-period",
    "title": "Glossary",
    "section": "unbonding period",
    "text": "unbonding period\n    The period of time for which bonded stake remains locked after processing an unbonding transaction. Unbonding period is defined as a number of blocks.\n    Proof of Stake consensus places constraints on the minimum length of the unbonding period. It must be long enough to allow the detection and reporting of consensus faults by validators, and not short enough to allow unbonding before a slashing penalty can be applied. As such it is a security property of the network."
  },
  {
    "objectID": "glossary/index.html#unix-time",
    "href": "glossary/index.html#unix-time",
    "title": "Glossary",
    "section": "Unix time",
    "text": "Unix time\n    The Unix OS system for representing a point in time as a timestamp. Time is measured as the number of seconds since the Unix Epoch began - 1st January 1970 at 00:00:00 UTC. Unix time is used for Autonity timestamps. For detail and format see Unix time."
  },
  {
    "objectID": "glossary/index.html#validator",
    "href": "glossary/index.html#validator",
    "title": "Glossary",
    "section": "validator",
    "text": "validator\n    A participant node that has registered as a validator on an Autonity network. Validator nodes may be selected to the consensus committee and participate in consensus if they have enough bonded stake."
  },
  {
    "objectID": "glossary/index.html#vote-period",
    "href": "glossary/index.html#vote-period",
    "title": "Glossary",
    "section": "vote period",
    "text": "vote period\n    An Autonity network’s configured voting period for price voting and aggregation) by the oracle network."
  },
  {
    "objectID": "glossary/index.html#voting-period",
    "href": "glossary/index.html#voting-period",
    "title": "Glossary",
    "section": "voting period",
    "text": "voting period\n    The period of time measured in blocks over which Autonity oracles submit and vote on price data reports to agree an aggregated data price for the currency pair symbols for which an Autonity network provides a median price. See vote period."
  },
  {
    "objectID": "glossary/index.html#voting-power",
    "href": "glossary/index.html#voting-power",
    "title": "Glossary",
    "section": "voting power",
    "text": "voting power\n    The amount of stake bonded by delegation to a validator. A validator’s voting power may also be referred to as its weight. The sum of stake bonded to validators that are members of a consensus committee may be referred to as the total voting power of the committee."
  },
  {
    "objectID": "glossary/index.html#voting-round",
    "href": "glossary/index.html#voting-round",
    "title": "Glossary",
    "section": "voting round",
    "text": "voting round\n    An Autonity network’s configured voting period for computing median price data for currency pairs provided by the oracle network."
  },
  {
    "objectID": "glossary/index.html#wallet",
    "href": "glossary/index.html#wallet",
    "title": "Glossary",
    "section": "wallet",
    "text": "wallet\n    A software application that provides functionality for a system user to access and manage their accounts."
  },
  {
    "objectID": "glossary/index.html#wei",
    "href": "glossary/index.html#wei",
    "title": "Glossary",
    "section": "wei",
    "text": "wei\n    The smallest denomination of Ethereum’s ether native cryptocurrency. 1 ether = 1,000,000,000,000,000,000 wei (10^18). In Ethereum gas prices are denominated in gwei - giga wei (10^9), 1 gwei = 1,000,000,000 wei. The Autonity equivalent of wei is ton and of gwei gigaton."
  },
  {
    "objectID": "node-operators/connect/index.html",
    "href": "node-operators/connect/index.html",
    "title": "Connecting to your Node",
    "section": "",
    "text": "This guide assumes that queries and transactions are created and submitted from a local machine, on which aut has been installed."
  },
  {
    "objectID": "node-operators/connect/index.html#configure-aut-local-machine",
    "href": "node-operators/connect/index.html#configure-aut-local-machine",
    "title": "Connecting to your Node",
    "section": "Configure aut (local machine)",
    "text": "Configure aut (local machine)\n    As a convenience, we configure aut to connect to your node without having to specify this on the command line. Edit the rpc_endpoint entry in your .autrc file:\n    rpc_endpoint=http://XX.XX.XX.XX:8545/\n    where XX.XX.XX.XX is the IP address used to connect to your host machine running the Autonity Go Client.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If you chose to expose the Web Socket end-point of your node, the URL will be of the form ws://XX.XX.XX.XX:8546/.\n    \n    \n    \n    Use the node info query to check the connection:\n    aut node info\n    {\n    \"eth_accounts\": [],\n    \"eth_blockNumber\": 12803619,\n    \"eth_gasPrice\": 1000000000,\n    \"eth_syncing\": false,\n    \"eth_chainId\": 65100000,\n    \"net_listening\": true,\n    \"net_peerCount\": 19,\n    \"net_networkId\": \"65100000\",\n    \"web3_clientVersion\": \"Autonity/v0.9.0/linux-amd64/go1.19\",\n    \"admin_enode\": \"enode://d9a7297b2bec3c2f92233dc42f53c0cf98af30528a56765b102d9e28be2a760b7fd3045790246d1a5836af9a8ea5d2dbcc9b56864f6391045ba76391d9db931e@77.86.9.81:30303\",\n    \"admin_id\": \"8794927d6dda6f8cb45bc7eefd9084dbb3b81ce508ff43e1ccb7fe904ccd2cfc\"\n}\n    The admin_enode entry should display the external IP of your host machine at the end."
  },
  {
    "objectID": "node-operators/connect/index.html#example-queries",
    "href": "node-operators/connect/index.html#example-queries",
    "title": "Connecting to your Node",
    "section": "Example queries",
    "text": "Example queries\n    The following are examples of simple queries to help familiarise yourself with aut and the Autonity network.\n    \n    Get the block number:\n    aut block height\n    12877058\n    \n    \n    Get maximum consensus committee size:\n    aut protocol get-max-committee-size\n    100\n    \n    Get all nodes in the consensus committee:\n    aut protocol get-committee\n    [\n  {\n    \"address\": \"0x2F3339fE44c184291a98Ff20dE8A303cfB96ae79\",\n    \"voting_power\": 10087\n  },\n  {\n    \"address\": \"0x1378f0691272781D18B3B277F185FAB2De0091Aa\",\n    \"voting_power\": 10002\n  },\n\n  ...\n\n  {\n    \"address\": \"0xeda5be17ccA4aa99fca6326Fb8fFDDDe72d813eF\",\n    \"voting_power\": 50\n  }\n]\n    \n    \n    \n    List the set of registered validators\n    aut validator list\n    0x32F3493Ef14c28419a98Ff20dE8A033cf9e6aB97\n0x31870f96212787D181B3B2771F58AF2BeD0019Aa\n0x6EBb5A45728be7Cd9fE9c007aDD1e8b3DaFF6B3B\n0xAC245aF88265E72881CD9D21eFb9DDC32E174B69\n0x36288C1F8C990fd66A1C5040a61d6f3EcF3A49c1\n0xb3A3808c698d82790Ac52a42C05E4BCb3dfCd3db\n0x467D99EA9DACC495E6D1174b8f3Dd20DDd531335\n0xba35a25badB802Cb3C0702e0e2df392e00511CA2\n0x9fd408Bdb83Be1c8504Ff13eBcCe7f490DCCC2cF\n0xE03D1DE3A2Fb5FEc85041655F218f18c9d4dac55\n0x52b89AFA0D1dEe274bb5e4395eE102AaFbF372EA\n0xFae912BAdB5e0Db5EC0116fe6552e8D6Bdb4e82b\n0xE4Ece2266Ea7B7468aD3E381d08C962641b567f2\n0xCD46183D0075116175c62dCDe568f2e0c4736597\n0xeb25090AA0fD5c940F87A172Aaf62413Eb625b63\n0x2AF517e6EdF3C01f8256E609122f004457024E67\n0x9f793D2c7E1D5a72A020281F383bfc5e3086AcA9\n0xde5aeb71cc4Aaa99cf6a23F68bFfDdDD7e8231Fe\n    \n    \n    Check the auton balance of an account:\n    aut account balance &lt;_addr&gt;\n    9.00341\n    \n    \n    Check the newton balance of an account:\n    aut account balance --ntn &lt;_addr&gt;\n    3.73401\n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    Once your node has been properly set up, you may consider making it a validator node to further help secure the network and earn rewards."
  },
  {
    "objectID": "node-operators/setup-node-monitoring/index.html",
    "href": "node-operators/setup-node-monitoring/index.html",
    "title": "Set up node monitoring",
    "section": "",
    "text": "This guide outlines how to set up metrics infrastructure for an Autonity Go Client using a standard open source software stack to record, filter, and analyse performance metrics. This provides an ‘observability stack’ that can then be used for monitoring a single node installation or multiple nodes. For example, when operating several nodes across a number of hosting providers.\nThe pipeline for this metrics infrastructure is: AGC &gt; Telegraf &gt; InfluxDB v2.x database &gt; Grafana. Telegraf is used to collect metrics from the AGC client and forward them to an InfluxDB V2 database, which is then used as a data source for Grafana dashboards. Note that this guide uses Telegraf but it is optional in this pipeline as AGC can be directly configured to export to InfluxDB.\nThe pipeline for this is: AGC &gt; Telegraf &gt; InfluxDB v2.x database &gt; Grafana. Telegraf is used to collect metrics from the AGC client and forward them to an InfluxDB V2 database, which is then used as a data source for Grafana dashboards.\nThe steps covered are:"
  },
  {
    "objectID": "node-operators/setup-node-monitoring/index.html#prerequisites",
    "href": "node-operators/setup-node-monitoring/index.html#prerequisites",
    "title": "Set up node monitoring",
    "section": "Prerequisites",
    "text": "Prerequisites\n    \n    An installation of Autonity Go Client (AGC), with the --metrics and --pprof flags enabled.\n    An installation of Telegraf server agent, which will provide the backend service for metrics collection.\n    An installation of Docker. See Get setup, Install Docker if Docker is not already installed onto the host machine.\n    \n    Familiarity with monitoring and the basics of the third-party products used in this guide is assumed:\n    \n    Telegraf server agent for metrics collection.\n    InfluxDB V2 time-series data platform.\n    Grafana observability dashboarding for monitoring and analysing metrics, log data, and application trace data."
  },
  {
    "objectID": "node-operators/setup-node-monitoring/index.html#install-influxdb-v2-and-grafana",
    "href": "node-operators/setup-node-monitoring/index.html#install-influxdb-v2-and-grafana",
    "title": "Set up node monitoring",
    "section": "Install Influxdb v2 and Grafana",
    "text": "Install Influxdb v2 and Grafana\n    \n    Make persistent container volumes:\n    \n    docker volume create grafana-storage\ndocker volume create influx-storage\n    This folder will be used to store the volumes for both InfluxDB and Grafana, so they will have persistent storage.\n    \n    Make a Docker network for InfluxDB and Grafana to communicate securely:\n    \n    docker network create --driver bridge influxdb-grafana-net\n    \n    Start InfluxDB Docker container\n    docker run \\\n  -d \\\n  --rm \\\n  --name=influxdb \\\n  --net=influxdb-grafana-net \\\n  -p 8086:8086 \\\n  -v influx-storage:/root/.influxdb2 \\\n  influxdb:2.0\n    Go to the InfluxDB GUI at localhost:8086 in a browser and setup a user and bucket, save the Token, or create a new one, as this will be needed for both Telegraf and Grafana.\n    To stop the InfluxDB container enter docker stop."
  },
  {
    "objectID": "node-operators/setup-node-monitoring/index.html#setup-telegraf",
    "href": "node-operators/setup-node-monitoring/index.html#setup-telegraf",
    "title": "Set up node monitoring",
    "section": "Setup Telegraf",
    "text": "Setup Telegraf\n    The metrics collection service Telegraf can be run in the Docker image or as a binary. Telegraf can be run in the same VM as Autonity or a different one. This guide assumes both AGC and the Telegraf agent are hosted on the same VM. If you set them up on different VM’s, then in the template configuration below edit the inputs.prometheus urls to replace localhost with the IP address of the VM running Autonity.\n    \n    Get Telegraf Docker image\n    To pull the latest Docker image run the command:\n    docker pull telegraf\n    Or to download the latest Telegraf binary go to the Telegraf download and select the Telegraf ‘platform’ release for your host environment.\n    At time of writing this is version 1.24.2. To install on Ubuntu Linux run the command:\n    wget https://dl.influxdata.com/telegraf/releases/telegraf-1.24.2_linux_amd64.tar.gz\ntar xf telegraf-1.24.2_linux_amd64.tar.gz\n    \n    \n    Configure Telegraf\n    In the working directory Telegraf will be run from, create the configuration file telegraf.conf based on the template below, editing where:\n    \n    &lt;NETWORK_ID&gt;: Use value of chainId from the network’s Genesis configuration.\n    &lt;AGC_NODE_NAME&gt;: is replaced by a string with a human-readable label for the node. This is used as the name for the node in the Grafana metrics dashboard.\n    Optionally edit the [[inputs.prometheus]] urls URL value to replace localhost with the IP address of your AGC if it is running on a different host to the Telegraf instance.\n    &lt;OUTPUTS_INFLUXDB_URL&gt;: is the influxdb v2.x endpoint for example - http://localhost:8086 if installed on the same VM as the telegraf agent.\n    &lt;BUCKET&gt;: is replaced by the name of the destination bucket written into.\n    &lt;TOKEN&gt;: is replaced by the InfluxDB V2 token you have created in the initial steps of this tutorial.\n    \n    [global_tags]\nnetworkid = \"&lt;NETWORK_ID&gt;\"\nafnc_name = \"&lt;AGC_NODE_NAME&gt;\"\nuser = \"test\"\n[agent]\nround_interval = true\nmetric_batch_size = 1000\nmetric_buffer_limit = 10000\ncollection_jitter = \"0s\"\nflush_interval = \"10s\"\nflush_jitter = \"0s\"\nprecision = \"\"\ndebug = false\nquiet = false\nlogfile = \"\"\nhostname = \"\"\nomit_hostname = false\n[[inputs.prometheus]]\nurls = [\"http://localhost:6060/debug/metrics/prometheus\"]\n\n[[outputs.influxdb_v2]]\nurls = [ \"&lt;OUTPUTS_INFLUXDB_URL&gt;\"]\norganization = \"autonity\"\nbucket = \"&lt;BUCKET&gt;\"\ntoken = \"&lt;TOKEN&gt;\"\n    You are now ready to run telegraf in your working directory."
  },
  {
    "objectID": "node-operators/setup-node-monitoring/index.html#setup-autonity-to-export-metrics",
    "href": "node-operators/setup-node-monitoring/index.html#setup-autonity-to-export-metrics",
    "title": "Set up node monitoring",
    "section": "Setup Autonity to export metrics",
    "text": "Setup Autonity to export metrics\n    To configure Autonity for exporting metrics set command line options when starting the node for:\n    \n    the Autonity testnet being connected to: --piccadilly or --bakerloo.\n    enabling metrics collection and reporting: --metrics.\n    enabling the pprof HTTP server: --pprof.\n    \n    The Piccadilly Testnet is connected to in the example configuration here. For a minimal command line start configuration see the how to Run Autonity.\n    Autonity will serve an http feed that provides metrics at http://localhost:6060/debug/metrics/prometheus, which you can view in a browser. Notice this is the input specified in telegraf.conf above. If you are using Docker, make sure you run the container as host, as shown below:\n    docker run \\\n-d \\\n--volume $(pwd)/autonity-chaindata:/autonity-chaindata \\\n--net=host \\\n--name autonity \\\n--rm \\\nghcr.io/autonity/autonity/autonity:latest \\\n    --datadir ./autonity-chaindata  \\\n    --piccadilly \\\n    --http  \\\n    --http.api aut,eth,net,txpool,web3,admin  \\\n    --ws  \\\n    --ws.addr 0.0.0.0 \\\n    --ws.api aut,eth,net,personal,txpool,web3,admin  \\\n    --nat extip:$(echo $IP_ADDRESS) \\\n    --metrics \\\n    --pprof"
  },
  {
    "objectID": "node-operators/setup-node-monitoring/index.html#start-telegraf-to-export-metrics",
    "href": "node-operators/setup-node-monitoring/index.html#start-telegraf-to-export-metrics",
    "title": "Set up node monitoring",
    "section": "Start Telegraf to export metrics",
    "text": "Start Telegraf to export metrics\n    \n    Start Telegraf. Open the working directory where you created your telegraf.conf config file.\n    To start Telegraf running in a Docker container:\n      docker run  -d --net=host -v $PWD/telegraf.conf:/etc/telegraf/telegraf.conf telegraf\n    Or if using the Telegraf binary then run with the config:\n    telegraf --config telegraf.conf\n    The Telegraf agent will initialise, report its config, and connect to the inputs url specified in telegraf.conf. Telegraf will now export metrics to the InfluxDB V2 database for the testnet you have installed in this tu\n    To stop an Autonity Go Client or Telegraf instance enter CTRL+C if running a binary or docker stop if running a Docker container."
  },
  {
    "objectID": "node-operators/setup-node-monitoring/index.html#start-grafana-docker-container",
    "href": "node-operators/setup-node-monitoring/index.html#start-grafana-docker-container",
    "title": "Set up node monitoring",
    "section": "Start Grafana Docker container",
    "text": "Start Grafana Docker container\n    docker run \\\n  -d \\\n  --rm \\\n  --name=grafana \\\n  --net=influxdb-grafana-net \\\n  -p 3000:3000 \\\n  -v grafana-storage:/var/lib/grafana \\\n  grafana/grafana\n    To view Grafana, go to localhost:3000 in a browser and login with username admin, and password admin, then set a new password. Once logged in, set a new InfluxDB data source:\n    \n    Use flux query language.\n    Use the url http://influxdb:8086.\n    Disable Basic Auth.\n    Use the organisation, token and default bucket from InfluxDB.\n    \n    You will now be able to create a dashboard to visualise node metrics on Grafana. For help getting started with writing queries in Grafana, checkout this guide on the Flux query language.\n    To stop the Grafana Docker container enter docker stop.\n    \n    If you need help, you can chat to us on Autonity Discord Server!"
  },
  {
    "objectID": "node-operators/index.html",
    "href": "node-operators/index.html",
    "title": "Running a Node",
    "section": "",
    "text": "All nodes on the Autonity network exchange blocks and transactions with other nodes, keeping track of the current state of the blockchain. Running a node offers the possibility of having a dedicated RPC endpoint for querying and for accepting transactions. DApps running on the network may take advantage of dedicated nodes for any “backend” or off-chain operations.\n    This guide describes the steps to install, configure and run an instance of the Autonity Go Client (AGC) on an Autonity testnet, and describes how to use the Autonity Utility Tool aut to connect to the node and perform some basic operations.\n    It is assumed that you have setup aut and have an account with funds that is able to submit transactions to the network. See the Account Holder Guide for details.\n    The approach taken in this guide is to run the Autonity Go Client on a dedicated host machine (a VPS or other host that is always-on and persistently available). Transactions and queries are expected to be created (and signed) on a distinct local machine, and then sent to the Autonity Go Client running on the host via the RPC endpoint. This setup may be adjusted to suit each specific deployment.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    This guide is intended for use on testnets (see Networks), on which there is no real-world value at stake. A production setup will likely have requirements not covered by this guide, such as node availability and security. For example, the configuration outlined here exposes an unencrypted http RPC end-point. For production an operator may wish to configure authentication and encryption (for example using a reverse-proxy such as NGINX).\n    \n    \n    \n    Further information about Autonity concepts and terminology are available in this documentation.\n    \n    If you need help, you can chat to us on Discord Server!"
  },
  {
    "objectID": "node-operators/run-aut/index.html",
    "href": "node-operators/run-aut/index.html",
    "title": "Run Autonity",
    "section": "",
    "text": "Prerequisites\n    \n    \n    \n    \n    \n    \n    Ensure that the host machine meets the minimum requirements"
  },
  {
    "objectID": "node-operators/run-aut/index.html#run-binary",
    "href": "node-operators/run-aut/index.html#run-binary",
    "title": "Run Autonity",
    "section": "Run Autonity (binary or source code install)",
    "text": "Run Autonity (binary or source code install)\n    \n    Ensure that the Autonity Go Client has been installed from a pre-compiled binary or from source code\n    \n    To connect to a network and sync, get the genesis and bootnode files if needed, and run Autonity. Autonity will initialise, connect to the network, and then sync ledger state.\n    \n    Create and enter a working directory for autonity.\n    Create the autonity-chaindata directory to hold the autonity working data:\n    mkdir autonity-chaindata\n    Start autonity:\n    autonity \\\n    --datadir ./autonity-chaindata \\\n    --piccadilly  \\\n    --http  \\\n    --http.addr 0.0.0.0 \\\n    --http.api aut,eth,net,txpool,web3,admin \\\n    --http.vhosts \"*\" \\\n    --ws  \\\n    --ws.addr 0.0.0.0 \\\n    --ws.api aut,eth,net,txpool,web3,admin  \\\n    --nat extip:&lt;IP_ADDRESS&gt; \\\n    --consensus.nat &lt;CONSENSUS_NAT&gt; \\\n    --consensus.port &lt;CONSENSUS_PORT_NUMBER&gt; \\\n    ;\n    where:\n    \n    &lt;IP_ADDRESS&gt; is the node’s host IP Address, which can be determined with curl ifconfig.me.\n    (Optional) &lt;CONSENSUS_NAT&gt; specify the NAT port mapping for the consensus channel (one of “any”, “none”, “upnp”, “pmp”, “extip:”) if the default value “any” is not to be used.\n    (Optional) &lt;CONSENSUS_PORT_NUMBER&gt; specify the network listening port for the consensus channel if the default port “20203” is not to be used.\n    --piccadilly specifies that the node will connect to the Piccadilly testnet. For other testnets, use the appropriate flag (for example, --bakerloo).\n    \n    \n    \n    \n    \n    \n    \n    \n    Default location for AGC’s node and consensus private keys file autonitykeys\n    \n    \n    \n    \n    \n    On starting, by default AGC will automatically generate an autonitykeys file containing your node key and consensus key within the autonity subfolder of the --datadir specified when running the node.\n    The autonitykeys file contains the private keys of (a) the node key used for transaction gossiping with other network peer nodes, and (b) the consensus key used for consensus gossiping with other validators if your node is run as a validator and is participating in consensus.\n    If you choose not to store your key in the default location, then specify the path to where you are keeping your autonitykeys file using the --autonitykeys option in the run command.\n    \n    \n    \n    See the Autonity command-line reference for the full set of available flags.\n    Autonity will download the blockchain in “snap” syncmode by default. Once fully synced, it will continue to import new chain segments as they are finalized."
  },
  {
    "objectID": "node-operators/run-aut/index.html#run-docker",
    "href": "node-operators/run-aut/index.html#run-docker",
    "title": "Run Autonity",
    "section": "Run Autonity as Docker image",
    "text": "Run Autonity as Docker image\n    \n    Ensure that the Autonity Go Client Docker image has been installed.\n    \n    \n    Create and enter a working directory for autonity.\n    Create the autonity-chaindata directory to hold the autonity working data:\n    mkdir autonity-chaindata\n    Start the node. Set the Docker configuration and the arguments for connecting Autonity to a network.\n    docker run \\\n    -t -i \\\n    --volume $(pwd)/autonity-chaindata:/autonity-chaindata \\\n    --publish 8545:8545 \\\n    --publish 8546:8546 \\\n    --publish 30303:30303 \\\n    --publish 30303:30303/udp \\\n    --publish 20203:20203 \\\n    --publish 6060:6060 \\\n    --name autonity \\\n    --rm \\\n    ghcr.io/autonity/autonity:latest \\\n        --datadir ./autonity-chaindata  \\\n        --piccadilly \\\n        --http  \\\n        --http.addr 0.0.0.0 \\\n        --http.api aut,eth,net,txpool,web3,admin  \\\n        --http.vhosts \"*\" \\\n        --ws  \\\n        --ws.addr 0.0.0.0 \\\n        --ws.api aut,eth,net,txpool,web3,admin  \\\n        --nat extip:&lt;IP_ADDRESS&gt; \\\n        --consensus.nat &lt;CONSENSUS_NAT&gt; \\\n        --consensus.port &lt;CONSENSUS_PORT_NUMBER&gt; \\\n     ;\n    where:\n    \n    &lt;IP_ADDRESS&gt; is the node’s host IP Address, which can be determined with curl ifconfig.me.\n    (Optional) &lt;CONSENSUS_NAT&gt; specify the NAT port mapping for the consensus channel (one of “any”, “none”, “upnp”, “pmp”, “extip:”) if the default value “any” is not to be used.\n    (Optional) &lt;CONSENSUS_PORT_NUMBER&gt; specify the network listening port for the consensus channel if the default port “20203” is not to be used.\n    --piccadilly specifies that the node will connect to the Piccadilly testnet. For other testnets, use the appropriate flag (for example, --bakerloo).\n    \n    See the Autonity command-line reference for the full set of available flags.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    \n    Note that all flags after the image name are passed to the Autonity Go Client in the container, and thus follow the same pattern as for running a binary or source install\n    The command above creates a temporary container, which is deleted (via the --rm flag) when the node is shut down.\n    The hosts autonity-chaindata directory is mounted in the container (via the --volume option). All working data will be saved in this directory and therefore persisted even when the temporary container is removed.\n    The same autonity-chaindata directory can thereby be used by both a local binary and the docker image (although not at the same time), allowing administrators to switch between run methods at any time.\n    The --publish flag causes incoming connections to the localhost to be forwarded to the container.\n    \n    \n    \n    \n    Naturally, the above command line can be tailored to suit a specific deployment. See the docker documentation for the complete list of Docker options."
  },
  {
    "objectID": "node-operators/run-aut/index.html#stopping-the-autonity-go-client",
    "href": "node-operators/run-aut/index.html#stopping-the-autonity-go-client",
    "title": "Run Autonity",
    "section": "Stopping the Autonity Go Client",
    "text": "Stopping the Autonity Go Client\n    To shutdown the node, press CTRL-C and wait for it to exit.\n    \n    \n    \n    \n    \n    \n    Warning!\n    \n    \n    \n    \n    \n    You must wait for the node to exit successfully. Terminating the process prematurely may risk corruption of the state store (LevelDB).\n    Exit may take up to 3 minutes. If you are using systemd and/or other software services management software, then make sure this is configured to allow for a safe exit time to avoid early shutdown.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    Now you can now connect to your node using aut from your local machine."
  },
  {
    "objectID": "node-operators/run-aut/index.html#migrating-an-autonity-go-client",
    "href": "node-operators/run-aut/index.html#migrating-an-autonity-go-client",
    "title": "Run Autonity",
    "section": "Migrating an Autonity Go Client",
    "text": "Migrating an Autonity Go Client\n    To migrate a node to a new instance the node identity must be preserved. The P2P node keys: autonityKeys and the node’s host ip address must be maintained to keep the same node identifier address and enode url.\n    Copy the P2P node keys: autonityKeys file to a safe location and be sure to maintain your hosting IP address.\n    \n    \n    \n    \n    \n    \n    Static IP Address is required\n    \n    \n    \n    \n    \n    Running an Autonity node requires maintaining a static ip address as described in the guide Install Autonity, Networking section.\n    If you are using a cloud provider for node hosting, then a static IP address for your cloud space should be a stated hosting requirement if you intend to migrate the node. Cloud vendors typically don’t supply a static IP address unless it is purchased explicitly.\n    \n    \n    \n    To migrate, when reinstalling and running the node:\n    \n    Install the node as described in the install autonity guide\n    Migrate the autonitykeys before running the node:\n    \n    Copy your original autonitykeys to the directory location you will use to hold the key when running the node. See &lt;DIR_PATH&gt; in Step 4 of this Guide.\n    \n    Start the node per Step 4 in this guide, maintaining the original IP address value for:\n    \n    --nat extip:&lt;IP_ADDRESS&gt;.\n    (Optional) --consensus-nat extip:&lt;IP_ADDRESS&gt; if you are not using AGC’s default settings for the consensus gossiping channel and have set extip.\n    \n    \n    Autonity will detect and use the original autonitykeys. The new node installation will have the same identity as the original.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If you are running a validator node you need to:\n    \n    pause the validator node before migration, and\n    reactivate the new validator after migration\n    \n    Be sure to fully decommission the original node installation.\n    \n    \n    \n    \n    If you need help, you can chat to us on Autonity Discord Server!"
  },
  {
    "objectID": "node-operators/install-aut/index.html",
    "href": "node-operators/install-aut/index.html",
    "title": "Install Autonity in your environment",
    "section": "",
    "text": "The Autonity Go Client can be installed in several ways:\n    \n    as a pre-compiled Linux Executable File from the Release Archive\n    by building the client from source code\n    in a Docker container.\n    \n    We assume that the Autonity Go Client will run on a host machine (a VPS or other host that is always-on and persistently available), and a distinct local machine will be used for creating transactions and queries which are then sent to the Autonity Go Client on the host via the RPC endpoint.\n    It is recommended not run Autonity using Docker containers outside of a test environment.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Client source code is versioned on a 3-digit major.minor.patch versioning scheme, and hosted and maintained in the public GitHub repo autonity."
  },
  {
    "objectID": "node-operators/install-aut/index.html#overview",
    "href": "node-operators/install-aut/index.html#overview",
    "title": "Install Autonity in your environment",
    "section": "",
    "text": "The Autonity Go Client can be installed in several ways:\n    \n    as a pre-compiled Linux Executable File from the Release Archive\n    by building the client from source code\n    in a Docker container.\n    \n    We assume that the Autonity Go Client will run on a host machine (a VPS or other host that is always-on and persistently available), and a distinct local machine will be used for creating transactions and queries which are then sent to the Autonity Go Client on the host via the RPC endpoint.\n    It is recommended not run Autonity using Docker containers outside of a test environment.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Client source code is versioned on a 3-digit major.minor.patch versioning scheme, and hosted and maintained in the public GitHub repo autonity."
  },
  {
    "objectID": "node-operators/install-aut/index.html#requirements",
    "href": "node-operators/install-aut/index.html#requirements",
    "title": "Install Autonity in your environment",
    "section": "Requirements",
    "text": "Requirements\n    \n    Hardware\n    To run an Autonity Go Client node, we recommend using a host machine (physical or virtual) with the following minimum specification:\n    \n    \n    \n    \n    \n    \n    \n    \n    Requirement\n    At least\n    Recommended\n    \n    \n    \n    \n    OS\n    Ubuntu 20.04 LTS\n    Ubuntu 20.04 LTS\n    \n    \n    CPU\n    3.10 GHz with 8 CPU’s\n    3.10 GHz with 16 CPU’s\n    \n    \n    RAM\n    8GB\n    16GB\n    \n    \n    Storage\n    1024GB free storage for full nodes and Validators\n    1024 GB free storage for full nodes and validators\n    \n    \n    Network interface\n    200 Mbit/s\n    200 Mbit/s\n    \n    \n    \n    \n    \n    Network\n    A public-facing internet connection with static IP is required:\n    \n    If you are using a cloud provider for node hosting, then a static IP address for your cloud space should be a stated hosting requirement. Cloud vendors typically don’t supply a static IP address unless it is purchased explicitly.\n    \n    \n    \n    \n    \n    \n    \n    Why is a static IP Address required?\n    \n    \n    \n    \n    \n    Running an Autonity node requires that you maintain a static ip address because the ip address forms part of the node’s network address, the enode URL. The enode provides the network location of the node client for p2p networking. Changing the ip address will change the node’s identity on the network, therefore. This is significant if you are operating a validator node as the enode is provided as part of the validator meta data when registering a validator.\n    \n    \n    \n    Incoming traffic must be allowed on the following:\n    \n    TCP, UDP 30303 for node p2p (DEVp2p) communication for transaction gossiping.\n    \n    You may also choose to allow traffic on the following ports:\n    \n    TCP 8545 to make http RPC connections to the node.\n    TCP 8546 to make WebSocket RPC connections to the node (for example, if you are operating as a validator node to allow a connection from your oracle server if it is running on a different host).\n    TCP 20203 for node p2p (DEVp2p) communication for consensus gossiping (required if you are operating a validator node).\n    TCP 6060 to export Autonity metrics (recommended but not required)\n    \n    \n    \n    \n    \n    \n    \n    \n    Securing ports allowing incoming traffic\n    \n    \n    \n    \n    \n    It is assumed that most administrators will want to restrict access to these ports (unless they wish to support public access to the RPC calls for anonymous clients). However, you should ensure that you can connect to one of the RPC ports from your local machine (e.g. with IP whitelisting in your firewall rules, SSH port forwarding or other technique).\n    \n    \n    \n    The description here covers only the basic network setup. Especially in a production setting, administrators should consider further security measures based on their situation.\n    \n    \n    \n    \n    \n    \n    Security of your node installation\n    \n    \n    \n    \n    \n    As a software system publicly accessible over the Internet, your node installation must be adequately secured!\n    Standard best practices for securing software allowing incoming traffic from the Internet are assumed. For example, firewalls and the configuration of reverse proxies, as well as additional steps required by your own best practices and security policies, are assumed."
  },
  {
    "objectID": "node-operators/install-aut/index.html#install-binary",
    "href": "node-operators/install-aut/index.html#install-binary",
    "title": "Install Autonity in your environment",
    "section": "Installing the pre-compiled executable",
    "text": "Installing the pre-compiled executable\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    A Linux OS running on AMD64 architecture is required to run the pre-compiled executable.\n    \n    \n    \n    \n    Navigate to the Autonity Releases Archive and download the latest stable release version of the client autonity-linux-amd64-&lt;RELEASE_VERSION&gt;.tar.gz from the Assets section.\n    Create a working directory for installing Autonity. For example:\n    mkdir autonity-go-client\ncd autonity-go-client\n    Unpack the downloaded tarball to your working directory:\n    tar -xzf &lt;PATH_TO_DOWNLOADS_DIRECTORY&gt;/autonity-linux-amd64-&lt;RELEASE_VERSION&gt;.tar.gz\n    (Optional) Copy the binary to /usr/local/bin so it can be accessed by all users, or other location in your PATH :\n    sudo cp -r autonity /usr/local/bin/autonity\n    \n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    You can now configure and launch Autonity."
  },
  {
    "objectID": "node-operators/install-aut/index.html#install-source",
    "href": "node-operators/install-aut/index.html#install-source",
    "title": "Install Autonity in your environment",
    "section": "Build from source code",
    "text": "Build from source code\n    \n    \n    \n    \n    \n    \n    Prerequisites\n    \n    \n    \n    \n    \n    The following should be installed in order to build the Autonity Go Client: - Git Follow the official GitHub documentation to install git. (Check if installed: git --version) - Golang (version 1.21 or later) - https://golang.org/dl (Check if installed: go --version or go version) - C compiler (GCC or another) (Check if GCC is installed: gcc --version) - GNU Make (Check if installed: make --version)\n    \n    \n    \n    \n    Clone/Copy the Autonity repo:\n    git clone git@github.com:autonity/autonity.git\n    Enter the autonity directory and ensure you are building from the correct release. This can be done by checking out the Release Tag in a branch:\n    git checkout tags/v0.13.0 -b v0.13.0\n    Build autonity:\n    make autonity\n    (The cmd utilities, including the Clef account management tool, can be built using make all.)\n    (Optional) Copy the generated binary to /usr/local/bin so it can be accessed by all users, or other location in your PATH :\n    sudo cp build/bin/autonity /usr/local/bin/autonity\n    \n    \n    Troubleshooting\n    An error of the form\n    Caught SIGILL in blst_cgo_init, consult &lt;blst&gt;/bindings/go/README.md.\n    thrown on the Go blst package (Go package docs when running the make command indicates missing environment variables for CGO Flags.\n    To resolve:\n    \n    Set environment variables for CGO Flags:\n    export CGO_CFLAGS=\"-O -D__BLST_PORTABLE__\" \nexport CGO_CFLAGS_ALLOW=\"-O -D__BLST_PORTABLE__\"\n    Run make clean to cleanse object and executable files from the previous make run\n    \n    Re-run your make command."
  },
  {
    "objectID": "node-operators/install-aut/index.html#install-docker",
    "href": "node-operators/install-aut/index.html#install-docker",
    "title": "Install Autonity in your environment",
    "section": "Installing the Docker image",
    "text": "Installing the Docker image\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Follow the official Docker documentation to install Docker onto the host machine and follow the post-installation steps to customise for your environment.\n    By default Docker needs to be run with sudo. To avoid using root privileges in the terminal (and error messages if you forget to use sudo), consider following the step to Manage Docker as a non-root user.\n    Consider also configuring Docker to start on boot.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Optional but Recommended\n    \n    \n    \n    \n    \n    To limit the size of the log files, add the following to the file /etc/docker/daemon.json (create it if it does not exist):\n    {\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"500m\",\n    \"max-file\": \"20\"\n  }\n}\n    Restart the Docker service to ensure the change is reflected:\n    sudo systemctl restart docker\n    \n    \n    \n    \n    Pull the Autonity Go Client image from the Github Container Registry: bash     docker pull ghcr.io/autonity/autonity:latest\n    (where latest can be replaced with another version)\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    For more information on using and pulling Docker images from GHCR, see GitHub docs Working with the container registry.\n    \n    \n    \n    Verify the authenticity of the Autonity Docker images against the official image digests:\n    docker images --digests ghcr.io/autonity/autonity\nREPOSITORY                               TAG       DIGEST                                                                    IMAGE ID       CREATED        SIZE\nghcr.io/autonity/autonity                latest    sha256:7298a5fb9834b8cc281b81df1153fcf2f955a292bf3bd5e5d3eb3f80b52f0727   3375da450343   3 weeks ago    54.4MB\n    \n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    You can now configure and launch Autonity."
  },
  {
    "objectID": "node-operators/install-aut/index.html#verify",
    "href": "node-operators/install-aut/index.html#verify",
    "title": "Install Autonity in your environment",
    "section": "Verify the installation",
    "text": "Verify the installation\n    You should now be able to execute the autonity command. Verify your installation by executing autonity version to return the client version and executable build details:\n    $ ./autonity version\n    Autonity\nVersion: 0.13.0-rc\nGit Commit: 8b4a17c18951088c3af01c06da707a87d7887971\nGit Commit Date: 20240210\nArchitecture: amd64\nProtocol Versions: [66]\nGo Version: go1.21.6\nOperating System: linux\nGOPATH=\nGOROOT=\n    \n    If using Docker, the setup of the image can be verified with:\n    $ docker run --rm ghcr.io/autonity/autonity:latest version\n    Autonity\nVersion: 0.10.1\nArchitecture: amd64\nProtocol Versions: [66]\nGo Version: go1.17.10\nOperating System: linux\nGOPATH=\nGOROOT=/usr/local/go\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The output above will vary depending on the version of the Autonity Go Client you have installed. Confirm that the “Version” field is consistent with the version you expect."
  },
  {
    "objectID": "node-operators/install-aut/index.html#next",
    "href": "node-operators/install-aut/index.html#next",
    "title": "Install Autonity in your environment",
    "section": "Next steps",
    "text": "Next steps\n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    You can now configure and launch Autonity.\n    \n    \n    \n    \n    If you need help, you can chat to us on Autonity Discord Server!"
  },
  {
    "objectID": "developer/submit-trans-gov-acct/index.html",
    "href": "developer/submit-trans-gov-acct/index.html",
    "title": "Submit a governance transaction from Autonity Utility Tool (aut)",
    "section": "",
    "text": "Info\n    \n    \n    \n    \n    \n    Governance functions are only callable from the governance operator account of an Autonity network. See the Autonity Interfaces Reference section Operator only for the listing of governance API methods."
  },
  {
    "objectID": "developer/submit-trans-gov-acct/index.html#prerequisites",
    "href": "developer/submit-trans-gov-acct/index.html#prerequisites",
    "title": "Submit a governance transaction from Autonity Utility Tool (aut)",
    "section": "Prerequisites",
    "text": "Prerequisites\n    To submit transactions restricted to the governance operator account from aut you need:\n    \n    An installation of aut - see the howto for further help.\n    To have setup the governance operator account in aut. Import the private key of the governance account as described in Import account using aut.\n    To have funded your governance operator account. If you are running the client in dev mode, the account is already funded. If you are creating a local testnet using a genesis file, you will need to fund the operator account in the genesis configuration file’s alloc data structure.\n    aut should be configured to connect to the local Autonity testnet you have setup."
  },
  {
    "objectID": "developer/submit-trans-gov-acct/index.html#examples",
    "href": "developer/submit-trans-gov-acct/index.html#examples",
    "title": "Submit a governance transaction from Autonity Utility Tool (aut)",
    "section": "Examples",
    "text": "Examples\n    For parameter definitions and usage of the operator only governance functions and the see the Autonity Contract Interfaces Operator only reference.\n    \n    Mint Newton stake token:\n    Mint Autonity’s native staking token, specifying the &lt;RECIPIENT_ADDRESS&gt; and &lt;AMOUNT&gt;:\n    aut protocol mint 1 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 | aut tx sign - | aut tx send -\n    \n    \n    Burn Newton stake token:\n    Burn Autonity’s native staking token, specifying the &lt;RECIPIENT_ADDRESS&gt; and &lt;AMOUNT&gt;:\n    aut protocol burn 1 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 | aut tx sign - | aut tx send -\n    \n    \n    Set minimum base fee:\n    Set a new minimum base fee denominated in Auton, specifying a decimal value:\n    aut protocol set-minimum-base-fee 50000000 | aut tx sign - | aut tx send -"
  },
  {
    "objectID": "developer/index.html",
    "href": "developer/index.html",
    "title": "Development with Autonity",
    "section": "",
    "text": "The steps in this section describe how to set up a local testnet for development and deploy contracts to your local or a public Autonity network.\n    It is assumed that you have:\n    \n    Setup the Autonity Utility Tool (aut).\n    Have an account that has been funded with auton, to pay for transaction gas costs:\n    \n    If deploying to a public network you will need to fund your account from the testnet faucet.\n    If deploying to a custom network you will need to:\n    \n    Fund your dev account(s) in the genesis configuration file’s alloc data structure.\n    If you are running the client in dev mode, there is a pre-funded developer account. See Command line options --dev, --dev.gaslimit, --dev.etherbase.\n    \n    \n    An installation of the Autonity Go Client. See the Running a node guide for details of how to install Autonity in your environment and run it."
  },
  {
    "objectID": "developer/deploy-brownie/index.html",
    "href": "developer/deploy-brownie/index.html",
    "title": "Deploy smart contracts to an Autonity network with Brownie",
    "section": "",
    "text": "This guide uses Brownie and Python to deploy an ERC20 token contract based on the OpenZeppelin open source library."
  },
  {
    "objectID": "developer/deploy-brownie/index.html#setup-brownie",
    "href": "developer/deploy-brownie/index.html#setup-brownie",
    "title": "Deploy smart contracts to an Autonity network with Brownie",
    "section": "Setup brownie",
    "text": "Setup brownie\n    Using pipx or any other python package manager, install brownie:\n    pipx install eth-brownie\n    Add the testnet you would like to deploy the contract to:\n    brownie networks add Ethereum piccadilly host=https://rpc1.piccadilly.autonity.org/ chainid=65100000\n    Here we have used the Piccadilly testnet as an example. See here for other possible networks.\n    Install the OpenZeppelin package, which contains a base ERC20 token implementation:\n    brownie pm install OpenZeppelin/openzeppelin-contracts@4.8.1"
  },
  {
    "objectID": "developer/deploy-brownie/index.html#create-the-token-project",
    "href": "developer/deploy-brownie/index.html#create-the-token-project",
    "title": "Deploy smart contracts to an Autonity network with Brownie",
    "section": "Create the token project",
    "text": "Create the token project\n    mkdir token\ncd token\nbrownie init\n    Create a file brownie-config.yaml in the token directory:\n    dependencies:\n  - OpenZeppelin/openzeppelin-contracts@4.8.1\ncompiler:\n  solc:\n    version: 'v0.8.19'\n    remappings:\n      - '@openzeppelin=OpenZeppelin/openzeppelin-contracts@4.8.1'"
  },
  {
    "objectID": "developer/deploy-brownie/index.html#create-the-token-contract",
    "href": "developer/deploy-brownie/index.html#create-the-token-contract",
    "title": "Deploy smart contracts to an Autonity network with Brownie",
    "section": "Create the token contract",
    "text": "Create the token contract\n    Before you begin, decide upon a (unique) name &lt;TOKEN NAME&gt;, a 3 or 4 digit symbol &lt;TOKEN SYMBOL&gt; and a total supply &lt;TOKEN SUPPLY&gt; for your token (in units of 10^-18 tokens, e.g. a supply of 10 tokens corresponds to 10^19 = 10_000_000_000_000_000_000 units).\n    Create a file contracts/&lt;TOKEN NAME&gt;.sol (for example, if your token name is MyToken, create the file contracts/MyToken.sol:\n    // SPDX-License-Identifier: None\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract &lt;TOKEN NAME&gt; is ERC20{\n    constructor (address owner) ERC20(\"&lt;TOKEN NAME&gt;\",\"&lt;TOKEN SYMBOL&gt;\") {\n        _mint(owner, &lt;TOKEN SUPPLY&gt;);\n    }\n}\n    Check that the contract compiles:\n    brownie compile"
  },
  {
    "objectID": "developer/deploy-brownie/index.html#deploy-the-token-contract",
    "href": "developer/deploy-brownie/index.html#deploy-the-token-contract",
    "title": "Deploy smart contracts to an Autonity network with Brownie",
    "section": "Deploy the Token contract",
    "text": "Deploy the Token contract\n    Create or nominate an account  under your control to act as the owner of the token (the initial holder of the total supply).\n    Create a deployment script scripts/deploy.py:\n    from brownie import accounts, &lt;TOKEN NAME&gt;\n\ndef main(owner):\n    deployer = accounts.load('deployer')\n    &lt;TOKEN NAME&gt;.deploy(owner, {'from': deployer})\n    Generate a deployer account (and password) in brownie.\n    brownie accounts generate deployer\n    (Enter a suitable password when prompted). Alternatively, an existing account can be imported into brownie - see brownie accounts --help.\n    Fund the account in order to pay gas fees.\n    Run the deploy script on the testnet:\n    brownie run --network piccadilly deploy main &lt;OWNER&gt;\n    Take note of the address of the deployed contract. This can be used with the --token option of the aut token commands in order to interact with the deployed token."
  },
  {
    "objectID": "developer/custom-networks/index.html",
    "href": "developer/custom-networks/index.html",
    "title": "Setting up custom networks",
    "section": "",
    "text": "To connect your node to a custom Autonity network, you will need the network’s: - bootnodes, typically given in a static-nodes.json file or specified when running the node with the --bootnodes command-line option. - genesis configuration file, genesis.json.\n    See Local Autonity Network configuration in the Genesis reference for how to create these files.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Note that the client provides command-line flag options for connecting to public Autonity testnets: --bakerloo and --piccadilly. The node will not run if you specify both genesis and bootnodes for a custom network and a testnet flag. The client will create a genesis block for the custom network’s genesis configuration and the node’s local store will then have an incompatible genesis with the testnet.\n    \n    \n    \n    \n    Install Autonity in a working directory and create an autonity-chaindata sub-directory as described in Running a node, Install Autonity.\n    Create and copy the bootnode file into the autonity-chaindata sub directory:\n    \n    cp ./&lt;PATH&gt;/static-nodes.json ./autonity-chaindata/\n    \n    Create and copy the genesis file into the working directory:\n    \n    cp ./&lt;PATH&gt;/genesis.json ./\n    \n    Run the node as described in Running a node, Run Autonity, replacing the network specifier flag (e.g. --piccadilly) with the options:\n    \n    --genesis: to provide the genesis file.\n    --networkid: to provide the network identifier. This is typically the same value as the chainId file in the genesis configuration file, but may be different.\n    \n    An example run command for a local development network on localhost could be:\n    \n    autonity \\\n        --datadir ./autonity-chaindata  \\\n        --genesis ./genesis.json  \\\n        --networkid 65110000 \\\n        --http  \\\n        --http.addr 0.0.0.0 \\\n        --http.api aut,eth,net,txpool,web3,admin  \\\n        --http.vhosts \\* \\\n        --ws  \\\n        --ws.addr 0.0.0.0 \\\n        --ws.api aut,eth,net,txpool,web3,admin  \\\n        --nat extip:&lt;IP_ADDRESS&gt;  \n        ;"
  },
  {
    "objectID": "overview/index.html",
    "href": "overview/index.html",
    "title": "Overview",
    "section": "",
    "text": "Autonity is an EVM-based Layer 1 blockchain protocol for decentralised markets.\n    Autonity networks are public and permissionless. Access is open and anyone can operate a peer node in the blockchain peer-to-peer network.\n    Autonity networks are Byzantine fault-tolerant and secured by delegated Proof of Stake consensus using the Tendermint consensus algorithm. Autonity has native protocol coins for settlement and staking. Autonity implements a liquid staking model.\n    Key technical features of the Autonity Protocol are:\n    \n    Immediate transaction finality in a public environment where participant nodes can join the network dynamically without permission.\n    Delegated Proof of Stake consensus for committee selection and blockchain management, using the Tendermint BFT consensus algorithm.\n    Native protocol assets and stabilization mechanism: Auton utility coin used in the transaction fee mechanism; Newton staking coin for securing the network. Auton price stability is by a CDP-based stabilization mechanism, the Auton Stabilization Mechanism (ASM); the stabilization target is the Auton Currency Unit (ACU), a base-invariant, volatility-minimized index.\n    Liquid staking for capital efficiency and a Penalty-Absorbing Stake model. Delegated Newton stake yields transferrable Liquid Newton tokens, which can be used to redeem the underlying Newton by unbonding stake. Self-bonded stake by validator operators does not yield Liquid Newton and is slashed before delegated stake to assure validator integrity and ‘skin in the game’.\n    Accountability and fault detection (AFD): a protocol for detecting infractions of consensus rules by validators participating in block proposal and voting as a committee member. Failure to adhere to these rules is a rule infraction and AFD will detect and apply slashing penalties for proven rule infractions.\n    Oracle network: a protocol for consensus-computed median price data for selected FX currency pairs as an L1 platform feature. The submission of price data for aggregation and voting is a validator responsibility; validator nodes form an oracle network."
  },
  {
    "objectID": "overview/index.html#what-is-autonity",
    "href": "overview/index.html#what-is-autonity",
    "title": "Overview",
    "section": "",
    "text": "Autonity is an EVM-based Layer 1 blockchain protocol for decentralised markets.\n    Autonity networks are public and permissionless. Access is open and anyone can operate a peer node in the blockchain peer-to-peer network.\n    Autonity networks are Byzantine fault-tolerant and secured by delegated Proof of Stake consensus using the Tendermint consensus algorithm. Autonity has native protocol coins for settlement and staking. Autonity implements a liquid staking model.\n    Key technical features of the Autonity Protocol are:\n    \n    Immediate transaction finality in a public environment where participant nodes can join the network dynamically without permission.\n    Delegated Proof of Stake consensus for committee selection and blockchain management, using the Tendermint BFT consensus algorithm.\n    Native protocol assets and stabilization mechanism: Auton utility coin used in the transaction fee mechanism; Newton staking coin for securing the network. Auton price stability is by a CDP-based stabilization mechanism, the Auton Stabilization Mechanism (ASM); the stabilization target is the Auton Currency Unit (ACU), a base-invariant, volatility-minimized index.\n    Liquid staking for capital efficiency and a Penalty-Absorbing Stake model. Delegated Newton stake yields transferrable Liquid Newton tokens, which can be used to redeem the underlying Newton by unbonding stake. Self-bonded stake by validator operators does not yield Liquid Newton and is slashed before delegated stake to assure validator integrity and ‘skin in the game’.\n    Accountability and fault detection (AFD): a protocol for detecting infractions of consensus rules by validators participating in block proposal and voting as a committee member. Failure to adhere to these rules is a rule infraction and AFD will detect and apply slashing penalties for proven rule infractions.\n    Oracle network: a protocol for consensus-computed median price data for selected FX currency pairs as an L1 platform feature. The submission of price data for aggregation and voting is a validator responsibility; validator nodes form an oracle network."
  },
  {
    "objectID": "overview/index.html#technology",
    "href": "overview/index.html#technology",
    "title": "Overview",
    "section": "Technology",
    "text": "Technology\n    Core technology is the Autonity Go Client (AGC), a fork of the Go Ethereum ‘Geth’ client, and the Autonity Oracle Server (AOS). For the Geth base version of AGC see Reference, Codebase.\n    AGC is the reference implementation of the Autonity Protocol and provides the main client software run by participant peer nodes in an Autonity network system - see Running a Node. AOS is operated by validator nodes only - see Running a validator.\n    The Autonity client extends the underlying Ethereum protocol at application, blockchain, and communication layers to implement the key technical features and protocol governance logic.\n    For explanations of core concepts refer to:\n    \n    Architecture for an Autonity system’s technical architecture and protocol primitives.\n    System model for the functions of participant nodes and blockchain primitives comprising the structure of an Autonity system’s peer-to-peer network and distributed ledger.\n    Consensus for the protocol’s implementation of the Tendermint BFT consensus algorithm and consensus committee selection.\n    Autonity Go Client (AGC) for an overview of AGC features.\n    Oracle network for an overview of the oracle protocol for computing median price data for FX currency pairs.\n    Autonity Oracle Server (AOS) for an overview of AOS features.\n    Validator for the role of validators and the functions they perform in securing an Autonity network.\n    Staking for protocol staking mechanisms and Autonity’s model for liquid staking.\n    Accountability and fault detection (AFD) protocol for proving and applying economic slashing penalties to consensus committee members found guilty of Byzantine behavior.\n    Auton Stabilization Mechanism (ASM) for protocol mechanisms to stabilize Auton price in a CDP-based stabilization mechanism where Auton is borrowed in return for depositing collateral token.\n    Protocol assets for the protocol’s native coins and tokens: Auton utility coin, Newton stake token, and Liquid Newton liquid stake token.\n    The Glossary for definitions of terms and concepts used in the documentation."
  },
  {
    "objectID": "overview/index.html#system-actors",
    "href": "overview/index.html#system-actors",
    "title": "Overview",
    "section": "System actors",
    "text": "System actors\n    The actors of an Autonity network are:\n    \n    Account Holders: externally owned accounts of human users of the system. Account holders are the users interacting with an Autonity network: operating node and validation infrastructure, deploying and using decentralised applications, building and contributing to the community and ecosystem.\n    Node operators: network peer nodes running the AGC client software, forming the backbone of the networks p2p infrastructure and shared system ledger. Nodes store an up-to-date copy of the system state and may be run as public rpc endpoints providing open access to an Autonity network.\n    Validator node operators: network nodes running the AGC client and AOS oracle server software forming the validation infrastructure proposing and maintaining system state, and the oracle network for computing median price data. Active validator nodes are candidates for selection to the network’s consensus committee. The consensus committee is responsible for proposing and deciding on new blocks and computing oracle price data in voting rounds.\n    Stake delegators: account holders that have a Newton stake token balance and delegate stake to one or more validators in order to secure the network. Stake holders receive staking rewards for bonded stake."
  },
  {
    "objectID": "overview/index.html#key-concepts",
    "href": "overview/index.html#key-concepts",
    "title": "Overview",
    "section": "Key concepts",
    "text": "Key concepts\n    In addition to Ethereum concepts such as address, gas, and node, the distinction between participant and validator nodes is key in the Autonity context:\n    \n    \n    \n    Concept\n    Meaning\n    \n    \n    \n    \n    Auton (ATN)\n    Autonity’s native account coin (intrinsic balance of an account, like “Ether” in Ethereum) used to pay transaction fees.\n    \n    \n    Newton (NTN)\n    Native staking instrument used to secure the Proof-of-Stake consensus mechanism.\n    \n    \n    Liquid Newton (LNTN)\n    Native liquid token representing delegated Newton stake token bonded to a validator in an Autonity Network.\n    \n    \n    Participant node\n    A node running Autonity Go Client software and connected to other nodes in an Autonity network. A participant node maintains a copy of system state and may become a validator.\n    \n    \n    Validator node\n    A participant node that has registered as a validator on an Autonity network. A validator node may be selected to the consensus committee if it has sufficient stake bonded to it by a stake delegator. As a consensus committee member, validators are responsible for participating in proposing and agreeing new blocks and participating in the oracle network\n    \n    \n    Liquid Staking\n    Participants in the network can stake Newton to a specific validator to earn a fraction of the rewards granted for securing the network. In return for delegated staking, a validator issues Liquid Newton tokens to the staker, where these tokens represent a claim on the staked Newton. Liquid Newton tokens can be freely transferred between participants.\n    \n    \n    Penalty-Absorbing Stake\n    A stake slashing model whereby self-bonded stake is slashed before delegated stake when applying slashing penalties for accountability events. PAS incentivises honest validator behavior.\n    \n    \n    Consensus Committee\n    The subset of validator nodes that participate in the consensus protocol. The Consensus Committee is updated periodically (every epoch), according to an algorithm prescribed by protocol.\n    \n    \n    Oracle network\n    The network of validator-operated oracles that submits price data from off-chain external data providers on-chain and votes on agreeing an aggregated median price data according to an oracle protocol.\n    \n    \n    Accountability and fault detection (AFD)\n    A protocol for detecting infractions of consensus rules by validators participating in consensus as consensus committee members.\n    \n    \n    Auton Stabilization Mechanism (ASM)\n    The protocol mechanism used to maintain Auton price stability. The Stabilization Mechanism is CDP, Auton borrowed against Newton or Liquid Newton collateral.\n    \n    \n    \n    For all Autonity terminology and concepts see the Glossary."
  },
  {
    "objectID": "cdp/open-cdp/index.html",
    "href": "cdp/open-cdp/index.html",
    "title": "Open and manage a CDP",
    "section": "",
    "text": "To open a CDP and borrow ATN you need:\n    \n    An account that has been funded with:\n    \n    Auton: to pay for transaction gas costs\n    Newton: to deposit as collateral token in the CDP.\n    \n    Note that this account address will be also be used as the CDP identifier account address as well as the CDP Owner address used to open and service the CDP.\n    A running instance of aut configured to submit a transaction from your account.\n    \n    \n    \n    \n    \n    \n    \n    Protocol contract calls\n    \n    \n    \n    \n    \n    The guide uses the aut contract call and aut contract tx commands for contract interactions.\n    aut contract usage requires that you specify the ABI file and the protocol contract address of the contract being called. To complete the guide you will need to call 2 protocol contracts:\n    \n    the Autonity Protocol Contract (Autonity.abi) with the protocol contract address 0xBd770416a3345F91E4B34576cb804a576fa48EB1\n    the Stabilization Contract (Stabilization.abi) with the protocol contract address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f.\n    \n    The Autonity Protocol Contract Interfaces is called to approve the Stabilization Contract as a spender of the CDP Owner’s NTN token. The primary interface for CDP interactions is the Stabilization Contract Interface.\n    The abi files are generated when building the client from source and can be found in your autonity installation directory at ./params/generated/Autonity.abi and ./params/generated/Stabilization.abi. Alternatively, you can generate the ABI using the abigen cmd utility if you built the utility when building from source (See Install Autonity, Build from source code).\n    The guide explicitly sets the path to the ABI file and contract address to be clear which contract is being called. Note that the ABI file and contract address can be set as defaults in aut’s configuration file .autrc using the contract_address and contract_abi flags as appropriate:\n    #contract_abi = Autonity.abi\n#contract_address = 0xBd770416a3345F91E4B34576cb804a576fa48EB1\n    or\n    contract_abi = Stabilization.abi\ncontract_address = 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f\n\n    The guide assumes the ABI files are in the directory from which the aut command is run."
  },
  {
    "objectID": "cdp/open-cdp/index.html#prerequisites",
    "href": "cdp/open-cdp/index.html#prerequisites",
    "title": "Open and manage a CDP",
    "section": "",
    "text": "To open a CDP and borrow ATN you need:\n    \n    An account that has been funded with:\n    \n    Auton: to pay for transaction gas costs\n    Newton: to deposit as collateral token in the CDP.\n    \n    Note that this account address will be also be used as the CDP identifier account address as well as the CDP Owner address used to open and service the CDP.\n    A running instance of aut configured to submit a transaction from your account.\n    \n    \n    \n    \n    \n    \n    \n    Protocol contract calls\n    \n    \n    \n    \n    \n    The guide uses the aut contract call and aut contract tx commands for contract interactions.\n    aut contract usage requires that you specify the ABI file and the protocol contract address of the contract being called. To complete the guide you will need to call 2 protocol contracts:\n    \n    the Autonity Protocol Contract (Autonity.abi) with the protocol contract address 0xBd770416a3345F91E4B34576cb804a576fa48EB1\n    the Stabilization Contract (Stabilization.abi) with the protocol contract address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f.\n    \n    The Autonity Protocol Contract Interfaces is called to approve the Stabilization Contract as a spender of the CDP Owner’s NTN token. The primary interface for CDP interactions is the Stabilization Contract Interface.\n    The abi files are generated when building the client from source and can be found in your autonity installation directory at ./params/generated/Autonity.abi and ./params/generated/Stabilization.abi. Alternatively, you can generate the ABI using the abigen cmd utility if you built the utility when building from source (See Install Autonity, Build from source code).\n    The guide explicitly sets the path to the ABI file and contract address to be clear which contract is being called. Note that the ABI file and contract address can be set as defaults in aut’s configuration file .autrc using the contract_address and contract_abi flags as appropriate:\n    #contract_abi = Autonity.abi\n#contract_address = 0xBd770416a3345F91E4B34576cb804a576fa48EB1\n    or\n    contract_abi = Stabilization.abi\ncontract_address = 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f\n\n    The guide assumes the ABI files are in the directory from which the aut command is run."
  },
  {
    "objectID": "cdp/open-cdp/index.html#determine-borrowing-limit",
    "href": "cdp/open-cdp/index.html#determine-borrowing-limit",
    "title": "Open and manage a CDP",
    "section": "Determine borrowing limit",
    "text": "Determine borrowing limit\n    As prerequisite to opening a CDP, verify your borrowing limit. This is done based on:\n    \n    collateral price\n    amount of collateral to be deposited\n    amount of interest to pay on the borrowing\n    \n    \n    Step 1. Get collateral price\n    Query for current collateral price calling the collateralPrice() function of the Stabilization Contract using the aut contract call command:\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f collateralPrice\n    The current collateral price is returned denominated in ton, Autonity’s equivalent of wei. For example:\n    9990828200000000000\n    \n    \n    Step 2. Get borrowing ceiling\n    Next, determine your borrowing limits. There are two ways to do this:\n    \n    By Auton borrowing amount, to calculate the amount of collateral token that must be deposited to borrow a stated amount of Auton (ATN). Call minimumCollateral().\n    By collateral token amount, to calculate the amount of Auton that can be borrowed for a stated amount of collateral token (NTN). Call borrowLimit().\n    \n    \n    By amount of Auton to be borrowed\n    Determine how much collateral token (NTN) you will need to deposit for the amount of auton (ATN) you want to borrow.\n    Query for the minimum collateral amount by calling the minimumCollateral() function of the Stabilization Contract using the aut contract call command. Pass in parameters for:\n    \n    &lt;PRINCIPAL&gt; - the amount of ATN to borrow, specified in ton, Autonity’s equivalent of wei\n    &lt;PRICE&gt; - set to the collateral price returned in Step 1.\n    &lt;MCR&gt; - the minimum collateralization ratio set for the ASM at genesis. Set to 2000000000000000000 (i.e. 2). (For the default value set for mcr see Reference, Genesis, ASM stabilization config minCollateralizationRatio).\n    \n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f minimumCollateral &lt;PRINCIPAL&gt; &lt;PRICE&gt; &lt;MCR&gt;\n    In this example 1.75 ATN is set as the principal\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f minimumCollateral 1750000000000000000 9990828200000000000 2000000000000000000\n    Returning:\n    350321307696993528\n    At the given collateral price, 0.350321307696993528 NTN must be deposited to borrow 1.75 ATN.\n    \n    \n    By amount of Newton collateral token deposited\n    Determine the maximum amount of Auton (ATN) that can be borrowed for a given amount of collateral token (NTN).\n    Query for the borrowing limit by calling the borrowLimit() function of the Stabilization Contract using the aut contract call command. Pass in parameters for:\n    \n    &lt;COLLATERAL&gt; - the amount of collateral token deposited to back the debt\n    &lt;PRICE&gt; - the collateral token price. Set as for the preceding example.\n    &lt;TARGETPRICE&gt; - the ACU value of 1 unit of debt set for the ASM at genesis. Set to 1000000000000000000 (i.e. 1). (For the default value set for targetPrice see Reference, Genesis, ASM stabilization config minCollateralizationRatio).\n    &lt;MCR&gt; - the minimum collateralization ratio. Set as for the preceding example.\n    \n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f borrowLimit &lt;COLLATERAL&gt; &lt;PRICE&gt; &lt;TARGETPRICE&gt; &lt;MCR&gt;\n    In this example the 0.35... NTN value returned by the other method is set as the collateral token amount.\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f borrowLimit 350321307696993528 9990828200000000000 1000000000000000000 2000000000000000000\n    Returning:\n    1749999999999999997\n    At the given collateral price, 1.749999999999999997 ATN can be borrowed for deposited collateral token of 0.350321307696993528 NTN.\n    \n    \n    \n    Step 3. Calculate borrowing interest\n    Determine the interest that will charged on the borrowed Auton over time.\n    Query for the borrowing costs by calling the interestDue() function of the Stabilization Contract using the aut contract call command. Pass in parameters for:\n    \n    &lt;DEBT&gt;: the amount of Auton you want to borrow\n    &lt;RATE&gt;: the borrow interest rate. For the default value set for rate see Reference, Genesis, ASM stabilization config. Set to 5%, 50000000000000000\n    &lt;TIMEBORROW&gt;: the time point at which you will take out the borrowing. The timestamp is provided as a Unix time value\n    &lt;TIMEDUE&gt;: the time point at which you will repay the borrowing, to specify the time point at which the interest is due. The timestamp is provided as a Unix time value.\n    \n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f interestDue &lt;DEBT&gt; &lt;RATE&gt; &lt;TIMEBORROW&gt; &lt;TIMEDUE&gt;\n    In this example interest for borrowing 1.75 ATN over the calendar month of October is requested.\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f interestDue 1750000000000000000 50000000000000000 1696114800 1698710400\n    Returning:\n    7216608464428718\n    Borrowing interest costs over the 31 day period are 7216608464428718 ton, or 0.007216608464428718 ATN.\n    \n    \n    Step 4. Determine collateral requirements\n    Finally, for ongoing management of your CDP you need to maintain a sufficient collateral buffer to manage the risk of the CDP entering a liquidatable state. Factors that could lead to a CDP becoming liquidatable include collateral withdrawals, increased principal borrowing, accrued interest increasing the debt, or collateral-to-Auton price fluctuation.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If a debt position is under collateralized or not is determined by calculating (collateral * price) / debt. If this returns a value &lt; liquidationRatio, then the CDP is under collateralised and can be liquidated.\n    \n    \n    \n    To mitigate this risk you can run different collateralization, debt, and price scenarios to simulate liquidation risk and determine how much collateral you post for your borrowing.\n    To support this simulation you can use the underCollateralized() function of the Stabilization Contract. Use the aut contract call command to do this, passing in parameters:\n    \n    &lt;COLLATERAL&gt;: the amount of collateral backing the debt\n    &lt;PRICE&gt;: the price of the collateral in Auton. The actual price can be retrieved by calling collateralPrice(). For how to do this see Step 1. Get collateral price.\n    &lt;DEBT&gt;: the debt amount\n    &lt;LIQUIDATIONRATIO&gt;: the liquidation ratio set for the ASM at genesis. Set to 1800000000000000000 (i.e. 1.8). (For the default value set for liquidationRatio see Reference, Genesis, ASM stabilization config liquidationRatio).\n    \n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f underCollateralized &lt;COLLATERAL&gt; &lt;PRICE&gt; &lt;DEBT&gt; &lt;LIQUIDATIONRATIO&gt;\n    In this example, values for borrowing 1.75 ATN per other Steps in this example are used for the parameterisation:\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f underCollateralized 350321307696993528 9990828200000000000 1750000000000000000 1800000000000000000\n    Returning:\n    false\n    If the borrowing amount is increased from 1.75 to 1.95 ATN, then the position becomes under collateralized:\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f underCollateralized 350321307696993528 9990828200000000000 1950000000000000000 1800000000000000000\n    Returning:\n    true\n    However, if collateral is increased from 350321307696993528 to 352000000000000000, then the position is no longer under collateralized:\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f underCollateralized 352000000000000000 9990828200000000000 1950000000000000000 1800000000000000000\n    Returning:\n    false"
  },
  {
    "objectID": "cdp/open-cdp/index.html#approve-the-stabilization-contract-as-a-collateral-token-spender",
    "href": "cdp/open-cdp/index.html#approve-the-stabilization-contract-as-a-collateral-token-spender",
    "title": "Open and manage a CDP",
    "section": "Approve the Stabilization Contract as a collateral token spender",
    "text": "Approve the Stabilization Contract as a collateral token spender\n    Before depositing collateral token to open a cdp, the collateral token contract must be called to approve the Stabilization Contract as a spender of collateral token using the standard ERC-20 “approve” method.\n    \n    \n    Step 1. Verify your collateral token balance\n    (Optional.) Verify you have the necessary NTN balance for the desired borrowing:\n    aut account balance --ntn\n    The amount approved in Step 2 must be &lt;= to your NTN balance, otherwise the transaction will revert.\n    \n    \n    Step 2. Approve the Stabilization Contract\n    Approve the Stabilization Contract as a spender of collateral token. Call the Autonity Protocol Contract approve() function, using the aut contract tx command. Pass in parameters for:\n    \n    &lt;SPENDER&gt; is the Stabilization Contract address\n    &lt;AMOUNT&gt; is the amount of NTN that you are allowing the contract to spend on your behalf.\n    \n    aut contract tx --abi Autonity.abi --address 0xBd770416a3345F91E4B34576cb804a576fa48EB1 approve  &lt;SPENDER&gt; &lt;AMOUNT&gt;\n    In this example, approval is given for 0.75 NTN:\n    aut contract tx --abi Autonity.abi --address 0xBd770416a3345F91E4B34576cb804a576fa48EB1 approve  0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f 750000000000000000 | aut tx sign - | aut tx send -\n    Optionally, verify the Stabilization Contract approval has succeeded by calling the Autonity Protocol Contract allowance() function, using the aut contract call command. Pass in parameters for:\n    \n    &lt;OWNER&gt; is your account address\n    &lt;SPENDER&gt; is the Stabilization Contract address.\n    \n    aut contract call --abi Autonity.abi --address 0xBd770416a3345F91E4B34576cb804a576fa48EB1 allowance &lt;OWNER&gt; &lt;SPENDER&gt;\n    For example:\n    aut contract call --abi Autonity.abi --address 0xBd770416a3345F91E4B34576cb804a576fa48EB1 allowance 0xF47FDD88C8f6F80239E177386cC5AE3d6BCdEeEa 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f\n750000000000000000"
  },
  {
    "objectID": "cdp/open-cdp/index.html#open-a-cdp",
    "href": "cdp/open-cdp/index.html#open-a-cdp",
    "title": "Open and manage a CDP",
    "section": "Open a CDP",
    "text": "Open a CDP\n    It is only possible to have one CDP open at a time. This prevents users opening multiple CDP’s to borrow Auton without maintaining collateralization ratios.\n    Open a CDP by depositing collateral token. Auton can then be borrowed against that collateral, creating the debt position. The debt of a CDP is then composed of:\n    \n    principal: the amount of ATN borrowed, which must be above a minimum debt requirement\n    accrued interest: the borrowing interest rate charged to the debt, continuously compounding.\n    \n    (For the default values set for borrowInterestRate and minDebtRequirement see Reference, Genesis, ASM stabilization config)."
  },
  {
    "objectID": "cdp/open-cdp/index.html#deposit-collateral-token",
    "href": "cdp/open-cdp/index.html#deposit-collateral-token",
    "title": "Open and manage a CDP",
    "section": "Deposit collateral token",
    "text": "Deposit collateral token\n    Deposit collateral token (NTN) by submitting a transaction to the deposit() function of the Stabilization Contract using the aut contract tx command. Pass in parameters for:\n    \n    &lt;AMOUNT&gt; - the amount of collateral token to deposit.\n    \n    aut contract tx --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f deposit &lt;AMOUNT&gt; | aut tx sign - | aut tx send -\n    In this example 0.75 NTN is deposited:\n    aut contract tx --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f deposit 750000000000000000 | aut tx sign - | aut tx send -\n    Optionally, verify the deposit has succeeded and the CDP opened by calling the Stabilization Contract accounts() function to return an array of open CDP’s. The account address you used to submit the transaction will be included in the array of CDP identifier addresses returned.\n    For example:\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f accounts\n[\"0x1f790c60D974F5A8f88558CA90F743a71F009641\", \"0xfd1ac0e99E9BD153F49080A96eb44843211E5C9f\", \"0xF47FDD88C8f6F80239E177386cC5AE3d6BCdEeEa\"]"
  },
  {
    "objectID": "cdp/open-cdp/index.html#borrow-against-collateral",
    "href": "cdp/open-cdp/index.html#borrow-against-collateral",
    "title": "Open and manage a CDP",
    "section": "Borrow against collateral",
    "text": "Borrow against collateral\n    Borrow Auton against deposited CDP collateral by submitting a transaction to the borrow() function of the Stabilization Contract using the aut contract tx command. Pass in parameters for:\n    \n    &lt;AMOUNT&gt; - the amount of Auton to borrow.\n    \n    aut contract tx --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f borrow &lt;AMOUNT&gt; | aut tx sign - | aut tx send -\n    The borrowed Auton will be transferred to your account. To view your new ATN account balance run aut account balance.\n    In this example 1.75 ATN is borrowed as the principal:\n    aut contract tx --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f borrow 1750000000000000000 | aut tx sign - | aut tx send -"
  },
  {
    "objectID": "cdp/open-cdp/index.html#manage-your-cdp",
    "href": "cdp/open-cdp/index.html#manage-your-cdp",
    "title": "Open and manage a CDP",
    "section": "Manage your CDP",
    "text": "Manage your CDP\n    \n    Get current CDP debt amount\n    The debt of a CDP consists of the Auton borrowed (the ‘principal’) and accrued interest due charged at the borrow interest rate.\n    To determine the current debt owed on a CDP call debtAmount()function of the Stabilization Contract using the aut contract call command.\n    \n    Call debtAmount() passing in parameters for:\n    \n    \n    &lt;ACCOUNT&gt;: the CDP account address\n    &lt;TIMESTAMP&gt;: the timestamp at which you want to value the debt. The timestamp is provided as a Unix time value.\n    \n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f debtAmount &lt;ACCOUNT&gt; &lt;TIMESTAMP&gt;\n    The call will return the total amount owed on the CDP, debt + accrued interest. The result is returned as an integer value in ton, Autonity’s equivalent of Ethereum’s wei.\n    In this example the debt amount is returned as 1.75... ATN at time point October 17 2023 14:16:37 GMT:\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f debtAmount 0xF47FDD88C8f6F80239E177386cC5AE3d6BCdEeEa 1697552197\n1750217362321414404\n    \n    \n    Repay borrowing\n    Repay an amount of borrowed Auton by submitting a transaction to the repay() function of the Stabilization Contract using the aut contract tx command. Pass in parameters for:\n    \n    &lt;AMOUNT&gt; - the amount of Auton to repay to the CDP.\n    \n    aut contract tx --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f --value &lt;AMOUNT&gt; repay | aut tx sign - | aut tx send -\n    In this example 0.25 ATN is repaid to reduce the principal:\n    aut contract tx --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f --value 250000000000000000 repay | aut tx sign - | aut tx send -\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    A repayment can be a partial or full repayment of the borrowed amount.\n    If you want to repay all borrowed ATN in a CDP and clear the debt position completely, then slightly overpay - this covers accrued interest and the protocol will return any surplus payment to your account immediately.\n    For example, you are repaying the entire debt and call interestDue() and debtAmount() to determine the amount owed. You then make a repayment for that exact amount. In the time interval before the repay() transaction is submitted a dust amount of interest can then accrue. In this scenario, overpayment will settle that interest due and surplus ATN from the repayment is returned.\n    \n    \n    \n    \n    \n    Withdraw collateral\n    Withdraw an amount of deposited collateral token by submitting a transaction to the withdraw() function of the Stabilization Contract using the aut contract tx command. Pass in parameters for:\n    \n    &lt;AMOUNT&gt; - the amount of Auton to repay to the CDP.\n    \n    aut contract tx --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f withdraw &lt;AMOUNT&gt; | aut tx sign - | aut tx send -\n    In this example 0.1 NTN collateral token is withdrawn to reduce the deposited collateral amount:\n    aut contract tx --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f withdraw 100000000000000000 | aut tx sign - | aut tx send -"
  },
  {
    "objectID": "cdp/liquidate-cdp/index.html",
    "href": "cdp/liquidate-cdp/index.html",
    "title": "Liquidate a CDP",
    "section": "",
    "text": "An account that has been funded with Auton (to pay for transaction gas costs)\n    A running instance of aut configured to submit a transaction from your account.\n    \n    \n    \n    \n    \n    \n    \n    Protocol contract calls\n    \n    \n    \n    \n    \n    The guide uses the aut contract call and aut contract tx commands for contract interactions.\n    aut contract usage requires that you specify the ABI file and the protocol contract address of the contract being called. To complete the guide you will need to call the Stabilization Contract (Stabilization.abi) with the protocol contract address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f.\n    The abi files are generated when building the client from source and can be found in your autonity installation directory at ./params/generated/Autonity.abi and ./params/generated/Stabilization.abi. Alternatively, you can generate the ABI using the abigen cmd utility if you built the utility when building from source (See Install Autonity, Build from source code).\n    The guide explicitly sets the path to the ABI file and contract address to be clear the Stabilization Contract is being called. Note that the ABI file and contract address can be set as defaults in aut’s configuration file .autrc using the contract_address and contract_abi flags:\n    contract_abi = Stabilization.abi\ncontract_address = 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f\n\n    The guide assumes the ABI files are in the directory from which the aut command is run."
  },
  {
    "objectID": "cdp/liquidate-cdp/index.html#prerequisites",
    "href": "cdp/liquidate-cdp/index.html#prerequisites",
    "title": "Liquidate a CDP",
    "section": "",
    "text": "An account that has been funded with Auton (to pay for transaction gas costs)\n    A running instance of aut configured to submit a transaction from your account.\n    \n    \n    \n    \n    \n    \n    \n    Protocol contract calls\n    \n    \n    \n    \n    \n    The guide uses the aut contract call and aut contract tx commands for contract interactions.\n    aut contract usage requires that you specify the ABI file and the protocol contract address of the contract being called. To complete the guide you will need to call the Stabilization Contract (Stabilization.abi) with the protocol contract address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f.\n    The abi files are generated when building the client from source and can be found in your autonity installation directory at ./params/generated/Autonity.abi and ./params/generated/Stabilization.abi. Alternatively, you can generate the ABI using the abigen cmd utility if you built the utility when building from source (See Install Autonity, Build from source code).\n    The guide explicitly sets the path to the ABI file and contract address to be clear the Stabilization Contract is being called. Note that the ABI file and contract address can be set as defaults in aut’s configuration file .autrc using the contract_address and contract_abi flags:\n    contract_abi = Stabilization.abi\ncontract_address = 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f\n\n    The guide assumes the ABI files are in the directory from which the aut command is run."
  },
  {
    "objectID": "cdp/liquidate-cdp/index.html#discover-if-a-cdp-is-liquidatable",
    "href": "cdp/liquidate-cdp/index.html#discover-if-a-cdp-is-liquidatable",
    "title": "Liquidate a CDP",
    "section": "Discover if a CDP is liquidatable",
    "text": "Discover if a CDP is liquidatable\n    \n    get the CDP’s accounts()\n    call isLiquidatable()\n    call underCollateralized()\n    can you call other functions to forecast if it will be liquidatable or under collateralised based on interest due/accruing, or?\n    \n    e.g. if the collateralPrice falls etc\n    i.e. liquidationRatio\n    i.e. collateralizationRatio\n    \n    \n    \n    Step 1. Get CDP accounts\n    Query for open CDPs by calling the accounts() function of the Stabilization Contract using the aut contract call command:\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f accounts\n    An array of open CDPs is returned. For example:\n    [\"0x1f790c60D974F5A8f88558CA90F743a71F009641\", \"0xfd1ac0e99E9BD153F49080A96eb44843211E5C9f\", \"0xF47FDD88C8f6F80239E177386cC5AE3d6BCdEeEa\"]\n    \n    \n    Step 2. Determine if a CDP is liquidatable\n    Determine if a CDP is liquidatable by calling the isLiquidatable() function of the Stabilization Contract using the aut contract call command. Pass in parameter:\n    \n    &lt;ACCOUNT&gt;: the CDP account address\n    \n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f isLiquidatable &lt;ACCOUNT&gt;\n    The call will return a boolean value indicating if the CDP is liquidatable or not.\n    For example, using the results returned from Step 1:\n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f isLiquidatable 0xF47FDD88C8f6F80239E177386cC5AE3d6BCdEeEa\n    false is returned for 0x1f790c60D974F5A8f88558CA90F743a71F009641 - the CDP is not liquidatable.\n    \n    \n    Step 3. Get CDP economic state\n    Next, inspect CDP state to understand the economic costs and returns of liquidation - i.e. cost of repaying the debt (principal, accrued interest) and the collateral token that will be transferred to the position’s liquidator.\n    There are two steps to do this:\n    \n    Get CDP debt amount, to calculate the current outstanding debt amount of Auton that must be repaid to liquidate the CDP.\n    Get CDP collateral amount, to return the amount of collateral token deposited to the CDP.\n    \n    \n    Get CDP collateral amount\n    As described in the Concept page for ASM Stabilization section, for each CDP, the Stabilization Contract records:\n    \n    timestamp: the timestamp of the last borrow or repayment\n    collateral: the collateral deposited with the Stabilization Contract\n    principal: the principal debt outstanding as of timestamp.\n    interest: the interest debt that is due at the timestamp.\n    \n    \n    \n    \n    \n    \n    \n    Warning\n    \n    \n    \n    \n    \n    The important data point is the collateral amount value as this gives you the economic benefit of liquidating the CDP.\n    The other data should be ignored. The timestamp reflects the time point that the CDP was last borrowed from or repaid to so the principal and interest data is out of date. To get the current CDP debt amount due you will need to call debtAmount(), which is done in the next step Get CDP debt amount.\n    \n    \n    \n    CDP state is maintained in memory as a public mapping cdps and may be inspected by calling the getter function automatically generated for it when the Stabilization Contract is compiled.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The cdps getter function definition can be found in the Stabilization.abi file by searching for \"name\": \"cdps\".\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The cdps function cannot currently be called from aut using the aut contract call command. This is a known issue logged as an autonity.py GitHub issue AssertionError on returning tuple #37.\n    \n    \n    \n    The auto-generated cdps method can be called to return the CDP data, simply passing in the CDP account address as the parameter.\n    This can be done using a simple web3.py script using the web3.eth.contract module to call the cdps function. Where:\n    \n    &lt;RPC_ENDPOINT&gt;: is the HTTP address for the node endpoint being called\n    &lt;ACCOUNT&gt;: is the CDP account address identifier.\n    \n    \nfrom web3 import Web3, HTTPProvider\nimport json\n\nwith open(\"Stabilization.abi\") as f:\n    abi = info_json = json.load(f)\n\n\nw3 = Web3(HTTPProvider('&lt;RPC_ENDPOINT&gt;'))\n\nstabilizationContractAddress = \"0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f\"\ncontract_instance = w3.eth.contract(address=stabilizationContractAddress, abi=abi)\n\n# read state: call the cdps function passing in the CDP identifier address &lt;ACCOUNT&gt;:\n\nprint(contract_instance.functions.cdps(\"&lt;ACCOUNT&gt;\").call())\n    For example, for the CDP account 0x1f790c60D974F5A8f88558CA90F743a71F009641 it returns:\n    % python3 aut_cdps.py\n[1695737259, 410000024269118276, 300010815663118114, 0]\n    \n    \n    Get CDP debt amount\n    The debt of a CDP consists of the Auton borrowed (the ‘principal’) and accrued interest due charged at the borrow interest rate.\n    To get the current debt owed on a CDP and so the cost of liquidating the CDP, call debtAmount()function of the Stabilization Contract using the aut contract call command. Pass in parameters for:\n    \n    &lt;ACCOUNT&gt;: the CDP account address\n    &lt;TIMESTAMP&gt;: the timestamp at which you want to value the debt. The timestamp is provided as a Unix time value.\n    \n    aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f debtAmount &lt;ACCOUNT&gt; &lt;TIMESTAMP&gt;\n    The call will return the total amount owed on the CDP, debt + accrued interest. The result is returned as an integer value in ton, Autonity’s equivalent of Ethereum’s wei.\n    In this example the debt amount for CDP 0x1f790c60D974F5A8f88558CA90F743a71F009641 is returned as 0.3008... ATN at time point October 17 2023 14:16:37 GMT:\n    ubuntu@vps-c7c3e8c7:~/TEST/autcli$ aut contract call --abi Stabilization.abi --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f debtAmount 0x1f790c60D974F5A8f88558CA90F743a71F009641 1697552197\n    Returning:\n    300875359676920667"
  },
  {
    "objectID": "cdp/liquidate-cdp/index.html#liquidate-a-cdp",
    "href": "cdp/liquidate-cdp/index.html#liquidate-a-cdp",
    "title": "Liquidate a CDP",
    "section": "Liquidate a CDP",
    "text": "Liquidate a CDP\n    To liquidate a CDP in a liquidatable state submit a liquidate transaction to the liquidate() function of the Stabilization Contract using the aut contract call command. Pass in parameter:\n    \n    &lt;ACCOUNT&gt;: the CDP account address to liquidate\n    &lt;AMOUNT&gt;: the payment amount, sufficient to repay the outstanding debt of the CDP\n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f --value &lt;AMOUNT&gt; liquidate &lt;ACCOUNT&gt;\n    The transaction will revert if the CDP is not liquidatable or the payment is insufficient to repay the debt.\n    On success, the CDP’s collateral token and any surplus Auton remaining from the payment are transferred to your account."
  },
  {
    "objectID": "cdp/index.html",
    "href": "cdp/index.html",
    "title": "Borrowing by CDP in the ASM",
    "section": "",
    "text": "The steps here describe interactions with the CDP-based Auton Stabilization Mechanism (ASM) for:\n    \n    CDP owners to open and manage a CDP to borrow Auton having deposited collateral token\n    CDP liquidators to identify and liquidate a CDP in a liquidatable state.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    See the Auton Stabilization Mechanism (ASM) section for an explanation of the ASM concept and how the mechanism functions."
  },
  {
    "objectID": "oracle/run-oracle/index.html",
    "href": "oracle/run-oracle/index.html",
    "title": "Run Autonity Oracle Server",
    "section": "",
    "text": "Prerequisites\n    \n    \n    \n    \n    \n    \n    Ensure that the host machine meets the minimum requirements\n    A running instance of an Autonity Go Client running on your host machine, with networking configured to allow incoming traffic on its WebSocket port. This will be registered as a validator node and oracle server will be configured to connect to it.\n    A configured instance of aut.\n    Auton (ATN) to seed-fund your oracle server account.\nTo run Autonity Oracle Server you will need to generate a keyfile for your oracle server account and seed-fund it, configure plugin(s) for external data sources, set the oracle server configuration, and connect to your Autonity Go Client node. Autonity Oracle Server will initialise, connect to the data sources and node, and then begin to submit price reports to your connected node."
  },
  {
    "objectID": "oracle/run-oracle/index.html#create-oracle-server-account",
    "href": "oracle/run-oracle/index.html#create-oracle-server-account",
    "title": "Run Autonity Oracle Server",
    "section": "Create oracle server account",
    "text": "Create oracle server account\n    Begin by creating an account that will be used as the cryptographic identity of the oracle server. Note that the account’s:\n    \n    private key is used as the oracle server key to sign price report transactions submitted to the Oracle Contract on-chain\n    address is used as the oracle identifier, the unique identifier of the oracle server.\n    \n    Transaction costs for submitting price report data on-chain are refunded but the account needs to be pre-funded to prevent an out of gas error on the first transaction submitted by the server.\n    \n    Generate a key file for the oracle server. Use aut to create an account for the oracle. Make a note of your oracle account address as this will be required when registering your validator.\n    Pre-fund the oracle server account. See Fund account."
  },
  {
    "objectID": "oracle/run-oracle/index.html#run-binary",
    "href": "oracle/run-oracle/index.html#run-binary",
    "title": "Run Autonity Oracle Server",
    "section": "Run Autonity Oracle Server (binary or source code install)",
    "text": "Run Autonity Oracle Server (binary or source code install)\n    \n    Ensure that the Autonity Oracle Server has been installed from a pre-compiled binary or from source code\n    \n    \n    Enter your working directory for the oracle server.\n    Configure the data plugins. Edit your oracle server data plugins config file plugins-conf.yml to specify the plugins configuration. The file can be found in the /autonity-oracle/config sub-directory. Edit plugins-conf.yml to specify the name and key for each plugins you are using. For how to do this see the Set up plugins config file section on this page.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    A sample plugins-conf.yml config file can be downloaded from the Autonity Oracle Server GitHub.\n    \n    \n    \n    (Optional) Add your own data source plugin(s). If you have developed your own FX plugins, (a) add sub-directory(ies) containing the plugin source code to the plugins sub-directory of your installation; (b) add config entry(ies) to the plugins-conf.yml file.\n    Configure the oracle server. Edit your oracle server config file oracle-server.config to specify the oracle server configuration. The file can be found in the /autonity-oracle/config sub-directory. For how to do this see the Set up oracle server config file section on this page.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    A sample oracle-server.config file can be downloaded from the Autonity Oracle Server GitHub.\n    \n    \n    \n    Start oracle server:\n    ./autoracle --config=\"./oracle-server.config\"\n    Oracle server will connect to external data sources using the providers set in the plugins configuration and begin submitting price reports to the connected node.\n    On running oracle server you should see something like:\n    2024/02/10 17:44:48 \n\n   Running autonity oracle server v0.1.6\n   with plugin directory: ./build/bin/plugins\n   by connecting to L1 node: ws://127.0.0.1:8546\n   on oracle contract address: 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The oracle server configuration can also be set as system environment variables or directly in the terminal as console flags. For how to do this see the page section Setup using command line flags or system env variables.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    New or updated plugins are configured by simply adding the binary code to the configured plugins directory (plugin.dir). See Installing data source plugins for more detail.\n    If plugins for external data sources or the symbols for which oracle server provides price data are changed while oracle server is running, changes are auto-detected and applied. Oracle server does not need to be re-started."
  },
  {
    "objectID": "oracle/run-oracle/index.html#run-docker",
    "href": "oracle/run-oracle/index.html#run-docker",
    "title": "Run Autonity Oracle Server",
    "section": "Run Autonity Oracle Server as Docker image",
    "text": "Run Autonity Oracle Server as Docker image\n    \n    Ensure that the Autonity Oracle Server Docker image has been installed.\n    \n    \n    Enter your working directory for autonity oracle server.\n    Configure the data plugins. Create and edit your oracle server data plugins config file plugins-conf.yml to specify the name and key for each plugins you are using.\n    touch plugins-conf.yml\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    A sample plugins-conf.yml config file can be downloaded from the Autonity Oracle Server GitHub.\n    \n    \n    \n    Edit plugins-conf.yml to configure plugins for data sources. See Set up plugins config file for how to do this.\n    Configure the oracle server. Create and edit your oracle server config file oracle-server.config to specify the oracle server configuration.\n    touch oracle-server.config\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    A sample oracle-server.config file can be downloaded from the Autonity Oracle Server GitHub.\n    \n    \n    \n    Edit oracle-server.config to specify the oracle server configuration. See Set up oracle server config file for how to do this.\n    Set the Docker configuration and the arguments for running Autonity Oracle Server and connecting to the Autonity Go Client it is serving.\n    docker run \\\n     -t -i \\\n     --volume $&lt;ORACLE_KEYFILE&gt;:/autoracle/oracle.key \\\n     --volume $&lt;PLUGINS_CONF_FILE&gt;:/autoracle/plugins-conf.yml \\\n     --volume $&lt;ORACLE_SERVER_CONF_FILE&gt;:/autoracle/plugins-conf.yml \\\n     --name &lt;ORACLE_CONTAINER_NAME&gt; \\\n     --rm \\\n     &lt;DOCKER_IMAGE&gt;:latest \\\n     ;\n    where:\n    \n    &lt;ORACLE_KEYFILE&gt; specifies the path to your oracle server key file. E.g. ../aut/keystore/oracle.key\n    &lt;PLUGINS_CONF_FILE&gt; is the path to the data plugins configuration file plugins-conf.yml. E.g. ./plugins-conf.yml.\n    &lt;ORACLE_SERVER_CONF_FILE&gt; is the path to the oracle server configuration file oracle-server.config. E.g. ./oracle-server.config.\n    &lt;ORACLE_CONTAINER_NAME&gt; is the name you are specifying for the container, i.e. oracle-server-bakerloo or oracle-server-piccadilly\n    &lt;DOCKER_IMAGE&gt; is the Docker image name, i.e. ghcr.io/autonity/autonity-oracle-bakerloo or ghcr.io/autonity/autonity-oracle-piccadilly.\n    \n    See the Autonity Oracle Server command-line reference for the full set of available flags.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    AOS requires an accessible ws/wss AGC endpoint. If you are also running AGC in docker and facing issues in connecting AOS to it, please execute the following command to correctly identify the IP address required for the &lt;WS_ADDRESS&gt;: docker inspect -f '{{.NetworkSettings.IPAddress}}' &lt;container_id_or_name&gt;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    \n    The command above creates a temporary container, which is deleted (via the --rm flag) when the node is shut down.\n    The --volume flags are needed to mount the key and config files. The plugins are pre-built and included in the Docker container at the path /usr/local/bin/plugins/.\n    \n    \n    \n    \n    Naturally, the above command line can be tailored to suit a specific deployment. See the docker documentation for the complete list of Docker options.\n    Start oracle server. On running the Docker you should see something like:\n     2023/09/26 10:04:53 \n\n     Running autonity oracle server v0.1.2\n     with symbols: AUD-USD,CAD-USD,EUR-USD,GBP-USD,JPY-USD,SEK-USD,ATN-USD,NTN-USD,NTN-ATN\n     and plugin directory: ./build/bin/plugins/\n     by connecting to L1 node: ws://127.0.0.1:8546\n     on oracle contract address: 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D \n    Oracle server will connect to external data sources using the providers set in the plugin. configuration properties and begin submitting price reports to the connected node."
  },
  {
    "objectID": "oracle/run-oracle/index.html#configure-oracle-server",
    "href": "oracle/run-oracle/index.html#configure-oracle-server",
    "title": "Run Autonity Oracle Server",
    "section": "Configure oracle server",
    "text": "Configure oracle server\n    The runtime configuration of oracle server can be specified using a configuration file, command line flags, or system environment variables. Using the configuration file oracle-server.config is the preferred default path.\n    \n    Set up oracle server config file\n    The oracle server config file oracle-server.config can be found in the /autonity-oracle/config sub-directory. Edit the file to set the config values where:\n    \n    tip: sets a gas priority fee cap for your oracle server data report transactions.\n    key.file: is the path to your oracle server key file, e.g. ../aut/keystore/oracle.key\n    key.password: is the password to your oracle server key file\n    log.level: sets the logging level. Values are: 0: No logging, 1: Trace, 2:Debug, 3: Info, 4: Warn, 5: Error.\n    ws: is the WebSocket IP Address of your connected Autonity Go Client node (see install Autonity, networks\n    plugin.dir is the path to the directory containing the built data plugins.\n    plugin.conf is the path to the plugins YAML configuration file plugins-conf.yml (defaults to ./plugins-conf.yml).\n    \n    An example configuration could be:\n    tip 1\nkey.file ./UTC--2023-02-27T09-10-19.592765887Z--b749d3d83376276ab4ddef2d9300fb5&gt;\nkey.password 123%&%^$\nlog.level 3\nws ws://127.0.0.1:8546\nplugin.dir ./build/binplugins\nplugin.conf ./config/plugins-conf.yml\n    \n    \n    Setup using command line flags or system env variables\n    The oracle server configuration can also be set directly in the terminal as console flags or as system environment variables.\n    For example, to start oracle server specifying command line flags when running the binary, simply specify the config as flags:\n    ./autoracle \\\n     --tip=\"1\" \\\n     --key.file=\"../../test_data/keystore/UTC--2023-02-27T09-10-19.592765887Z--b749d3d83376276ab4ddef2d9300fb5ce70ebafe\" \\\n     --key.password=\"123\" \\\n     --ws=\"ws://127.0.0.1:8546\" \\\n     --plugin.dir=\"./plugins\" \\\n     --plugin.conf=\"./plugins-conf.yml\" \\\n     ;\n    For example, to start oracle server specifying command line flags when running the Docker image, specify the Docker configuration and oracle server config as flags:\n    docker run \\\n     -t -i \\\n     --volume $&lt;ORACLE_KEYFILE&gt;:/autoracle/oracle.key \\\n     --volume $&lt;PLUGINS_CONF_FILE&gt;:/autoracle/plugins-conf.yml \\\n     --name &lt;ORACLE_CONTAINER_NAME&gt; \\\n     --rm \\\n     &lt;DOCKER_IMAGE&gt;:latest \\\n     -tip=\"&lt;TIP&gt;\" \\\n     -key.file=\"/autoracle/oracle.key\" \\\n     -key.password=\"&lt;PWD&gt;\" \\\n     -ws=\"&lt;WS_ADDRESS&gt;\" \\\n     -plugin.dir=\"/usr/local/bin/plugins/\" \\\n     -plugin.conf=\"/autoracle/plugins-conf.yml\"\n    where:\n    \n    &lt;ORACLE_KEYFILE&gt; specifies the path to your oracle server key file. E.g. ../aut/keystore/oracle.key\n    &lt;PLUGINS_CONF_FILE&gt; is the path to the data plugins configuration file plugins-conf.yml. E.g. ./plugins-conf.yml.\n    &lt;ORACLE_CONTAINER_NAME&gt; is the name you are specifying for the container, i.e. oracle-server-bakerloo or oracle-server-piccadilly\n    &lt;DOCKER_IMAGE&gt; is the Docker image name, i.e. ghcr.io/autonity/autonity-oracle-bakerloo or ghcr.io/autonity/autonity-oracle-piccadilly\n    &lt;TIP&gt; sets a gas priority fee cap for your oracle server data report transactions, e.g. 1.\n    &lt;PWD&gt; is the password to your oracle server key file\n    &lt;WS_ADDRESS&gt; is the WebSocket IP Address of your connected Autonity Go Client node, e.g. “ws://172.17.0.2:8546”, see install Autonity, networks).\n    \n    ::: {.callout-note title=“Note” collapse=“false”} - Note that all flags after the image name are passed to the Autonity Oracle Server in the container, and thus follow the same pattern as for running a binary or source install - The command above creates a temporary container, which is deleted (via the --rm flag) when the node is shut down. - The --volume flags are needed to mount the key and config files. The plugins are pre-built and included in the Docker container at the path /usr/local/bin/plugins/. :::\n    See the Autonity Oracle Server command-line reference or the oracle server’s GitHub repo README, Configuration of oracle server section CLI flags for the full set of available flags.\n    For how to set the flags as system environment variables see the README section System Environment Variables."
  },
  {
    "objectID": "oracle/run-oracle/index.html#configure-data-source-plugins",
    "href": "oracle/run-oracle/index.html#configure-data-source-plugins",
    "title": "Run Autonity Oracle Server",
    "section": "Configure data source plugins",
    "text": "Configure data source plugins\n    The oracle server will need to provide FX, ATN and NTN currency pairs utilised in the Auton Stabilization Mechanism.\n    A basic set of data adaptor plugins for sourcing this data is provided out the box with oracle server for testnet pre-Mainnet in the autonity-oracle GitHub repo /plugins directory:\n    \n    Forex plugins: for connecting to public FX data sources. See the forex_ prefixed adaptors. Four forex plugins are currently provided.\n    Simulator plugin: for simulated ATN/NTN data. See the sim_plugin adaptor.\n    \n    \n    Set up plugins config file\n    To configure FX data source plugins edit the plugins_conf.yml file to add a config entry for each plugin. The oracle server release contains out-the-box plugins for four publicly accessible FX endpoints with free and paid subscriptions tiers. You will need to create an account and get an API Key to connect. One or more plugin source must be configured.\n    Navigate to the public GitHub repo [autonity-oracle] (https://github.com/autonity/autonity-oracle) README.md Configuration section to view the supported FX endpoint providers.\n    For each FX endpoint configured:\n    \n    Get FX plugin API Key(s). Navigate to one of the listed FX endpoint websites and create an account. Make a note of the API Key.\n    Add configuration entry to plugins-conf.yml. Edit the file to add an entry for each plugin you are configuring.\n    \n    Configuration fields:\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Name\n    Datatype\n    Mandatory?\n    Description\n    \n    \n    \n    \n    name\n    string\n    required\n    the name of the plugin binary; use the name of the sub-directory in the plugins directory\n    \n    \n    key\n    string\n    required\n    the API key granted by your data provider to access their data API\n    \n    \n    scheme\n    string\n    optional\n    the data service http scheme, http or https. Default value is https.\n    \n    \n    endpoint\n    string\n    optional\n    the data service endpoint url of the data provider\n    \n    \n    timeout\n    int\n    optional\n    the duration of the timeout period for an API request in seconds. Default value is 10.\n    \n    \n    refresh\n    int\n    optional\n    the data update interval in seconds. Used for a rate limited provider’s plugin to limit the request rate. Default value is 30.\n    \n    \n    \n    An example minimal entry could be:\n    - name: forex_currencyfreaks\n  key: 5490e15565e741129788f6100e022ec5\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The optional fields should be set as needed to fit the service level agreed with your rate provider.\n    \n    \n    \n    \n    \n    ATN and NTN data simulator plugin\n    If you are connecting to Bakerloo testnet an ATN and NTN Simulator is deployed and available to provide simulated data for testnet use.\n    To connect to this simulator as a data source, you need to edit your plugins-conf.yml config file to point to the Bakerloo ATN and NTN data simulator. Just add an entry for the Bakerloo simulator data source:\n    - name: sim_plugin\n  endpoint: simfeed.bakerloo.autonity.org\n  scheme: https\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The sim_plugin is built and added to the plugins directory when building from source running the make autoracle-bakerloo command.\n    When running make on oracle server the simulator plugin is also built to a test directory. So if you didn’t run the Bakerloo-specific make command you can still get the plugin by just copying the file to the plugins directory:\n    cp e2e_test/plugins/simulator_plugins/sim_plugin build/bin/plugins/sim_plugin\n    The simulator can also be built independently by running the make simulator command.\n    \n    \n    \n    \n    \n    Develop plugins\n    Additional data adaptors for any external data source can be developed using the oracle server’s plugin template. See:\n    \n    Adaptor code template template_plugin in /plugins.\n    Guide for how To write a new plugin using the template in /plugins/README."
  },
  {
    "objectID": "oracle/run-oracle/index.html#stopping-the-autonity-oracle-server",
    "href": "oracle/run-oracle/index.html#stopping-the-autonity-oracle-server",
    "title": "Run Autonity Oracle Server",
    "section": "Stopping the Autonity Oracle Server",
    "text": "Stopping the Autonity Oracle Server\n    To shutdown the oracle server, press CTRL-C and wait for it to exit.\n    \n    If you need help, you can chat to us on Autonity Discord Server!"
  },
  {
    "objectID": "oracle/index.html",
    "href": "oracle/index.html",
    "title": "Running an Oracle Server",
    "section": "",
    "text": "To operate and run a validator node, the Autonity Oracle Server must also be installed and configured to collect data from one or more external data sources.\n    The steps here describe how to install and run the oracle server, configure external data sources, and configure the server to connect to your validator node. This guide assumes a running validator node and connected aut."
  },
  {
    "objectID": "oracle/install-oracle/index.html",
    "href": "oracle/install-oracle/index.html",
    "title": "Install Autonity Oracle Server in your environment",
    "section": "",
    "text": "The Autonity Oracle Server can be installed in several ways:\n    \n    as a pre-compiled Linux Executable File from the Release Archive\n    by building the client from source code\n    in a Docker container.\n    \n    We assume that the Autonity Oracle Server will run on a host machine (a VPS or other host that is always-on and persistently available), and a distinct host machine will be used for Autonity Go Client the oracle serves via the WSS endpoint.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Autonity Oracle Server source code is versioned on a 3-digit major.minor.patch versioning scheme, and hosted and maintained in the public GitHub repo [autonity-oracle] (https://github.com/autonity/autonity-oracle)."
  },
  {
    "objectID": "oracle/install-oracle/index.html#overview",
    "href": "oracle/install-oracle/index.html#overview",
    "title": "Install Autonity Oracle Server in your environment",
    "section": "",
    "text": "The Autonity Oracle Server can be installed in several ways:\n    \n    as a pre-compiled Linux Executable File from the Release Archive\n    by building the client from source code\n    in a Docker container.\n    \n    We assume that the Autonity Oracle Server will run on a host machine (a VPS or other host that is always-on and persistently available), and a distinct host machine will be used for Autonity Go Client the oracle serves via the WSS endpoint.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Autonity Oracle Server source code is versioned on a 3-digit major.minor.patch versioning scheme, and hosted and maintained in the public GitHub repo [autonity-oracle] (https://github.com/autonity/autonity-oracle)."
  },
  {
    "objectID": "oracle/install-oracle/index.html#requirements",
    "href": "oracle/install-oracle/index.html#requirements",
    "title": "Install Autonity Oracle Server in your environment",
    "section": "Requirements",
    "text": "Requirements\n    \n    Hardware\n    To run an Autonity Oracle Server, we recommend using a host machine (physical or virtual) with the following minimum specification:\n    \n    \n    \n    Requirement\n    At least\n    Recommended\n    \n    \n    \n    \n    OS\n    Ubuntu 20.04 LTS\n    Ubuntu 20.04 LTS\n    \n    \n    CPU\n    1.9GHz with 4CPU’s\n    1.9GHz with 4CPU’s\n    \n    \n    RAM\n    2GB\n    4GB\n    \n    \n    Storage\n    32GB\n    64GB\n    \n    \n    Network interface\n    64Mbit/s\n    128Mbit/s\n    \n    \n    \n    \n    \n    Network\n    A public-facing internet connection with static IP is required. Incoming traffic must be allowed on the following:\n    \n    TCP 8546 to make WebSocket RPC connections to the node.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Your validator node’s installation must also allow traffic on your validator node’s port TCP 8546 to allow the Oracle Server’s WebSocket RPC connection to the node.\n    \n    \n    \n    The description here covers only the basic network setup. Especially in a production setting, administrators should consider further security measures based on their situation."
  },
  {
    "objectID": "oracle/install-oracle/index.html#install-binary",
    "href": "oracle/install-oracle/index.html#install-binary",
    "title": "Install Autonity Oracle Server in your environment",
    "section": "Installing the pre-compiled executable",
    "text": "Installing the pre-compiled executable\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    A Linux OS running on AMD64 architecture is required to run the pre-compiled executable.\n    \n    \n    \n    \n    Navigate to the Autonity Oracle Server Releases Archive and download the latest stable release version of the Autonity Oracle Server autoracle-linux-amd64-&lt;RELEASE_VERSION&gt;.tar.gz from the Assets section.\n    Create a working directory for installing Oracle Server. For example:\n    mkdir autonity-oracle\ncd autonity-oracle\n    Unpack the downloaded tarball to your working directory:\n    tar -xf &lt;PATH_TO_DOWNLOADS_DIRECTORY&gt;/autoracle-linux-amd64-&lt;RELEASE_VERSION&gt;.tar.gz\n    This will unpack the pre-compiled executable, a /plugins subdirectory containing data source plugins packaged in the release, and a plugins-conf.yml configuration file.\n    (Optional) Add data source plugins. Navigate to the plugins sub-directory of your working directory and add sub-directories for additional plugins you are installing.\n    (Optional) Copy the binary to /usr/local/bin so it can be accessed by all users, or other location in your PATH :\n    sudo cp -r autoracle /usr/local/bin/autoracle\n    \n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    You can now configure and launch Autonity Oracle Server."
  },
  {
    "objectID": "oracle/install-oracle/index.html#install-source",
    "href": "oracle/install-oracle/index.html#install-source",
    "title": "Install Autonity Oracle Server in your environment",
    "section": "Build from source code",
    "text": "Build from source code\n    \n    \n    \n    \n    \n    \n    Prerequisites\n    \n    \n    \n    \n    \n    The following should be installed in order to build the Autonity Oracle Server: - Git Follow the official GitHub documentation to install git. (Check if installed: git --version) - Golang (version 1.19.3 or later) - https://golang.org/dl (Check if installed: go --version or go version) - C compiler (GCC or another) (Check if GCC is installed: gcc --version) - GNU Make (Check if installed: make --version)\n    \n    \n    \n    \n    Clone/Copy the Autonity Oracle Server repo:\n    git clone git@github.com:autonity/autonity-oracle.git\n    Enter the autonity-oracle directory and build autonity oracle server. ```\n    This will build the executable (./build/bin/autoracle) and create a subdirectory containing data source plugins packaged in the release (./build/bin/plugins/).\n    Adjust the make command according to the testnet you are connecting to.\n    If connecting to Piccadilly Testnet, run:\n    cd autonity-oracle\nmake autoracle\n    If connecting to Bakerloo Testnet, run:\n    cd autonity-oracle\nmake autoracle-bakerloo\n    (Optional) Add data source plugins. Navigate to the plugins sub-directory of your working directory and add sub-directories for additional plugins you are installing. See Installing data source plugins.\n    (Optional) Copy the generated binary to /usr/local/bin so it can be accessed by all users, or other location in your PATH:\n    sudo cp build/bin/autoracle /usr/local/bin/autoracle\n    \n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    You can now configure and launch Autonity Oracle Server."
  },
  {
    "objectID": "oracle/install-oracle/index.html#install-docker",
    "href": "oracle/install-oracle/index.html#install-docker",
    "title": "Install Autonity Oracle Server in your environment",
    "section": "Installing the Docker image",
    "text": "Installing the Docker image\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Follow the official Docker documentation to install Docker onto the host machine and follow the post-installation steps to customize for your environment.\n    By default Docker needs to be run with sudo. To avoid using root privileges in the terminal (and error messages if you forget to use sudo), consider following the step to Manage Docker as a non-root user.\n    Consider also configuring Docker to start on boot.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Optional but recommended\n    \n    \n    \n    \n    \n    To limit the size of the log files, add the following to the file /etc/docker/daemon.json (create it if it does not exist):\n    {\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"500m\",\n    \"max-file\": \"20\"\n  }\n}\n    Restart the Docker service to ensure the change is reflected:\n    sudo systemctl restart docker\n    \n    \n    \n    \n    Create a working directory and CD to your working directory: bash     mkdir autonity-oracle && cd autonity-oracle\n    Pull the Autonity Oracle Server image from the GitHub Container Registry.\n    If you are deploying to the Bakerloo Testnet:\n    docker pull ghcr.io/autonity/autonity-oracle-bakerloo:latest\n    If you are deploying to the Piccadilly Testnet:\n    docker pull ghcr.io/autonity/autonity-oracle-piccadilly:latest\n    (where latest can be replaced with another version)\n    Note that the data source plugins are included as part of the Docker image at the directory path /usr/local/bin/plugins.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    For more information on using and pulling Docker images from GHCR, see GitHub docs Working with the container registry.\n    \n    \n    \n    \n    \n    \n    (Optional) Add data source plugins. Navigate to the plugins sub-directory of your working directory and add sub-directories for additional plugins you are installing.\n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    You can now configure and launch oracle server."
  },
  {
    "objectID": "oracle/install-oracle/index.html#verify",
    "href": "oracle/install-oracle/index.html#verify",
    "title": "Install Autonity Oracle Server in your environment",
    "section": "Verify the installation",
    "text": "Verify the installation\n    You should now be able to execute the autoracle command. Verify your installation by executing autoracle version to return the oracle version and configuration:\n    $ ./autoracle version\n    v0.1.6\n    If using Docker, the setup of the Bakerloo image can be verified with:\n    docker run --rm ghcr.io/autonity/autonity-oracle:latest version \n    v0.1.6\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The output above will vary depending on the version of the Autonity Oracle Server you have installed. Confirm that the “Version” field is consistent with the version you expect."
  },
  {
    "objectID": "oracle/install-oracle/index.html#install-plugin",
    "href": "oracle/install-oracle/index.html#install-plugin",
    "title": "Install Autonity Oracle Server in your environment",
    "section": "Installing data source plugins",
    "text": "Installing data source plugins\n    Oracle server will need to provide price data for FX and ATN and NTN currency pairs utilized in the Auton Stabilization Mechanism.\n    A basic set of data adaptor plugins for sourcing this data is provided out the box with oracle server for testnet pre-Mainnet:\n    \n    Forex plugins: for connecting to public FX data sources. See the forex_ prefixed adaptors in /plugins. Four forex plugins are currently provided.\n    ATN and NTN plugins:\n    \n    For connecting to Piccadilly Testnet. See the pcgc_cax adaptor in /plugins. This provides ATN and NTN data from the Centralized Auton Exchange deployed to Piccadilly for the Piccadilly Circus Games Competition. See game.autonity.org.\n    For connecting to Bakerloo Testnet. See the sim_plugin adaptor in /plugins. This provides simulated ATN and NTN data.\n    \n    \n    The plugins are built by the make process when building from source. The plugins are included pre-built as part of oracle server Docker image and the pre-built executable.\n    If installing by building from source, run the make command appropriate for the Testnet you are connecting to as described in Build from source code. You can view the built plugins in the directory ./build/bin/plugins.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The Simulator plugin is built when building from source for Bakerloo Testnet. You can also build the Simulator plugin independently by running the command make simulator. This will build the sim_plugin in the /plugins directory. A local testnet could be a scenario for setting up and using a simulator.\n    If you have developed your own plugins for external data sources using the oracle server’s plugin template architecture, then you will need to build them and add to the /plugins directory.\n    For how to do this, see Developing data plugins."
  },
  {
    "objectID": "oracle/install-oracle/index.html#next",
    "href": "oracle/install-oracle/index.html#next",
    "title": "Install Autonity Oracle Server in your environment",
    "section": "Next steps",
    "text": "Next steps\n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    You can now configure and launch the oracle server.\n    \n    \n    \n    \n    If you need help, you can chat to us on Autonity Discord Server!"
  },
  {
    "objectID": "account-holders/setup-aut/index.html",
    "href": "account-holders/setup-aut/index.html",
    "title": "Setup the Autonity Utility Tool (aut)",
    "section": "",
    "text": "The recommended way of interacting with the Autonity network is via the Autonity Utility Tool aut, which provides a command-line interface to Autonity-specific queries and operations, as well as much of the base Ethereum functionality. In general it only needs to be installed on local machines, to connect to the RPC endpoint of an Autonity Go Client (either your own node, or a node providing public RPC access).\nFor full details and to report any issues, see the aut repository."
  },
  {
    "objectID": "account-holders/setup-aut/index.html#install",
    "href": "account-holders/setup-aut/index.html#install",
    "title": "Setup the Autonity Utility Tool (aut)",
    "section": "Installation",
    "text": "Installation\n    \n    \n    \n    \n    \n    \n    Prerequisites\n    \n    \n    \n    \n    \n    A working Python install with the pip tool is required.\n    \n    \n    \n    The tool can be installed using pipx. To get the latest release run:\n    pipx install --force git+https://github.com/autonity/aut\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If you are experiencing errors such as:\n    ImportError: cannot import name 'NodeAddress' from 'autonity.validator'\n    You are using an earlier version of aut. Please upgrade your aut tool to use the latest release using the installation command above.\n    It is highly recommended to also follow the instructions in the repository to set up command-line completion."
  },
  {
    "objectID": "account-holders/setup-aut/index.html#configure",
    "href": "account-holders/setup-aut/index.html#configure",
    "title": "Setup the Autonity Utility Tool (aut)",
    "section": "Configuration using the .autrc file",
    "text": "Configuration using the .autrc file\n    As detailed in the aut repository, some configuration parameters can be set in an .autrc file in the working directory or any parent directory. As a minimal configuration, it is recommended to create an .autrc containing the end-point to use for RPC operations:\n    [aut]\nrpc_endpoint=https://rpc1.&lt;NETWORK_NAME&gt;.autonity.org\n    See the list of available networks to determine the correct endpoint to use."
  },
  {
    "objectID": "account-holders/setup-aut/index.html#usage",
    "href": "account-holders/setup-aut/index.html#usage",
    "title": "Setup the Autonity Utility Tool (aut)",
    "section": "Usage",
    "text": "Usage\n    The tool is intended to be self documenting via aut --help, aut &lt;command&gt; --help etc. Some example commands can be found in the aut repository.\n    We suggest trying the following command (which retrieves some basic information about the connected node and network) to confirm that the install and configuration have been successful:\n    aut node info\n    {\n  \"eth_accounts\": [],\n  \"eth_blockNumber\": 12803619,\n  \"eth_gasPrice\": 1000000000,\n  \"eth_syncing\": false,\n  \"eth_chainId\": 65100000,\n  \"net_listening\": true,\n  \"net_peerCount\": 19,\n  \"net_networkId\": \"65100000\",\n  \"web3_clientVersion\": \"Autonity/v0.10.0-1183a113-20230118/linux-amd64/go1.19\",\n  \"admin_enode\": \"enode://d9a7297b2bec3c2f92233dc42f53c0cf98af30528a56765b102d9e28be2a760b7fd3045790246d1a5836af9a8ea5d2dbcc9b56864f6391045ba76391d9db931e@77.86.9.81:30303\",\n  \"admin_id\": \"8794927d6dda6f8cb45bc7eefd9084dbb3b81ce508ff43e1ccb7fe904ccd2cfc\"\n}\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The output above may vary depending on the version of the Autonity Go Client you are connected to.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    Now that you have a working aut installation, you can create and fund and account on the network, and then create and submit a transaction.\n    \n    \n    \n    \n    If you need help, you can chat to us on Autonity Discord Server!"
  },
  {
    "objectID": "account-holders/index.html",
    "href": "account-holders/index.html",
    "title": "Accounts",
    "section": "",
    "text": "In order to submit a transaction to the Autonity network, an account is required. The concept of an account in Autonity matches that of Ethereum. Briefly, an account has a public address (which acts as an identifier of the account for use by other participants) and a secret “private key”, which is required in order to control the account (and in particular to spend funds held by the account). This is described further in the System Model section."
  },
  {
    "objectID": "account-holders/create-acct/index.html",
    "href": "account-holders/create-acct/index.html",
    "title": "Create an account",
    "section": "",
    "text": "This how to covers the import and generation of new accounts using aut. Accounts are created as Ethereum keystore files using the Web3 Secret Storage Definition, an encrypted file format that provides secure storage for an account’s private key.\n    \n    \n    \n    \n    \n    \n    Warning\n    \n    \n    \n    \n    \n    The use of hardware wallets or other key-management tools may be more secure than encrypted files. Operators may choose to make use of such tools with Autonity, and explicit support for these will be added in the future. For the purposes of the testnets this guide will assume the use of password-protected keyfiles.\n    Ensure that your keystore file is backed up and stored securely according to your security policy at all times; remember the password phrase you used to create it! If you do not remember the password, you will not be able to decrypt this private key file and may lose any funds associated with this account."
  },
  {
    "objectID": "account-holders/create-acct/index.html#overview",
    "href": "account-holders/create-acct/index.html#overview",
    "title": "Create an account",
    "section": "",
    "text": "This how to covers the import and generation of new accounts using aut. Accounts are created as Ethereum keystore files using the Web3 Secret Storage Definition, an encrypted file format that provides secure storage for an account’s private key.\n    \n    \n    \n    \n    \n    \n    Warning\n    \n    \n    \n    \n    \n    The use of hardware wallets or other key-management tools may be more secure than encrypted files. Operators may choose to make use of such tools with Autonity, and explicit support for these will be added in the future. For the purposes of the testnets this guide will assume the use of password-protected keyfiles.\n    Ensure that your keystore file is backed up and stored securely according to your security policy at all times; remember the password phrase you used to create it! If you do not remember the password, you will not be able to decrypt this private key file and may lose any funds associated with this account."
  },
  {
    "objectID": "account-holders/create-acct/index.html#create-account-using-aut",
    "href": "account-holders/create-acct/index.html#create-account-using-aut",
    "title": "Create an account",
    "section": "Create account using aut",
    "text": "Create account using aut\n    The following command will generate a keyfile with a default generated name, in the keystore (which can be specified with the --keyfile flag, or by adding a keyfile = &lt;path&gt; entry to the .autrc file).\n    aut account new\n    Password for new account:\nConfirm account password:\n0x905824A6924F1564348Dac9709b3113AFb7c8C77  ~/.autonity/keystore/UTC--2023-01-20T09-45-05.360588000Z--905824a6924f1564348dac9709b3113afb7c8c77\n    A custom keyfile can be specified using the --keyfile flag:\n    mkdir keystore\naut account new --keyfile ./keystore/alice.key\n    Password for new account:\nConfirm account password:\n0x0592486A2491F653484Dac709b91331AF7Cb7c87  keystore/alice.key\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    To see all options available for account creation, run aut account new --help. See also aut account list for working with key-stores."
  },
  {
    "objectID": "account-holders/create-acct/index.html#import-account-using-aut",
    "href": "account-holders/create-acct/index.html#import-account-using-aut",
    "title": "Create an account",
    "section": "Import account using aut",
    "text": "Import account using aut\n    An account can be created from an existing private key using aut:\n    \n    Create a plain text file that contains the private key in hexadecimal format. For example, copy your private key into a file named alice.priv\n    Import the key using the import-private-key command:\n    aut account import-private-key ./alice.priv\n    Password for new account:\nConfirm account password:\n0xd4EdDdE5D1D0d7129a7f9C35Ec55254f43b8E6d4  ~/.autonity/keystore/UTC--2023-01-20T09-45-05.360588000Z--d4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4\n    \n    The --keyfile and --keystore flags can be used as with aut account new to control the location of the resulting keyfile.\n\n    \n    \n    If you need help, you can chat to us on Autonity Discord Server!"
  },
  {
    "objectID": "account-holders/key-mgt/clef/index.html",
    "href": "account-holders/key-mgt/clef/index.html",
    "title": "Connect Clef secure wallet",
    "section": "",
    "text": "An installation of Autonity built with make all as described in the How to Install Autonity.\n    A funded account on the network with the keystore file save to the keystore directory that Clef will be specified in Clef’s configuration. (See Use Clef with the Autonity client beneath.\n    an installed NodeJS Console configured as described in the Submit a transaction using NodeJS Console"
  },
  {
    "objectID": "account-holders/key-mgt/clef/index.html#prerequisites",
    "href": "account-holders/key-mgt/clef/index.html#prerequisites",
    "title": "Connect Clef secure wallet",
    "section": "",
    "text": "An installation of Autonity built with make all as described in the How to Install Autonity.\n    A funded account on the network with the keystore file save to the keystore directory that Clef will be specified in Clef’s configuration. (See Use Clef with the Autonity client beneath.\n    an installed NodeJS Console configured as described in the Submit a transaction using NodeJS Console"
  },
  {
    "objectID": "account-holders/key-mgt/clef/index.html#overview",
    "href": "account-holders/key-mgt/clef/index.html#overview",
    "title": "Connect Clef secure wallet",
    "section": "Overview",
    "text": "Overview\n    Clef is the replacement for Go Ethereum’s account management functionality, but it is not a Geth module. Rather, it is a standalone daemon that works with any Ethereum client. It is a framework to unify all existing methods of signing transactions through a pluggable architecture. It works by exposing an API to local clients via IPC or HTTP. Clef currently supports keyfile-format accounts as well as hardware wallets.\n    This how to describes setting up Clef and using it with Autonity for account management and signing transactions.\n    \n    \n    \n    \n    \n    \n    Further Information\n    \n    \n    \n    \n    \n    For tutorials and in-depth information on clef we recommend referring to the Go Ethereum Clef docs at https://geth.ethereum.org/docs/clef/introduction."
  },
  {
    "objectID": "account-holders/key-mgt/clef/index.html#setup-clef",
    "href": "account-holders/key-mgt/clef/index.html#setup-clef",
    "title": "Connect Clef secure wallet",
    "section": "Setup Clef",
    "text": "Setup Clef\n    The following are the steps to successfully demonstrate clef working with Autonity:\n    \n    Navigate to the working directory for your Autonity installation. Initialise the clef utility:\n    ./autonity/build/bin/clef init\n    Clef will initialise and print to the console, prompting you to enter OK:\n    WARNING!\n\n Clef is an account management tool. It may, like any software, contain bugs.\n\n Please take care to\n - backup your keystore files,\n - verify that the keystore(s) can be opened with your password.\n\n Clef is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n PURPOSE. See the GNU General Public License for more details.\n\n Enter 'ok' to proceed:\n &gt;\n    Enter ‘ok’ and enter a password when prompted for the masterseed.json file:\n    The master seed of clef will be locked with a password.\nPlease specify a password. Do not forget this password!\nPassword:\nRepeat password:\n\nA master seed has been generated into /home/alice/.clef/masterseed.json\n\nThis is required to be able to store credentials, such as:\n* Passwords for keystores (used by rule engine)\n* Storage for JavaScript auto-signing rules\n* Hash of JavaScript rule-file\n\nYou should treat 'masterseed.json' with utmost secrecy and make a backup of it!\n* The password is necessary but not enough, you need to back up the master seed too!\n* The master seed does not contain your accounts, those need to be backed up separately!\n    Clef is now setup and ready to use.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The password that you are setting here is not the password for your keystore. It is the password for the clef masterseed, which is used for a variety of functions, including storing keystores passwords. It is strongly suggested to choose a strong password, different from the keystore one."
  },
  {
    "objectID": "account-holders/key-mgt/clef/index.html#use-clef-with-the-autonity-client",
    "href": "account-holders/key-mgt/clef/index.html#use-clef-with-the-autonity-client",
    "title": "Connect Clef secure wallet",
    "section": "Use Clef with the Autonity client",
    "text": "Use Clef with the Autonity client\n    \n    Start the Clef binary, specifying:\n    \n    (optional) the &lt;PATH&gt; to the keystore directory holding the accounts you will use. If not specified, the default location will be used as described in the how to Create an account using Clef\n    the &lt;CHAINID&gt; for the Autonity network to which your Autonity Go Client node is connected:\n    \n    ./clef --keystore ~/.autonity/keystore --chainid 65010000\n    You will be prompted to enter ‘ok’ and then your masterseed password. Clef will initialise and print its status to the console:\n     -----------------------\n INFO [03-25|15:14:40.579] Starting signer                           chainid=444,800 keystore=/home/alice/.autonity/keystore light-kdf=false     advanced=false\n DEBUG[03-25|15:14:40.579] FS scan times                             list=\"83.278µs\" set=\"11.424µs\" diff=\"4.714µs\"\n DEBUG[03-25|15:14:40.580] Ledger support enabled\n DEBUG[03-25|15:14:40.580] Trezor support enabled via HID\n DEBUG[03-25|15:14:40.580] Trezor support enabled via WebUSB\n INFO [03-25|15:14:40.580] Smartcard socket file missing, disabling err=\"stat /run/pcscd/pcscd.comm: no such file or directory\"\n INFO [03-25|15:14:40.580] Audit logs configured                     file=audit.log\n DEBUG[03-25|15:14:40.580] IPCs registered                           namespaces=account\n INFO [03-25|15:14:40.580] IPC endpoint opened                      url=/    home/alice/.clef/clef.ipc\n ------- Signer info -------\n * intapi_version : 7.0.1\n * extapi_version : 6.1.0\n * extapi_http : n/a\n * extapi_ipc : /home/alice/.clef/clef.ipc\n DEBUG[03-25|15:14:47.597] Served account_version                   reqid=1  duration=\"147.624µs\"\n DEBUG[03-25|15:14:47.599] RPC connection read error                err=EOF\n DEBUG[03-25|15:36:54.364] Served account_version                   reqid=1  duration=\"97.296µs\"\n    Make a note of the extapi_ipc url in the ‘Signer info’ section. This is the endpoint the Autonity client will connect to. In the example above this is /home/alice/.clef/clef.ipc.\n    Run the Autonity client binary with the addition of the --signerflag, specifying as the &lt;PATH&gt; the extapi_ipc value from the preceding step:\n    --signer=&lt;PATH&gt;/.clef/clef.ipc"
  },
  {
    "objectID": "account-holders/key-mgt/clef/index.html#submit-transactions-using-nodejs-console",
    "href": "account-holders/key-mgt/clef/index.html#submit-transactions-using-nodejs-console",
    "title": "Connect Clef secure wallet",
    "section": "Submit transactions using NodeJS Console",
    "text": "Submit transactions using NodeJS Console\n    ::: {.callout-note title=“Note” collapse=“false”}Since you are using clef to sign transactions, whenever you issue a command on the NodeJS console which requires a signature from your private key, the nodejs console will hang. This is because it is waiting for the signature from clef, that you need to manually approve. This process can be automated using the clef rule engine https://geth.ethereum.org/docs/clef/tutorial#automatic-rules:::\n    \n    Start the Autonity NodeJS Console and then, to view the accounts in Clef, enter as follows:\n    const wallet = await web3.personal.listWallets()\nconst address = web3.utils.toChecksumAddress(wallet[0].accounts[0].address)\naddress\n    This will retrieve the first address in the configured keystore directory. If there is more than one account in the wallet, edit the list index position from which you will retrieve the account in accounts[0]. For example, change to accounts[2] to return the third address listed in the wallet.\n    Clef will prompt to approve the request. Enter ‘y’. The NodeJS Console will return something like this:\n    &gt; address\n'0xcC50C345B34a80c6bDc51Be4dd79dC73ee81190e'\n    Send a transaction with your chosen account in the Autonity NodeJS Console.\n    Note that gas costs are automatically calculated by the Autonity client if the gas-related parameters are not included in the method arguments passed to the called RPC method.\n    To verify Clef signing is functioning correctly, send an empty transaction using eth.sendTransaction, specifying ‘from’ and ‘to’ account addresses:\n    web3.eth.sendTransaction({from: address, to: address})\n    For example:\n    &gt; web3.eth.sendTransaction({from: '0xcC50C345B34a80c6bDc51Be4dd79dC73ee81190e',to: '0xbC50C347A44a80c6bDc51Be4dd79eC73ee89290f'})\n    Clef will print the transaction request to the console and prompt you to approve the request. For example:\n     -----------------------\n WARN [03-25|17:21:42.172] Served account_signTransaction           reqid=6  duration=4.372186471s    err=\"request denied\"\n --------- Transaction request-------------\n to:    0xbC50C347A44a80c6bDc51Be4dd79eC73ee89290f\n from:               0xcC50C345B34a80c6bDc51Be4dd79dC73ee81190e [chksum ok]\n value:              0 wei\n gas:                0x5208 (21000)\n maxFeePerGas:          2500010000 wei\n maxPriorityFeePerGas:  2500000000 wei\n nonce:    0x1 (1)\n chainid:  0x6c980\n Accesslist\n\nRequest context:\n     NA -&gt; ipc -&gt; NA\n\nAdditional HTTP header data, provided by the external caller:\n     User-Agent: \"\"\n     Origin: \"\"\n -------------------------------------------\n Approve? [y/N]:\n    Enter ‘y’ and when prompted enter the password for the account:\n    &gt; y\nWARN [03-25|17:22:08.510] Key does not exist                          key= 0xcC50C345B34a80c6bDc51Be4dd79dC73ee81190e\n## Account password\n\nPlease enter the password for account 0xcC50C345B34a80c6bDc51Be4dd79dC73ee81190e\n&gt;\n    The transaction will then send. Clef prints details of the transaction signed to console:\n    -----------------------\nTransaction signed:\n{\n   \"type\": \"0x2\",\n    \"nonce\": \"0x1\",\n    \"gasPrice\": null,\n    \"maxPriorityFeePerGas\": \"0x9502f900\",\n    \"maxFeePerGas\": \"0x95032010\",\n    \"gas\": \"0x5208\",\n    \"value\": \"0x0\",\n    \"input\": \"0x\",\n    \"v\": \"0x0\",\n    \"r\": \"0x78b3940aa2aaef9b86845bce56aeb6fde141e3b161b3e7b98f884df3d2424cfb\",\n    \"s\": \"0x2b410bf9164e6cfcf77784ba65d9eec578e881be971b120e7cf005ca09414b71\",\n    \"to\": \"0xbc50c347a44a80c6bdc51be4dd79ec73ee89290d\",\n    \"chainId\": \"0x6c980\",\n    \"accessList\": [],\n    \"hash\": \"0x892bbed9991f03d89afa65a4170c8dc9703b76a905407f4b281d1939a747a3c1\"\n}\nDEBUG[03-25|17:22:34.304] Served account_signTransaction           reqid=7  duration=47.892717474s\n    In the NodeJS Console, on completion of the sendTransaction, the method returns and the blockhash is returned:\n    &gt; web3.eth.sendTransaction({from: '0xcC50C345B34a80c6bDc51Be4dd79dC73ee81190e',to: '0xbC50C347A44a80c6bDc51Be4dd79eC73ee89290f'})\n{ blockHash:\n'0x6bc8c3eb68834207a8b0516d599c4d0d85cebcbd3e6399ee9bd98e5f996e924e',\nblockNumber: 6339,\ncontractAddress: null,\ncumulativeGasUsed: 21000,\neffectiveGasPrice: 2500005000,\nfrom: '0xcC50C345B34a80c6bDc51Be4dd79dC73ee81190e',\ngasUsed: 21000,\nlogs: [],\nlogsBloom:\n'0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\nstatus: true,\nto: '0xbC50C347A44a80c6bDc51Be4dd79eC73ee89290f',\ntransactionHash:\n'0x892bbed9991f03d89afa65a4170c8dc9703b76a905407f4b281d1939a747a3c1',\ntransactionIndex: 0,\ntype: '0x2' }\n&gt;"
  },
  {
    "objectID": "account-holders/key-mgt/clef/index.html#examples",
    "href": "account-holders/key-mgt/clef/index.html#examples",
    "title": "Connect Clef secure wallet",
    "section": "Examples",
    "text": "Examples\n    Here are some examples of calling Autonity Protocol Contract ERC20 functionality from the console using Clef to sign.\n    For parameter definitions and usage see the Reference Autonity Interfaces.\n    \n    Transfer Auton between accounts using eth web3.eth.sendTransaction:\n    web3.eth.sendTransaction({from: \"&lt;address&gt;\",to: \"&lt;address&gt;\", value: &lt;AMOUNT&gt;})\n    \n    \n    Transfer Newton stake token to another account using autonity.transfer:\n    autonity.transfer('&lt;_recipient&gt;', &lt;_amount&gt;).send({from: myAddress, gas: gas})"
  },
  {
    "objectID": "account-holders/key-mgt/usb-wallets/index.html",
    "href": "account-holders/key-mgt/usb-wallets/index.html",
    "title": "Connect hardware wallet",
    "section": "",
    "text": "physical access to a running local instance of an Autonity Go Client connected to an Autonity network\n    a running instance of the Autonity NodeJS Console attached to your node, configured for your account as described in Submit a transaction from Autonity NodeJS Console\n    one of the supported hardware wallets holding your account keys:\n    \n    USB wallets: Ledger, Trezor\n    \n    udev rules for the chosen hardware wallet have been configured on the host Linux machine if a USB wallet:\n    \n    Ledger. Refer to Solution 1. Set up udev rules in the Ledger support article Fix USB connection issues with Ledger Live run:\n    Trezor. Refer to the Trezor Wiki article set up Udev rules.\n    \n    installed app for the chosen hardware wallet:\n    Trezor Suite app. Refer to the Trezor Wiki article Apps: Trezor Suite\n    Ledger Live app. Refer to the Ledger support article Download and install Ledger Live"
  },
  {
    "objectID": "account-holders/key-mgt/usb-wallets/index.html#prerequisites",
    "href": "account-holders/key-mgt/usb-wallets/index.html#prerequisites",
    "title": "Connect hardware wallet",
    "section": "",
    "text": "physical access to a running local instance of an Autonity Go Client connected to an Autonity network\n    a running instance of the Autonity NodeJS Console attached to your node, configured for your account as described in Submit a transaction from Autonity NodeJS Console\n    one of the supported hardware wallets holding your account keys:\n    \n    USB wallets: Ledger, Trezor\n    \n    udev rules for the chosen hardware wallet have been configured on the host Linux machine if a USB wallet:\n    \n    Ledger. Refer to Solution 1. Set up udev rules in the Ledger support article Fix USB connection issues with Ledger Live run:\n    Trezor. Refer to the Trezor Wiki article set up Udev rules.\n    \n    installed app for the chosen hardware wallet:\n    Trezor Suite app. Refer to the Trezor Wiki article Apps: Trezor Suite\n    Ledger Live app. Refer to the Ledger support article Download and install Ledger Live"
  },
  {
    "objectID": "account-holders/key-mgt/usb-wallets/index.html#overview",
    "href": "account-holders/key-mgt/usb-wallets/index.html#overview",
    "title": "Connect hardware wallet",
    "section": "Overview",
    "text": "Overview\n    This how to describes the workflow for connecting Trezor and Ledger Nano S hardware wallets to an Autonity Go Client, signing and sending transactions with the NodeJS Console.\n    Autonity maintains go-ethereum’s out-the-box support for external hardware secure wallets. Before connecting a USB external hardware wallet to a Linux machine you will need to configure the Linux Udev subsystem with device-specific rules for the external drive to be recognised. For how to setup udev rules see prerequisites above."
  },
  {
    "objectID": "account-holders/key-mgt/usb-wallets/index.html#use-trezor-wallet-with-the-autonity-client",
    "href": "account-holders/key-mgt/usb-wallets/index.html#use-trezor-wallet-with-the-autonity-client",
    "title": "Connect hardware wallet",
    "section": "Use Trezor wallet with the Autonity client",
    "text": "Use Trezor wallet with the Autonity client\n    \n    Start the Autonity client and connect to your chosen Autonity network. Connect NodeJS Console to the node\n    Plug Trezor wallet into the host machine and unlock using Trezor Suite app\n    Get the URL of the Trezor wallet by calling from NodeJS Console:\n    web3.personal.listWallets()\n    The result will look something like this:\n    [\n  {\n    url: 'trezor://1209:53c1:03',\n    status: 'Closed',\n failure: 'failed to write to device: libusb: i/o error [code -1]'\n  }\n]\n    Open the Trezor wallet using the PIN code set with Trezor:\n    web3.personal.openWallet('trezor://1209:53c1:03', '&lt;TREZOR_PINCODE&gt;')\n    Get the address of the Trezor wallet account:\n    const wallet = await web3.personal.listWallets()\nconst address = web3.utils.toChecksumAddress(wallet[0].accounts[0].address)\naddress\n    Verify the wallet account is functioning. Send a test transaction using Trezor:\n    web3.eth.sendTransaction({from: &lt;ADDRESS&gt;, to: &lt;ADDRESS&gt;})\n    You will be prompted on the Trezor hardware wallet to confirm the transaction.\n    \n    To transfer value, you will need to specify transaction fee values, configuring the NodeJS Console with gas constants as described in the How to Submit a transaction from Autonity NodeJS Console. For example, to transfer an amount of newton stake token to another address by calling the Autonity Protocol Contract using Trezor:\n    const gas = 10000000;\nautonity.transfer('&lt;TO_ADDRESS&gt;', &lt;AMOUNT&gt;).send({from: myAddress, gas: gas})\n    You will be prompted on the Trezor wallet to confirm the transaction."
  },
  {
    "objectID": "account-holders/key-mgt/usb-wallets/index.html#use-ledger-wallet-with-the-autonity-client",
    "href": "account-holders/key-mgt/usb-wallets/index.html#use-ledger-wallet-with-the-autonity-client",
    "title": "Connect hardware wallet",
    "section": "Use Ledger wallet with the Autonity client",
    "text": "Use Ledger wallet with the Autonity client\n    \n    Start the Autonity client and connect to your chosen Autonity network. Connect NodeJS Console to the node\n    Plug Ledger Nano S wallet into the host machine, unlock using Ledger Live app, and open the Ethereum application on the Ledger\n    Get the address of the Ledger wallet account:\n    const wallet = web3.personal.listWallets()\nconst address = web3.utils.toChecksumAddress(wallet[0].accounts[0].address)\naddress\n    Verify the wallet account is functioning. Send a transaction using the Ledger Nano S:\n    web3.eth.sendTransaction({from: &lt;ADDRESS&gt;, to: &lt;ADDRESS&gt;})\n    You will be prompted on the Ledger hardware wallet to confirm the transaction\n    \n    To transfer value, you will need to:\n    \n    enable blind signing in the settings of the Ethereum application on the Ledger\n    specify transaction fee values, configuring the NodeJS Console with a gas constant as described in the How to Submit a transaction from Autonity NodeJS Console.\n    \n    For example, to transfer an amount of newton stake token to another address:\n    const gas = 10000000;\nautonity.transfer('&lt;TO_ADDRESS&gt;', &lt;AMOUNT&gt;).send({from: address, gas: gas})\n    You will be prompted on the Ledger wallet to confirm the transaction."
  },
  {
    "objectID": "account-holders/submit-trans-aut/index.html",
    "href": "account-holders/submit-trans-aut/index.html",
    "title": "Submit a transaction from the Autonity Utility tool (aut)",
    "section": "",
    "text": "To submit transactions to a client node from aut you need:\n    \n    An installation of aut - see the howto for further help.\n    An account that has been funded with auton, to pay for transaction gas costs.\n    aut should be configured to connect to the appropriate node or Autonity network (see the list of networks including public RPC endpoints.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    This guide assumes that the following have been set in your .autrc file, or will be added to the commands below using the appropriate flags: - rpc_endpoint: the endpoint URI of the node you will connect to. - keyfile: the path to the encrypted private key file for your default testnet account. - (optional) keystore: the default directory containing keyfiles."
  },
  {
    "objectID": "account-holders/submit-trans-aut/index.html#prerequisites",
    "href": "account-holders/submit-trans-aut/index.html#prerequisites",
    "title": "Submit a transaction from the Autonity Utility tool (aut)",
    "section": "",
    "text": "To submit transactions to a client node from aut you need:\n    \n    An installation of aut - see the howto for further help.\n    An account that has been funded with auton, to pay for transaction gas costs.\n    aut should be configured to connect to the appropriate node or Autonity network (see the list of networks including public RPC endpoints.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    This guide assumes that the following have been set in your .autrc file, or will be added to the commands below using the appropriate flags: - rpc_endpoint: the endpoint URI of the node you will connect to. - keyfile: the path to the encrypted private key file for your default testnet account. - (optional) keystore: the default directory containing keyfiles."
  },
  {
    "objectID": "account-holders/submit-trans-aut/index.html#examples",
    "href": "account-holders/submit-trans-aut/index.html#examples",
    "title": "Submit a transaction from the Autonity Utility tool (aut)",
    "section": "Examples",
    "text": "Examples\n    For parameter definitions and usage see the Reference Autonity Contract Interfaces.\n    \n    Transfer Auton:\n    Transfer Autonity’s native account coin, specifying the &lt;RECIPIENT_ADDRESS&gt;:\n    aut tx make --to &lt;RECIPIENT_ADDRESS&gt;  --value 1 | aut tx sign - | aut tx send -\n0xA473bC8B8449A2f02719F2569Ae8137F0bEcdb1843Ab78C84B9A4f02712F9529\n    \n    A note about signing and submitting\n    The output of each command above is being piped to the next in this example. Alternatively, the output can be written to files, for example to be signed using a hardware wallet or other key management systems).\n    This use of piping will appear in many example commands, for convenience. For reference: - aut tx make ... outputs a transaction in JSON format - aut tx sign ... signs the transaction and outputs the signed transaction in JSON format - aut tx send ... send the transaction and outputs the transaction hash\n    \n    \n    \n    Waiting for transactions\n    Wait for (and return the receipt from) a given transaction using its hash:\n    aut tx wait 0xA473bC8B8449A2f02719F2569Ae8137F0bEcdb1843Ab78C84B9A4f02712F9529\n    \n    \n    Transfer Newton:\n    Transferring Autonity’s native stake token Newton, specifying the &lt;RECIPIENT_ADDRESS&gt; and the --ntn flag:\n    aut tx make --to &lt;RECIPIENT_ADDRESS&gt; --value 1 --ntn | aut tx sign - | aut tx send -\n    \n    \n    Get auton balance:\n    Getting an account’s balance in Autonity’s native protocol coin Auton:\n    aut account balance\n    By default, the account associated with the default keyfile is used. Use aut account balance &lt;ACCOUNT_ADDRESS&gt; to check the balance of other accounts.\n    \n    \n    Get newton balance:\n    Getting an account’s balance in Autonity’s native stake token Newton, using the --ntn flag:\n    aut account balance --ntn\n    (Similarly, aut account balance --ntn &lt;ACCOUNT_ADDRESS&gt; can be used to check other accounts.)\n    \n    \n    ERC20 tokens:\n    The --token flag can be used to interact with any ERC20 token, including the Liquid Newton tokens for registered validators.\n    aut account balance --token &lt;TOKEN_ADDRESS&gt;\n    aut tx make --to &lt;RECIPIENT_ADDRESS&gt; --value 1.2 --token &lt;TOKEN_ADDRESS&gt; | aut tx sign - | aut tx send -\n    The following command can be used to determine the Liquid Newton contract address of the validator &lt;VALIDATOR&gt;.\n    aut validator info --validator &lt;VALIDATOR&gt;\n    See the liquid_contract field of the JSON output for the contract address.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    See also aut token --help for more command to interact with ERC20 tokens."
  },
  {
    "objectID": "account-holders/fund-acct/index.html",
    "href": "account-holders/fund-acct/index.html",
    "title": "Fund an account",
    "section": "",
    "text": "An account address - see the how to Create an account."
  },
  {
    "objectID": "account-holders/fund-acct/index.html#prerequisites",
    "href": "account-holders/fund-acct/index.html#prerequisites",
    "title": "Fund an account",
    "section": "",
    "text": "An account address - see the how to Create an account."
  },
  {
    "objectID": "account-holders/fund-acct/index.html#fund-account-from-faucet",
    "href": "account-holders/fund-acct/index.html#fund-account-from-faucet",
    "title": "Fund an account",
    "section": "Fund account from Faucet",
    "text": "Fund account from Faucet\n    To fund an account with testnet funds go to the Autonity Faucet. This provides a simple interface to acquire Auton (ATN), the native coin of an Autonity account.\n    \n    Navigate to the Autonity Faucet.\n    Input your account address.\n    Input the total value of auton you need.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Faucet requests are capped at 1,000.\n    \n    \n    \n    \n    Click the Go button to submit the funding request. The auton will be sent to your account in approximately 10 seconds."
  },
  {
    "objectID": "issues/index.html",
    "href": "issues/index.html",
    "title": "Known issues",
    "section": "",
    "text": "There is a known issue in the go-ethereum codebase where the default snap syncmode is not yet supported for new networks - see https://github.com/autonity/autonity/blob/master/eth/handler.go#L196-L200.\n    To resolve, for new networks:\n    \n    genesis nodes bootstrapping the network need to run with full sync: set the flag --syncmode \"full\" when starting the node\n    new nodes joining the network after genesis can run in the default “snap” syncmode."
  },
  {
    "objectID": "issues/index.html#snap-syncing-is-not-supported-for-new-networks",
    "href": "issues/index.html#snap-syncing-is-not-supported-for-new-networks",
    "title": "Known issues",
    "section": "",
    "text": "There is a known issue in the go-ethereum codebase where the default snap syncmode is not yet supported for new networks - see https://github.com/autonity/autonity/blob/master/eth/handler.go#L196-L200.\n    To resolve, for new networks:\n    \n    genesis nodes bootstrapping the network need to run with full sync: set the flag --syncmode \"full\" when starting the node\n    new nodes joining the network after genesis can run in the default “snap” syncmode."
  },
  {
    "objectID": "issues/index.html#autonity-protocol-proposer-election-algorithm-contains-an-off-by-one-error",
    "href": "issues/index.html#autonity-protocol-proposer-election-algorithm-contains-an-off-by-one-error",
    "title": "Known issues",
    "section": "Autonity Protocol proposer election algorithm contains an off-by-one error",
    "text": "Autonity Protocol proposer election algorithm contains an off-by-one error\n    The proposer election algorithm for height h and round r actually returns the result for height h-1 and round r.\n    The Autonity Protocol Contract Interface function getProposer() takes parameters of block height and consensus round. To get the elected proposer for height = h and round = r pass the following parameters to it: - height = h - 1. - round = r."
  },
  {
    "objectID": "delegators/bond-stake/index.html",
    "href": "delegators/bond-stake/index.html",
    "title": "Bond and unbond stake",
    "section": "",
    "text": "See the staking section to understand the concepts behind bonding and unbonding."
  },
  {
    "objectID": "delegators/bond-stake/index.html#prerequisites",
    "href": "delegators/bond-stake/index.html#prerequisites",
    "title": "Bond and unbond stake",
    "section": "Prerequisites",
    "text": "Prerequisites\n    \n    A running instance of aut configured to submit a transaction from your account.\n    An account that has been funded with auton to pay for transaction gas costs.\n    A Newton stake token balance &gt;= to the amount being bonded."
  },
  {
    "objectID": "delegators/bond-stake/index.html#discover-registered-validators",
    "href": "delegators/bond-stake/index.html#discover-registered-validators",
    "title": "Bond and unbond stake",
    "section": "Discover registered validators",
    "text": "Discover registered validators\n    The validator command is used for operations that interact with validators.\n    The current set of registered validators in the Autonity network can be queried using the list subcommand:\n    aut validator list\n    0x32F3493Ef14c28419a98Ff20dE8A033cf9e6aB97\n0x31870f96212787D181B3B2771F58AF2BeD0019Aa\n0x6EBb5A45728be7Cd9fE9c007aDD1e8b3DaFF6B3B\n0xb3A3808c698d82790Ac52a42C05E4BCb3dfCd3db\n0x467D99EA9DACC495E6D1174b8f3Dd20DDd531335\n0x1114fE559b302403BB3a89806bC08F7fA5299E99\n0x9fd408Bdb83Be1c8504Ff13eBcCe7f490DCCC2cF\n0xE03D1DE3A2Fb5FEc85041655F218f18c9d4dac55\n0x52b89AFA0D1dEe274bb5e4395eE102AaFbF372EA\n    Details about a specific validator can be queried with the info subcommand:\n    aut validator info --validator 0x9fd408Bdb83Be1c8504Ff13eBcCe7f490DCCC2cF\n{\n  \"treasury\": \"0x040803C4767A28A65e0cc15E4626DF1f7977109c\",\n  \"addr\": \"0x9fd408Bdb83Be1c8504Ff13eBcCe7f490DCCC2cF\",\n  \"enode\": \"enode://ad9972b7b23ecfc229323cd243f50c3caf980f5825a6765b102d9e28be2a760b7fd3045790246d1a5836af9a8ea5d2dbcc9b56864f6391504ab376d91d99b13e@77.68.90.188:30303\",\n  \"commission_rate\": 1000,\n  \"bonded_stake\": 95,\n  \"total_slashed\": 0,\n  \"liquid_contract\": \"0x7A4C3b88B944fA2702F19625e9A38107FcbE1db8\",\n  \"liquid_supply\": 95,\n  \"registration_block\": 5657271,\n  \"state\": 0\n}\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If you interact with a specific validator very frequently, you might consider making it the default by adding an entry such as\n    validator=0x9fd408Bdb83Be1c8504Ff13eBcCe7f490DCCC2cF\n    to your .autrc file.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    As described in Committee member selection the set of validators in the consensus committee is changed at every block epoch. Voting power changes caused by bonding and unbonding stake to a validator are applied at the end of an epoch before the committee selection algorithm for the next epoch’s committee is run.\n    To get the validators in the current consensus committee use the protocol command get-committee to call:\n    aut protocol get-committee"
  },
  {
    "objectID": "delegators/bond-stake/index.html#bond-newton-to-validator",
    "href": "delegators/bond-stake/index.html#bond-newton-to-validator",
    "title": "Bond and unbond stake",
    "section": "Bond Newton to validator",
    "text": "Bond Newton to validator\n    The aut validator bond command creates a transaction that bonds the caller’s newton to a specific validator.\n    aut validator bond --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt; &lt;AMOUNT&gt; | aut tx sign - | aut tx send -\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Bonding requests are not processed until the end of the current epoch. The Newton to be bonded will be deducted from your balance, but your liquid newton balance will not be affected until the epoch end.\n    (Pending and historical bonding requests can be discovered by listening for NewBondingRequest events emitted by the bond() function.)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Remember to verify your chosen validator is in an active state before attempting to bond stake to it. I.e. when you call aut validator info it returns \"state\": 0. If you attempt to bond stake to a validator in an inactive state, then the transaction will revert and a BondingRejected event is emitted by the bond() function."
  },
  {
    "objectID": "delegators/bond-stake/index.html#unbond-newton-from-validator",
    "href": "delegators/bond-stake/index.html#unbond-newton-from-validator",
    "title": "Bond and unbond stake",
    "section": "Unbond Newton from validator",
    "text": "Unbond Newton from validator\n    The aut validator unbond command creates a transaction that unbonds the caller’s newton from a specific validator.\n    aut validator unbond --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt; &lt;AMOUNT&gt; | aut tx sign - | aut tx send -\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If you are a validator operator unbonding self-bonded stake, then the amount specifies Newton stake token. Otherwise, if you are unbonding delegated stake, then the amount is specifying Liquid Newton.\n    Like bonding requests, unbonding does not complete immediately. The unbonding request will only be effective after the unbonding period, rounded to the next epoch. Newton will then be returned to the caller. See the staking section for further details.\n    (Pending and historical unbonding requests can be discovered by listening for NewUnbondingRequest events emitted by the unbond() function.)"
  },
  {
    "objectID": "delegators/transfer-lntn/index.html",
    "href": "delegators/transfer-lntn/index.html",
    "title": "Transfer Liquid Newton",
    "section": "",
    "text": "To send Liquid Newton (LNTN) to another account you need:\n    \n    A running instance of aut for submitting transactions from your account configured as described in Submit a transaction from Autonity Utility Tool (aut).\n    An account funded with auton to pay for transaction gas costs, and a Liquid Newton stake token balance &gt;= to the amount being transferred.\n    You have already bonded stake to one or more validators and so have Liquid Newton token balance(s)."
  },
  {
    "objectID": "delegators/transfer-lntn/index.html#prerequisites",
    "href": "delegators/transfer-lntn/index.html#prerequisites",
    "title": "Transfer Liquid Newton",
    "section": "",
    "text": "To send Liquid Newton (LNTN) to another account you need:\n    \n    A running instance of aut for submitting transactions from your account configured as described in Submit a transaction from Autonity Utility Tool (aut).\n    An account funded with auton to pay for transaction gas costs, and a Liquid Newton stake token balance &gt;= to the amount being transferred.\n    You have already bonded stake to one or more validators and so have Liquid Newton token balance(s)."
  },
  {
    "objectID": "delegators/transfer-lntn/index.html#get-liquid-newton-holdings",
    "href": "delegators/transfer-lntn/index.html#get-liquid-newton-holdings",
    "title": "Transfer Liquid Newton",
    "section": "Get Liquid Newton holdings",
    "text": "Get Liquid Newton holdings\n    Before transferring LNTN, verify your liquid newton holdings and the liquid newton contract address of the validator-specific stake delegation you are transferring LNTN from.\n    \n    To return a listing of your current LNTN holdings for all of your stake delegations, use the account command lntn-balances to call:\n    aut account lntn-balances\n    It will return an array of the liquid newton holdings for your account.\n    You should see something like beneath. In this example, the calling account has staked a single validator whose identifier address 0xA9F070101236476fe077F4A058C0C22E81b8A6C9 and has a liquid newton holding of 9901:\n    aut account lntn-balances\n{\n    \"0xA9F070101236476fe077F4A058C0C22E81b8A6C9\": 9901\n}\n    To return the liquid newton contract address of a validator, use the validator command info to submit a call to query for validator metadata. Specify:\n    \n    &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt;: the validator identifier address of the validator you are querying for.\n    \n    It will return the validator metadata from system state, including the liquid newton contract address:\n    aut validator info --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt;\n    You should see something like beneath. In this example, the liquid newton contract address is 0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37:\n    aut validator info --validator 0xA9F070101236476fe077F4A058C0C22E81b8A6C9\n{\n    \"treasury\": \"0x11A87b260Dd85ff7189d848Fd44b28Cc8505fa9C\",\n    \"addr\": \"0xA9F070101236476fe077F4A058C0C22E81b8A6C9\",\n    \"enode\": \"enode://11e025123dc489f30c26f2f46cef177de2c72d07c3b0f6aa948a2575e2b4be362b8098c14ec4720e4e46daceb390caeb1ad273f3adbfca8c4150e58c0c71f24b@51.89.151.55:30303\",\n    \"commission_rate\": 1000,\n    \"bonded_stake\": 9901,\n    \"total_slashed\": 0,\n    \"liquid_contract\": \"0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37\",\n    \"liquid_supply\": 9901,\n    \"registration_block\": 0,\n    \"state\": 0\n}"
  },
  {
    "objectID": "delegators/transfer-lntn/index.html#transfer-liquid-newton-to-another-account",
    "href": "delegators/transfer-lntn/index.html#transfer-liquid-newton-to-another-account",
    "title": "Transfer Liquid Newton",
    "section": "Transfer Liquid Newton to another account",
    "text": "Transfer Liquid Newton to another account\n    \n    To transfer an amount of LNTN to another account, use the tx command make, passing in as arguments:\n    \n    \n    --to: &lt;RECIPIENT_ACCOUNT_ADDRESS&gt;the recipient account address.\n    --token: &lt;LIQUID_CONTRACT&gt; the liquid newton contract address of the validator-specific stake delegation you are transferring LNTN from; returned from Step 2 above in the liquid_contract property.\n    --value: &lt;AMOUNT&gt; the amount of LNTN you are transferring to the to account.\n    aut tx make --to &lt;RECIPIENT_ACCOUNT_ADDRESS&gt; --token &lt;LIQUID_CONTRACT&gt; --value &lt;AMOUNT&gt; | aut tx sign - | aut tx send -\n    You will be prompted for your passphrase for the key file. Having entered the password, the transaction hash will be returned on success.\n    You should see something like beneath. In this example, the liquid newton holder transfers 111 LNTN from their account validator liquid newton contract address 0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37 to the recipient address 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4. The returned hash is 0x0aee45...29c67725:\n    aut tx make --to 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 --token 0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37 --value 111 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x0aee457755874ff776e36ec2d76955fcd4856d6753d5e75e1ba125d029c67725\n    \n    ::: {.callout-note title=“Note” collapse=“false”}The Liquid Newton contract is ERC20 so you can also transfer LNTN using the ERC20 transfer command in the token command group.\n    If using transfer, pass in as arguments:\n    \n    --token: &lt;LIQUID_CONTRACT&gt; the liquid newton contract address of the validator-specific stake delegation you are transferring LNTN from; returned from Step 2 above in the liquid_contract property.\n    RECIPIENT: the recipient account address.\n    AMOUNT: &lt;AMOUNT&gt; the amount of LNTN you are transferring to the to account. The AMOUNT is specified in decimal notation if fractional.\n    aut token transfer --token &lt;LIQUID_CONTRACT&gt;  &lt;RECIPIENT_ACCOUNT_ADDRESS&gt; &lt;AMOUNT&gt;  | aut tx sign - | aut tx send -\n    :::"
  },
  {
    "objectID": "delegators/claim-rewards/index.html",
    "href": "delegators/claim-rewards/index.html",
    "title": "Claim Staking Rewards",
    "section": "",
    "text": "To claim staking rewards you need:\n    \n    A running instance of aut for submitting transactions from your account configured as described in Submit a transaction from Autonity Utility Tool (aut)\n    An account funded with auton to pay for transaction gas costs, and a Newton stake token balance &gt;= to the amount being bonded.\n    You have already bonded stake to a validator and have a Liquid Newton token balance that may have accrued claimable rewards."
  },
  {
    "objectID": "delegators/claim-rewards/index.html#prerequisites",
    "href": "delegators/claim-rewards/index.html#prerequisites",
    "title": "Claim Staking Rewards",
    "section": "",
    "text": "To claim staking rewards you need:\n    \n    A running instance of aut for submitting transactions from your account configured as described in Submit a transaction from Autonity Utility Tool (aut)\n    An account funded with auton to pay for transaction gas costs, and a Newton stake token balance &gt;= to the amount being bonded.\n    You have already bonded stake to a validator and have a Liquid Newton token balance that may have accrued claimable rewards."
  },
  {
    "objectID": "delegators/claim-rewards/index.html#get-reward-balance",
    "href": "delegators/claim-rewards/index.html#get-reward-balance",
    "title": "Claim Staking Rewards",
    "section": "Get claimable reward balance",
    "text": "Get claimable reward balance\n    \n    To return the current balance of your claimable rewards for a validator, use the unclaimed-rewards command to submit a call to query for claimable rewards. Specify:\n    \n    &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt;: the validator identifier address of the validator you are querying for your claimable rewards balance.\n    \n    It will return the amount of staking rewards you have available to claim, denominated in ton:\n    aut validator unclaimed-rewards --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt;\n    You should see something like beneath. In this example, claimable rewards are 259885349961020:\n    aut validator unclaimed-rewards --validator 0xA9F070101236476fe077F4A058C0C22E81b8A6C9\n259885349961020"
  },
  {
    "objectID": "delegators/claim-rewards/index.html#claim-rewards",
    "href": "delegators/claim-rewards/index.html#claim-rewards",
    "title": "Claim Staking Rewards",
    "section": "Claim staking rewards",
    "text": "Claim staking rewards\n    \n    To claim rewards from a validator, submit a claim-rewards transaction. Specify:\n    \n    &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt;: the validator identifier address of the validator you are querying for your claimable rewards balance.\n    \n    aut validator claim-rewards --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt; | aut tx sign - | aut tx send -\n    You will be prompted for your passphrase for the key file. Having entered the password, the transaction hash will be returned on success.\n    You should see something like beneath. In this example, the returned hash is rewards are 0xb0daf5...a6bcf12d:\n    aut validator claim-rewards --validator 0xA9F070101236476fe077F4A058C0C22E81b8A6C9 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit):\n0xb0daf5a584d192ab5e38940bac38acf672507fa7322f60ef7a6bd59ca6bcf12d"
  },
  {
    "objectID": "delegators/claim-rewards/index.html#claim-costs",
    "href": "delegators/claim-rewards/index.html#claim-costs",
    "title": "Claim Staking Rewards",
    "section": "Claim costs",
    "text": "Claim costs\n    Note that claiming rewards is a state-affecting transaction that incurs gas costs. After claiming rewards, the user’s auton balance will only increase by amount of rewards claimed - claim transaction cost. Fees should not be claimed until the gain outweighs the cost! The gas cost of a claim transaction can be calculated simply as gas used by transaction * gas price per unit of gas.\n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    See also the How to Transfer Liquid Newton."
  },
  {
    "objectID": "delegators/index.html",
    "href": "delegators/index.html",
    "title": "Staking",
    "section": "",
    "text": "Staking is the process of locking up Newton tokens to help secure the network. In return, the staker (or delegator) earns a proportion of the network transaction fees paid by users of the blockchain. See the Staking and System model sections of this document for further information about the role of staking in the Autonity network.\n    The steps in this section describe how to carry out operations related to staking. It is assumed that you have setup the Autonity Utility Tool aut, have an account that is funded and is able to submit transactions to the network. See the Account Holder Guide for details."
  },
  {
    "objectID": "reference/api/aut/op-prot/index.html",
    "href": "reference/api/aut/op-prot/index.html",
    "title": "Governance and Protocol Only Reference",
    "section": "",
    "text": "Functions with the onlyOperator access constraint that can only be called by the governance operator account.\n    \n    \n    Burns the specified amount of Newton stake token from an account. When x amount of newton is burned, then x is simply deducted from the account’s balance and from the total supply of newton in circulation.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _addr\n    address\n    the account address from which newton is being burned\n    \n    \n    _amount\n    uint256\n    a positive integer value for the value amount being burned, denominated in Newton\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The new Newton balance of the account can be retrieved from state by calling the balanceOf() method.\n    The new total supply of Newton in circulation can be retrieved from state by calling the totalSupply() method.\n    \n    \n    \n    On a successful call the function emits a BurnedStake event, logging: _addr, _amount.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol burn [OPTIONS] AMOUNT ACCOUNT\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol burn 1 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x3e86062cca9fa263acb7076f8287117e9ee2c5570e0f4e4bd2ff4db21895796e\n    \n    \n    \n    \n    \n    \n    \n    Mints new stake token and adds it to the recipient’s account balance. When x amount of newton is minted, then x is simply added to the account’s balance and to the total supply of newton in circulation.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _addr\n    address\n    the recipient account address\n    \n    \n    _amount\n    uint256\n    a positive integer value for the value amount being minted, denominated in Newton\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The new Newton balance of the recipient account can be retrieved from state by calling the balanceOf() method.\n    The new total supply of newton in circulation can be retrieved from state by calling the totalSupply() method.\n    \n    \n    \n    On a successful call the function emits a MintedStake event, logging: _addr, _amount.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol mint [OPTIONS] AMOUNT RECIPIENT\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol mint 1 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xbd9e604372cc922c4594b0fce94919f933734e29b0043c5af3c4a7774ed99ad7\n    \n    \n    \n    \n    \n    \n    \n    The Auton mint function, called by the Stabilization Contract to mint Auton to recipients while processing a CDP borrowing.\n    The protocol calls the function using by the stabilizer account, the Stabilization Contract address The recipient cannot be the stabilizer account or the 0 zero address. The minted amount cannot be equal to 0 or greater than the Supply Control Contract’s available auton balance.\n    When x amount of auton is minted, then x is simply added to the account’s balance, increasing the total supply of Auton in circulation and reducing the supply of Auton available for minting.\n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    recipient\n    address\n    the recipient account address\n    \n    \n    amount\n    uint256\n    amount of Auton to mint (non-zero)\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The new Auton balance of the recipient account can be returned from state using aut to Get the auton balance.\n    The new total supply of auton available for minting can be retrieved from state by calling the availableSupply() method.\n    \n    \n    \n    On a successful call the function emits a Mint event, logging: recipient, amount.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The ASM Supply Control Contract Interface is not currently supported by aut.\n    You can interact with the contract using the aut contract command group. See aut contract tx -h for how to submit a transaction calling the interface function.\n    \n    \n    \n    \n    \n    \n    \n    Modifies the ACU symbols, quantities, or scale of the ACU currency basket.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    symbols_\n    string\n    the symbols used to retrieve prices\n    \n    \n    quantities_\n    uint256\n    the basket quantity corresponding to each symbol\n    \n    \n    scale_\n    uint256\n    the scale for quantities and the ACU value\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The ASM ACU Contract Interface is not currently supported by aut.\n    You can interact with the contract using the aut contract command group. See aut contract tx -h for how to submit a transaction calling the interface function.\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the Autonity Accountability Contract address.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _address\n    address\n    the ethereum formatted address of the Accountability Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-accountability-contract [OPTIONS] CONTRACT-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the ASM Auton Currency Unit (ACU) Contract address.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _address\n    address\n    the ethereum formatted address of the ACU Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-acu-contract [OPTIONS] CONTRACT-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the committeeSize protocol parameter.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _size\n    uint256\n    a positive integer value for the maximum committee size\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by calling the getMaxCommitteeSize() method.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-committee-size [OPTIONS] COMMITTEE_SIZE\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    $ aut protocol set-committee-size 50 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x3dbe5afbb89267b1549f735d09ac3acd6a4894eccbab8dca125497806c8fdc2d\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the epochPeriod protocol parameter.\n    The epochPeriod period value must be less than the unbondingPeriod protocol parameter.\n    Constraint checks are applied:\n    \n    if decreasing the epoch period, checks the current chain head has not already exceeded the new epoch period window: if block.number &gt;= lastEpochBlock + _period, then the transaction reverts.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _period\n    uint256\n    a positive integer value specifying the number of blocks defining the duration of an epoch on the network\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the call.\n    The updated parameter can be retrieved from state by a call to the epochPeriod() public variable.\n    \n    \n    \n    On a successful call the function emits an EpochPeriodUpdated event, logging: _period.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-epoch-period [OPTIONS] EPOCH_PERIOD\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-epoch-period 1000 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xdf3b3eb316a3070a591621d8cc450ca6d1af3a6d57a0455714b5bff72eb06b92\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the liquidationRatio protocol parameter in the ASM Stabilization Contract configuration.\n    Constraint checks are applied:\n    \n    the ratio must be less than the minimum collateralization ratio parameter.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    ratio\n    uint256\n    an integer value specifying the liquidation ratio for ASM CDP’s\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The ASM Stabilization Contract Interface is not currently supported by aut.\n    You can interact with the contract using the aut contract command group. See aut contract tx -h for how to submit a transaction calling the interface function.\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the minCollateralizationRatio protocol parameter in the ASM Stabilization Contract configuration\n    Constraint checks are applied:\n    \n    the ratio must be a positive value\n    the ratio must be greater than the liquidation ratio\n    minimum collateralization ratio parameter.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    ratio\n    uint256\n    a positive integer value specifying the minimum collateralization ratio for ASM CDP’s\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The ASM Stabilization Contract Interface is not currently supported by aut.\n    You can interact with the contract using the aut contract command group. See aut contract tx -h for how to submit a transaction calling the interface function.\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the minDebtRequirement protocol parameter in the ASM Stabilization Contract configuration.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    amount\n    uint256\n    an integer value specifying the minimum debt requirement for ASM CDP’s\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The ASM Stabilization Contract Interface is not currently supported by aut.\n    You can interact with the contract using the aut contract command group. See aut contract tx -h for how to submit a transaction calling the interface function.\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the minBaseFee protocol parameter. The value is denominated in ton.\n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _price\n    uint256\n    a positive integer value for the minimum gas price, denominated in ton\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by calling the getMinimumBaseFee() method.\n    \n    \n    \n    On a successful call the function emits a MinimumBaseFeeUpdated event, logging: _price.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-minimum-base-fee [OPTIONS] base-fee\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-minimum-base-fee 50000000 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x4d1abc6881f63d7856b3b2d6f0b9865a4a9c2b1378dd824e36e9ac194fd8da52\n    \n    \n    \n    \n    \n    \n    \n    Sets a new governance account address as the protocol parameter for the Autonity Protocol Contracts:\n    \n    Autonity Protocol Contract\n    Autonity Oracle Contract\n    ASM ACU Contract\n    ASM Supply Control Contract\n    ASM Stabilization Contract\n    upgradeManagerContract.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _account\n    address\n    the ethereum formatted address of the operator governance account\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by a call to the operatorAccount() public variable.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-operator-account [OPTIONS] OPERATOR-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-operator-account 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xee513f48b4ad4cd24cfc5bb0fe0c1402a5e03ae030b6c73824bae253f56efd51\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the Autonity Oracle Contract address.\n    The Oracle Contract is called by the Autonity Protocol Contracts:\n    \n    Autonity Protocol Contract\n    ASM ACU Contract\n    ASM Stabilization Contract.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _address\n    address\n    the ethereum formatted address of the Oracle Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-oracle-contract [OPTIONS] CONTRACT-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the ASM Stabilization Contract address.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _address\n    address\n    the ethereum formatted address of the Stabilization Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-stabilization-contract [OPTIONS] CONTRACT-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the ASM Supply Control Contract address.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    supplyControl\n    address\n    the ethereum formatted address of the Supply Control Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-supply-control-contract [OPTIONS] CONTRACT-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value set for the currency pair symbols for which the Oracle Contract computes median price.\n    Note that the function overwrites the existing symbols; and does not update; the complete set of symbols for which oracles shall provide price reports must be provided.\n    Constraint checks are applied:\n    \n    the _symbols parameter cannot be empty; new symbols are provided\n    the current round number is not equal to the current symbol update (a) round number, and (b) round number +1.\n    \n    The symbol update is applied and oracle submissions for the new symbols are effective from the next round round+1.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    symbols\n    string array\n    a comma-separated list of the new currency pair symbols for which price reports are generated\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    On a successful call the function emits a NewSymbols event, logging: a string array of the new currency pair _symbol and the following round number at which the new symbols become effective round+1.\n    \n    \n    \n    \n    aut\n    \n    \n    aut contract tx --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D setSymbols '[\"_symbol\"]' | aut tx sign - | aut tx send -\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut contract tx --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D setSymbols '[\"AUD-USD\", \"CAD-USD\", \"EUR-USD\", \"GBP-USD\", \"JPY-USD\", \"SEK-USD\", \"ATN-USD\", \"NTN-USD\", \"NTN-ATN\"]' | aut tx sign - | aut tx send -\n    \n    \n    \n    \n    \n    \n    \n    Sets a new account address as the value of the treasuryAccount protocol parameter.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _account\n    address payable\n    the ethereum formatted address of the Autonity Treasury Account for community funds\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by a call to config() to get the Autonity network configuration.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-treasury-account [OPTIONS] treasury-address\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-treasury-account 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xffe8725f6988668700896f335ecb5db75bb48c9dfb7caef90acecef85d0a2520\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the treasuryFee protocol parameter.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _treasuryFee\n    uint256\n    a positive integer value specifying the percentage fee levied on staking rewards before redistribution\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by a call to config() to get the Autonity network configuration.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-treasury-fee [OPTIONS] TREASURY-FEE\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-treasury-fee 100000000 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x513f36338720545a8f2c1111e0c2f4b5eebe9582e39493c6cd587ababe1e2e08\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the unbondingPeriod protocol parameter. The unbonding period specifies the length of time that bonded stake must wait before it can be redeemed for Newton after processing a stake redeem transaction. The period of time is defined as a number of blocks.\n    The unbondingPeriod period value must be greater than the epochPeriod protocol parameter. When the last block of an epoch is finalised, logic checks if the unbonding period for any pending unbonding requests for unbonding has expired and if so applies the staking transitions.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _period\n    uint256\n    a positive integer value specifying the number of blocks defining the duration of an unbonding period\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by a call to config() to get the Autonity network configuration.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-unbonding-period [OPTIONS] UNBONDING_PERIOD\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-unbonding-period 1000 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x1057bf2525ee910b393ea8d54d0ec9b362355e5dbeb14235ed5eba92750a4bdd\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the Upgrade Manager Contract address.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    This is a development function only used for internal testing purposes. A value other than 0x3C368B86AF00565Df7a3897Cfa9195B9434A59f9 will break the upgrade function.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    UpgradeManager\n    _address\n    the ethereum formatted address of the Upgrade Manager Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    Provides new contract creation code for an Autonity Protocol Contract.\n    The function calls an in-protocol EVM replace mechanism. The contract creation code is compiled and the new contract bytecode and abi appended to the contract storage buffer.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The contract storage buffer length is checked during block finalization and if a contract upgrade is ready it is applied - see finalize().\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _target\n    address\n    the target contract address to be updated\n    \n    \n    _data\n    string\n    the contract creation code\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None."
  },
  {
    "objectID": "reference/api/aut/op-prot/index.html#operator-only",
    "href": "reference/api/aut/op-prot/index.html#operator-only",
    "title": "Governance and Protocol Only Reference",
    "section": "",
    "text": "Functions with the onlyOperator access constraint that can only be called by the governance operator account.\n    \n    \n    Burns the specified amount of Newton stake token from an account. When x amount of newton is burned, then x is simply deducted from the account’s balance and from the total supply of newton in circulation.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _addr\n    address\n    the account address from which newton is being burned\n    \n    \n    _amount\n    uint256\n    a positive integer value for the value amount being burned, denominated in Newton\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The new Newton balance of the account can be retrieved from state by calling the balanceOf() method.\n    The new total supply of Newton in circulation can be retrieved from state by calling the totalSupply() method.\n    \n    \n    \n    On a successful call the function emits a BurnedStake event, logging: _addr, _amount.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol burn [OPTIONS] AMOUNT ACCOUNT\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol burn 1 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x3e86062cca9fa263acb7076f8287117e9ee2c5570e0f4e4bd2ff4db21895796e\n    \n    \n    \n    \n    \n    \n    \n    Mints new stake token and adds it to the recipient’s account balance. When x amount of newton is minted, then x is simply added to the account’s balance and to the total supply of newton in circulation.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _addr\n    address\n    the recipient account address\n    \n    \n    _amount\n    uint256\n    a positive integer value for the value amount being minted, denominated in Newton\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The new Newton balance of the recipient account can be retrieved from state by calling the balanceOf() method.\n    The new total supply of newton in circulation can be retrieved from state by calling the totalSupply() method.\n    \n    \n    \n    On a successful call the function emits a MintedStake event, logging: _addr, _amount.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol mint [OPTIONS] AMOUNT RECIPIENT\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol mint 1 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xbd9e604372cc922c4594b0fce94919f933734e29b0043c5af3c4a7774ed99ad7\n    \n    \n    \n    \n    \n    \n    \n    The Auton mint function, called by the Stabilization Contract to mint Auton to recipients while processing a CDP borrowing.\n    The protocol calls the function using by the stabilizer account, the Stabilization Contract address The recipient cannot be the stabilizer account or the 0 zero address. The minted amount cannot be equal to 0 or greater than the Supply Control Contract’s available auton balance.\n    When x amount of auton is minted, then x is simply added to the account’s balance, increasing the total supply of Auton in circulation and reducing the supply of Auton available for minting.\n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    recipient\n    address\n    the recipient account address\n    \n    \n    amount\n    uint256\n    amount of Auton to mint (non-zero)\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The new Auton balance of the recipient account can be returned from state using aut to Get the auton balance.\n    The new total supply of auton available for minting can be retrieved from state by calling the availableSupply() method.\n    \n    \n    \n    On a successful call the function emits a Mint event, logging: recipient, amount.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The ASM Supply Control Contract Interface is not currently supported by aut.\n    You can interact with the contract using the aut contract command group. See aut contract tx -h for how to submit a transaction calling the interface function.\n    \n    \n    \n    \n    \n    \n    \n    Modifies the ACU symbols, quantities, or scale of the ACU currency basket.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    symbols_\n    string\n    the symbols used to retrieve prices\n    \n    \n    quantities_\n    uint256\n    the basket quantity corresponding to each symbol\n    \n    \n    scale_\n    uint256\n    the scale for quantities and the ACU value\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The ASM ACU Contract Interface is not currently supported by aut.\n    You can interact with the contract using the aut contract command group. See aut contract tx -h for how to submit a transaction calling the interface function.\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the Autonity Accountability Contract address.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _address\n    address\n    the ethereum formatted address of the Accountability Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-accountability-contract [OPTIONS] CONTRACT-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the ASM Auton Currency Unit (ACU) Contract address.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _address\n    address\n    the ethereum formatted address of the ACU Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-acu-contract [OPTIONS] CONTRACT-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the committeeSize protocol parameter.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _size\n    uint256\n    a positive integer value for the maximum committee size\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by calling the getMaxCommitteeSize() method.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-committee-size [OPTIONS] COMMITTEE_SIZE\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    $ aut protocol set-committee-size 50 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x3dbe5afbb89267b1549f735d09ac3acd6a4894eccbab8dca125497806c8fdc2d\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the epochPeriod protocol parameter.\n    The epochPeriod period value must be less than the unbondingPeriod protocol parameter.\n    Constraint checks are applied:\n    \n    if decreasing the epoch period, checks the current chain head has not already exceeded the new epoch period window: if block.number &gt;= lastEpochBlock + _period, then the transaction reverts.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _period\n    uint256\n    a positive integer value specifying the number of blocks defining the duration of an epoch on the network\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the call.\n    The updated parameter can be retrieved from state by a call to the epochPeriod() public variable.\n    \n    \n    \n    On a successful call the function emits an EpochPeriodUpdated event, logging: _period.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-epoch-period [OPTIONS] EPOCH_PERIOD\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-epoch-period 1000 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xdf3b3eb316a3070a591621d8cc450ca6d1af3a6d57a0455714b5bff72eb06b92\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the liquidationRatio protocol parameter in the ASM Stabilization Contract configuration.\n    Constraint checks are applied:\n    \n    the ratio must be less than the minimum collateralization ratio parameter.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    ratio\n    uint256\n    an integer value specifying the liquidation ratio for ASM CDP’s\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The ASM Stabilization Contract Interface is not currently supported by aut.\n    You can interact with the contract using the aut contract command group. See aut contract tx -h for how to submit a transaction calling the interface function.\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the minCollateralizationRatio protocol parameter in the ASM Stabilization Contract configuration\n    Constraint checks are applied:\n    \n    the ratio must be a positive value\n    the ratio must be greater than the liquidation ratio\n    minimum collateralization ratio parameter.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    ratio\n    uint256\n    a positive integer value specifying the minimum collateralization ratio for ASM CDP’s\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The ASM Stabilization Contract Interface is not currently supported by aut.\n    You can interact with the contract using the aut contract command group. See aut contract tx -h for how to submit a transaction calling the interface function.\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the minDebtRequirement protocol parameter in the ASM Stabilization Contract configuration.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    amount\n    uint256\n    an integer value specifying the minimum debt requirement for ASM CDP’s\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The ASM Stabilization Contract Interface is not currently supported by aut.\n    You can interact with the contract using the aut contract command group. See aut contract tx -h for how to submit a transaction calling the interface function.\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the minBaseFee protocol parameter. The value is denominated in ton.\n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _price\n    uint256\n    a positive integer value for the minimum gas price, denominated in ton\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by calling the getMinimumBaseFee() method.\n    \n    \n    \n    On a successful call the function emits a MinimumBaseFeeUpdated event, logging: _price.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-minimum-base-fee [OPTIONS] base-fee\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-minimum-base-fee 50000000 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x4d1abc6881f63d7856b3b2d6f0b9865a4a9c2b1378dd824e36e9ac194fd8da52\n    \n    \n    \n    \n    \n    \n    \n    Sets a new governance account address as the protocol parameter for the Autonity Protocol Contracts:\n    \n    Autonity Protocol Contract\n    Autonity Oracle Contract\n    ASM ACU Contract\n    ASM Supply Control Contract\n    ASM Stabilization Contract\n    upgradeManagerContract.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _account\n    address\n    the ethereum formatted address of the operator governance account\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by a call to the operatorAccount() public variable.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-operator-account [OPTIONS] OPERATOR-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-operator-account 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xee513f48b4ad4cd24cfc5bb0fe0c1402a5e03ae030b6c73824bae253f56efd51\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the Autonity Oracle Contract address.\n    The Oracle Contract is called by the Autonity Protocol Contracts:\n    \n    Autonity Protocol Contract\n    ASM ACU Contract\n    ASM Stabilization Contract.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _address\n    address\n    the ethereum formatted address of the Oracle Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-oracle-contract [OPTIONS] CONTRACT-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the ASM Stabilization Contract address.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _address\n    address\n    the ethereum formatted address of the Stabilization Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-stabilization-contract [OPTIONS] CONTRACT-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the ASM Supply Control Contract address.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    supplyControl\n    address\n    the ethereum formatted address of the Supply Control Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-supply-control-contract [OPTIONS] CONTRACT-ADDRESS\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value set for the currency pair symbols for which the Oracle Contract computes median price.\n    Note that the function overwrites the existing symbols; and does not update; the complete set of symbols for which oracles shall provide price reports must be provided.\n    Constraint checks are applied:\n    \n    the _symbols parameter cannot be empty; new symbols are provided\n    the current round number is not equal to the current symbol update (a) round number, and (b) round number +1.\n    \n    The symbol update is applied and oracle submissions for the new symbols are effective from the next round round+1.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    symbols\n    string array\n    a comma-separated list of the new currency pair symbols for which price reports are generated\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    On a successful call the function emits a NewSymbols event, logging: a string array of the new currency pair _symbol and the following round number at which the new symbols become effective round+1.\n    \n    \n    \n    \n    aut\n    \n    \n    aut contract tx --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D setSymbols '[\"_symbol\"]' | aut tx sign - | aut tx send -\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut contract tx --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D setSymbols '[\"AUD-USD\", \"CAD-USD\", \"EUR-USD\", \"GBP-USD\", \"JPY-USD\", \"SEK-USD\", \"ATN-USD\", \"NTN-USD\", \"NTN-ATN\"]' | aut tx sign - | aut tx send -\n    \n    \n    \n    \n    \n    \n    \n    Sets a new account address as the value of the treasuryAccount protocol parameter.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _account\n    address payable\n    the ethereum formatted address of the Autonity Treasury Account for community funds\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by a call to config() to get the Autonity network configuration.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-treasury-account [OPTIONS] treasury-address\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-treasury-account 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xffe8725f6988668700896f335ecb5db75bb48c9dfb7caef90acecef85d0a2520\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the treasuryFee protocol parameter.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _treasuryFee\n    uint256\n    a positive integer value specifying the percentage fee levied on staking rewards before redistribution\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by a call to config() to get the Autonity network configuration.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-treasury-fee [OPTIONS] TREASURY-FEE\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-treasury-fee 100000000 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x513f36338720545a8f2c1111e0c2f4b5eebe9582e39493c6cd587ababe1e2e08\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the unbondingPeriod protocol parameter. The unbonding period specifies the length of time that bonded stake must wait before it can be redeemed for Newton after processing a stake redeem transaction. The period of time is defined as a number of blocks.\n    The unbondingPeriod period value must be greater than the epochPeriod protocol parameter. When the last block of an epoch is finalised, logic checks if the unbonding period for any pending unbonding requests for unbonding has expired and if so applies the staking transitions.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _period\n    uint256\n    a positive integer value specifying the number of blocks defining the duration of an unbonding period\n    \n    \n    \n    \n    \n    \n    No response object is returned on successful execution of the method call.\n    The updated parameter can be retrieved from state by a call to config() to get the Autonity network configuration.\n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-unbonding-period [OPTIONS] UNBONDING_PERIOD\n    \n    \n    \n    \n    \n    \n    \n    aut\n    \n    \n    aut protocol set-unbonding-period 1000 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x1057bf2525ee910b393ea8d54d0ec9b362355e5dbeb14235ed5eba92750a4bdd\n    \n    \n    \n    \n    \n    \n    \n    Sets a new value for the Upgrade Manager Contract address.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    This is a development function only used for internal testing purposes. A value other than 0x3C368B86AF00565Df7a3897Cfa9195B9434A59f9 will break the upgrade function.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    UpgradeManager\n    _address\n    the ethereum formatted address of the Upgrade Manager Contract\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None.\n    \n    \n    \n    \n    Provides new contract creation code for an Autonity Protocol Contract.\n    The function calls an in-protocol EVM replace mechanism. The contract creation code is compiled and the new contract bytecode and abi appended to the contract storage buffer.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The contract storage buffer length is checked during block finalization and if a contract upgrade is ready it is applied - see finalize().\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _target\n    address\n    the target contract address to be updated\n    \n    \n    _data\n    string\n    the contract creation code\n    \n    \n    \n    \n    \n    \n    None.\n    \n    \n    \n    None."
  },
  {
    "objectID": "reference/api/aut/op-prot/index.html#protocol-only",
    "href": "reference/api/aut/op-prot/index.html#protocol-only",
    "title": "Governance and Protocol Only Reference",
    "section": "Protocol only",
    "text": "Protocol only\n    Functions with protocol contract access constraints can only be invoked by the Autonity protocol itself:\n    \n    Autonity Protocol Contract: for state finalization and committee selection\n    Autonity Stabilization Contract: for Auton mint and burn.\n    \n    \n    burn (Supply Control Contract)\n    The Auton burn function, called by the Stabilization Contract stabilizer account address to burn Auton while processing a CDP repayment.\n    Burns the specified amount of Auton, taking it out of circulation.\n    Constraint checks are applied:\n    \n    the caller is the stabilizer account, the Stabilization Contract address.\n    \n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    amount\n    uint256\n    a non-zero integer value for the value amount being burned, denominated in Auton\n    \n    \n    \n    \n    \n    Response\n    No response object is returned on successful execution of the method call.\n    \n    \n    Event\n    On a successful call the function emits a Burn event, logging: value, the amount of Auton burned.\n    \n    \n    \n    computeCommittee\n    Selects the consensus committee for the following epoch by selecting the validators with the highest amount of bonded stake.\n    The algorithm reads from the validatorList state variable to select the set of registered validators that are in an enabled state and with bonded stake greater than 0.\n    If the number of selected validators exceeds the maximum committee size, then the selected validators are sorted by bonded stake amount in ascending order. The top N where N is the maximum committee size, are then selected to be members of the consensus committee for the next epoch.\n    The consensus committee variables maintained in persistent storage are deleted and recreated:\n    \n    committee is assigned the array of new CommitteeMember’s, each CommitteeMember struct recording the validator’s account address (_addr) and bonded stake amount (votingPower)\n    committeeNodes is assigned the array of enode URL’s for the committee members\n    epochTotalBondedStake is assigned the total amount of the stake bonded to the committee members.\n    \n    Constraint checks:\n    \n    validatorList.length &gt; 0. A committee cannot be selected without registered validators.\n    ValidatorState = 0 (i.e. active). Validators must be in an active state to be included in the selection algorithm (validators in a paused, jailed, or jailbound state are excluded).\n    bondedStake &gt; 0. Validators must have a non-zero amount of bonded stake to be included in the selection algorithm.\n    \n    \n    Parameters\n    None.\n    \n    \n    Response\n    No response object is returned on successful execution of the method invocation.\n    The new committee can be retrieved from state by calling the getCommittee() method.\n    The new committee enode URL’s can be retrieved from state by calling the getCommitteeEnodes() method.\n    Returns the amount of stake token bonded to the new consensus committee members and securing the network during the epoch can be retrieved from state by a call to the epochTotalBondedStake() method.\n    \n    \n    \n    distributeRewards (Accountability Contract)\n    The Accountability Contract reward distribution function, called at epoch finalisation as part of the state finalisation function finalize.\n    The function:\n    \n    distributes rewards for reporting provable faults committed by an offending validator to the reporting validator.\n    if multiple slashing events are committed by the same offending validator during the same epoch, then rewards are only distributed to the last reporter.\n    if funds can’t be transferred to the reporter’s treasury account, then rewards go to the autonity protocol treasury account for community funds (see also Protocol Parameters Reference).\n    \n    After distribution, the reporting validator is removed from the beneficiaries array.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _validator\n    address\n    the address of the validator node being slashed\n    \n    \n    \n    \n    \n    Response\n    None.\n    \n    \n    Event\n    None.\n    \n    \n    \n    finalize\n    The block finalisation function, invoked each block after processing every transaction within it. The function:\n    \n    tests if the bytecode protocol parameter is 0 length to determine if an Autonity Protocol Contract upgrade is available. If the bytecode length is &gt;0, the contractUpgradeReady protocol parameter is set to true\n    tests if the block number is the last epoch block number (equal to lastEpochBlock + epochPeriod config) and if so sets the epochEnded boolean variable to true or false accordingly\n    invokes the Accountability Contract finalize() function, triggering the Accountability Contract to compute and apply penalties for provable accountability and omission faults committed by validators, and distribute rewards for submitting provable fault accusations\n    then, if epochEnded is true:\n    \n    performs the staking rewards redistribution, redistributing the available reward amount per protocol and emitting a Rewarded event for each distribution\n    applies any staking transitions - pending bonding and unbonding requests tracked in BondingRequest and UnbondingRequest data structures in memory\n    applies any validator commission rate changes - pending rate change requests tracked in CommissionRateChangeRequest data structures in memory\n    selects the consensus committee for the following epoch, invoking the computeCommittee() function\n    assigns the lastEpochBlock state variable the value of the current block number\n    increments the epochID by 1\n    emits a NewEpoch event logging the epochID of the new epoch\n    \n    invokes the Oracle Contract finalize() function, triggering the Oracle Contract to check it is the end of a voting round and if so:\n    \n    calculate the median price of currency pairs\n    re-set oracle voters and parameters ready for the next oracle voting round.\n    \n    then, if the oracle has computed data and started a new voting round (newRound is true), invokes the ACU Contract update() function to recompute the ACU value using the new price data.\n    \n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    contractUpgradeReady\n    bool\n    Set to true if an Autonity Protocol Contract upgrade is available\n    \n    \n    committee\n    CommitteeMember[] array\n    the consensus committee that approved the block, each CommitteeMember struct recording the validator’s account address (_addr) and bonded stake amount (votingPower)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If an upgrade is available for a protocol contract, this is executed by the protocol at epoch finalisation. After an upgrade has been completed the new Autonity Protocol Contract version can be retrieved from state by calling the getVersion() method.\n    \n    \n    \n    \n    \n    Event\n    On successful reward distribution the function emits:\n    \n    a Rewarded event for each staking reward distribution, logging: recipient address addr and reward amount amount.\n    a NewEpoch event signalling the beginning of a new epoch, logging: unique identifier for the new epoch epochID.\n    \n    \n    \n    \n    finalize (Accountability Contract)\n    The Accountability Contract finalisation function, called at each block finalisation as part of the state finalisation function finalize(). The function checks if it is the last block of the epoch, then:\n    \n    On each block, tries to promote Accusations without proof of innocence into misconducts. Accusations without a valid innocence proof are considered guilty of the reported misconduct and a new fault proof is created if the fault severity is higher than that of any previous fault already committed by the validator in the current epoch.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    A validator can, of course, have more than one fault proven against it in an epoch. For example, a first fault is proven and then another fault for a higher severity is proven. Note that the protocol will only apply an accountability slashing to a validator for the fault with the highest severity committed in an epoch.\n    \n    \n    \n    \n    On epoch end, performs slashing tasks.\n    \n    \n    promote guilty accusations\n    Accusations are placed into an accusation queue stored in memory. For each Accusation in the queue, the protocol checks if the proof submission window for the Accusation has expired and, if so, it attempts to promote the Accusation into a misbehaviour fault. If a fault with a higher severity than the Accusation already exists for the epoch, then the Accusation is dropped. Otherwise, a new FaultProof is created from the Accusation and the slashing history of the validator is updated to record this as the highest severity fault committed in the epoch.\n    The function takes each Accusation proof from the accusations queue and:\n    \n    Checks if the proof innocence window has closed. If the window is still open, the Accusation remains in the queue. If the window has closed (the sum of the block number at which the Accusation was reported and the number of blocks in the proof innocence window is greater than the current block number (_ev.reportingBlock + INNOCENCE_PROOF_SUBMISSION_WINDOW &gt; block.number)), then the Accusation is removed from the queue (i.e. deleted) to determine if the Accusation's should be promoted to a fault.\n    Tries to promote the Accusation to a fault or discards. The slashing history of the validator is checked to see if the validator already has a proven offence (i.e. a FaultProof) for the epoch with a severity &gt;= to the Accusation. If true, then the Accusation is skipped as a FaultProof with a higher severity has already been reported during the epoch. If false, then the validator’s slashing history is updated to record the new fault as the highest severity for the epoch. A new FaultProof is created for the validator and added to the slashing queue.\n    A FaultProof event is emitted logging the event.\n    \n    The reported validator will be silenced and slashed for the fault at the end of the current epoch.\n    \n    \n    perform slashing tasks\n    For each fault the protocol performs slashing over faulty validators at the end of an epoch.\n    The function checks the total number of faults committed by all validators in the epoch, counting the number of fault proofs in the slashing queue, to quantify validator collusion. It then applies slashing for each fault in the slashing queue:\n    \n    Computes the slashing. The slashing rate and amount are computed taking into account the number of fault offences committed in the epoch by the offending validator and all validators globally. The slashing amount is calculated by the formula (slashing rate * validator bonded stake)/slashing rate precision.\n    Applies the slashing penalty. Slashing is applied to the offending validator’s stake, subtracting the slashing amount from the validator’s bonded stake according to the protocol’s Penalty Absorbing Stake (PAS) model (self-bonded stake before delegated stake)\n    Computes the jail period of the offending validator. If the validator stake slashing is 100% of bonded stake, permanent validator jailing is applied and the validator state is set to jailbound. Else, jailing is temporary and a jail period is calculated, using the formula current block number + jail factor * proven offence fault count * epoch period to compute a jail release block number. The validator state is set to jailed.\n    Updates validator state. The validator’s proven fault counter is incremented by 1 to record the slashing occurrence in the validator’s reputational slashing history. The jail release block number is recorded, set to the computed value if jailed or set to 0 if jailbound. Bonded stake amounts are adjusted for the slashing amount and the slashed stake token are transferred to the Autonity Protocol global treasury account for community funding.\n    Updates global slashing state. The pending slashing fault queue is reset ready for the next epoch, and the reporting validator is added to the array of reward beneficiaries that will receive rewards for offence reporting\n    A SlashingEvent event is emitted for each validator that has been slashed.\n    \n    Rewards for fault reporting are distributed to the treasury account of the reporting validator as the last block of the epoch is finalised. Reporting validator self-bonded and delegated stakeholders receive a share of the rewards pro rata to their bonded stake amount. If the rewards transfer to the validator treasury account fails, then the rewards are sent to the Autonity Protocol’s community treasury account.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The protocol adjusts the slashing rate according to the total number of fault offences committed in an epoch across all validators.\n    This mechanism applies a dynamic slashing rate mitigating collusion risk by Byzantine agents in an epoch.\n    \n    \n    \n    \n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    epochEnd\n    Bool\n    boolean value indicating if the current block is the last block of the epoch (true) or not (false)\n    \n    \n    \n    \n    \n    Response\n    None.\n    \n    \n    Event\n    The function emits events:\n    \n    on submission of a fault proof, a NewFaultProof event, logging: _offender, _severity, _id.\n    after a successful slashing, a SlashingEvent logging: _val.nodeAddress, _slashingAmount, _val.jailReleaseBlock, isJailbound.\n    \n    \n    \n    \n    finalize (Oracle Contract)\n    The Oracle Contract finalisation function, called once per VotePeriod as part of the state finalisation function finalize(). The function checks if it is the last block of the vote period, if so then:\n    \n    executes the Oracle Contract’s on-chain aggregation routine to calculate the median of all price data points for each symbol submitted to the oracle, invoking the Oracle Contract aggregateSymbol function\n    checks if there have been any oracle voter changes, if so then updates the oracle voter set for the following oracle voting round\n    resets the lastRoundBlock to the current block.number\n    increments the round counter by 1\n    checks if there have been any oracle symbol changes, if so then updates the oracle symbol set for the following oracle voting round.\n    \n    \n    Parameters\n    None.\n    \n    \n    Response\n    Returns true if there is a new voting round and new symbol prices are available, false if not.\n    \n    \n    Event\n    On success the function emits a NewRound event for the new oracle voting period, logging: round number round, block.number, block.timestamp and vote period duration votePeriod.\n    \n    \n    \n    handleEvent (Accountability Contract)\n    The accountability event handling function, invoked by protocol on submission of accountability event data to handle event processing.\n    Constraint checks are applied:\n    \n    the msg.sender caller is a registered validator identifier, else the transaction reverts. (Rewards for reporting a successful slashing event are distributed to the validator’s treasury account.)\n    the msg.sender calling the function and the slashing event reporter addresses are the same.\n    chunk segments are contiguous for oversize events that have been chunked for storage into a map. If an event’s raw proof data is above a floor byte size, then the event is chunked into 16kb size chunks and stored in a map. Chunk id’s must be contiguous; i.e. a map can only contain chunks from one and not multiple events.\n    \n    The function checks the event data:\n    \n    If the raw proof contains &gt;1 chunk, then the function stores the event into a map and then returns.\n    \n    The function then processes the event according to event type.\n    The function validates the accountability event proof, passing the event’s rawProof data to a precompiled contract for verification. The precompiled contract returns verification outcome to the method:\n    \n    _success - boolean flag indicating if proof verification succeeded or failed\n    _offender - validator identifier address of the fault offender\n    _ruleId - ID of the accountability rule tested\n    _block - number of the block in which the fault occurred\n    _messageHash - cryptographic hash of the main fault evidence, the rawProof.\n    \n    Based on the verification outcome, constraint checks are applied:\n    \n    the raw proof verification passed: _success is true\n    there are no mismatches between the event data and the verified raw proof data fields:\n    \n    the returned _offender and event offender address values match\n    the returned _ruleId and event rule identifier values match\n    \n    the_block number returned by the verification is less than the current block.number - the proof is for a historical and not future event\n    depending on event type, specific constraint checks are applied:\n    \n    if FaultProof, then:\n    \n    the severity of the fault event is greater than the severity of the offender’s current slashing history for the epoch.\n    \n    if Accusation, then:\n    \n    the severity of the fault event is greater than the severity of the offender’s current slashing history for the epoch\n    the validator does not have a pending accusation being processed.\n    \n    if InnocenceProof, then:\n    \n    the validator has an associated pending accusation being processed\n    the innocence proof and associated accusation proof have matching: rule identifiers, block number, message hash.\n    \n    \n    \n    On successful constraint checking:\n    \n    The event data object is updated using data returned by processing of the raw proof during proof verification processing:\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    block\n    uint256\n    assigned block number returned from verification in _block\n    \n    \n    epoch\n    uint256\n    assigned the identifier of the epoch in which the accountability event _block occurred\n    \n    \n    reportingBlock\n    uint256\n    assigned the current block number\n    \n    \n    messageHash\n    uint256\n    assigned the hash of the main evidence for the accountability event returned from verification in _messageHash\n    \n    \n    \n    \n    The event is added to the events queue and assigned an _eventId value reflecting its position in the event queue.\n    \n    Then, depending on event type:\n    \n    If FaultProof, then:\n    \n    The record of validator faults is updated to add the new event ID.\n    The event is added to the slashing queue.\n    The slashing history of the validator for the epoch is updated to record the fault’s severity.\n    \n    If Accusation, then:\n    \n    The event is recorded as the validator’s pending accusation.\n    The event is added to the accusation queue.\n    \n    If InnocenceProof, then:\n    \n    The accusation queue is checked and the associated accusation is removed.\n    The validator’s pending accusation is reset to 0, indicating the validator has no pending accusations (so a new accusation can now be submitted against the validator).\n    \n    \n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _event\n    Event\n    event data object\n    \n    \n    \n    On proof submission an _event object data structure is constructed in memory, populated with fields ready for proof processing:\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    chunks\n    uint8\n    counter of the number of chunks in the accountability event (for oversize accountability event)\n    \n    \n    chunkId\n    uint8\n    chunk index to construct the oversize accountability event\n    \n    \n    eventType\n    EventType\n    the accountability event type, one of: FaultProof (proven misbehaviour), Accusation (pending accusation), InnocenceProof (proven innocence)\n    \n    \n    rule\n    Rule\n    the identifier of the accountability Rule defined in the Accountability Fault Detector (AFD) rule engine. Enumerated values are defined for each AFD Rule ID.\n    \n    \n    reporter\n    address\n    the node address of the validator that reported this accountability event\n    \n    \n    offender\n    address\n    the node address of the validator accused of the accountability event\n    \n    \n    rawProof\n    bytes\n    the rlp encoded bytes of the accountability proof object\n    \n    \n    block\n    uint256\n    the number of the block at which the accountability event occurred. Assigned by protocol after proof verification.\n    \n    \n    epoch\n    uint256\n    the identifier of the epoch in which the accountability event occurred. Assigned by protocol after proof verification.\n    \n    \n    reportingBlock\n    uint256\n    the number of the block at which the accountability event was reported. Assigned by protocol after proof verification.\n    \n    \n    messageHash\n    uint256\n    hash of the main evidence for the accountability event. Assigned by protocol after proof verification.\n    \n    \n    _validator\n    address\n    the address of the validator node being slashed\n    \n    \n    \n    \n    \n    Response\n    None.\n    \n    \n    Event\n    On success the function emits events for handling of:\n    \n    Fault proof: a NewFaultProof event, logging: round _offender validator address, _severity of the fault, and _eventId.\n    Accusation proof: a NewAccusation event, logging: round _offender validator address, _severity of the fault, and _eventId.\n    Innocence proof: an InnocenceProven event, logging: _offender validator address, 0 indicating there are no pending accusations against the validator.\n    \n    \n    \n    \n    mint (Supply Control Contract)\n    The Auton mint function, called by the Stabilization Contract to mint Auton to recipients while processing a CDP borrowing.\n    Mints Auton and sends it to a recipient account, increasing the amount of Auton in circulation.\n    Constraint checks are applied:\n    \n    the caller is the stabilizer account, the Stabilization Contract address\n    invalid recipient: the recipient cannot be the stabilizer account, the Stabilization Contract address, or the 0 zero address\n    invalid amount: the amount is not equal to 0 or greater than the Supply Control Contract’s available Auton balance.\n    \n    When x amount of Auton is minted, then x is simply added to the account’s balance, increasing the total supply of Auton in circulation and reducing the supply of Auton available for minting.\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    recipient\n    address\n    the recipient account address\n    \n    \n    amount\n    uint256\n    amount of Auton to mint (non-zero)\n    \n    \n    \n    \n    \n    Response\n    No response object is returned on successful execution of the method call.\n    The new Auton balance of the recipient account can be returned from state using aut to Get the auton balance.\n    The new total supply of auton available for minting can be retrieved from state by calling the availableSupply() method.\n    \n    \n    Event\n    On a successful call the function emits a Mint event, logging: recipient, amount.\n    \n    \n    \n    update (ACU Contract)\n    The Auton Currency Unit (ACU) Contract finalization function, called once per Oracle voting round as part of the state finalization function finalize(). The function checks if the Oracle Contract finalize() has initiated a new oracle voting round, if so then:\n    \n    it retrieves the latest prices from the Oracle Contract (i.e. the latest round data)\n    checks price data completeness:\n    \n    if latest prices have been returned for all symbols in the ACU currency basket, then:\n    \n    computes the ACU index value\n    resets the round to the index number of the oracle voting round that computed the retrieved latest prices.\n    returns status of true to the calling Autonity Protocol Contract\n    \n    else if one or more prices are unavailable from the Oracle, it will not compute the ACU value for that round, and returns status of false to the calling Autonity Protocol Contract.\n    \n    \n    \n    Parameters\n    None.\n    \n    \n    Response\n    None.\n    \n    \n    Event\n    On success the function emits an Updated event for the new ACU value, logging: block.number, block.timestamp, oracle voting round number round, and the ACU index value calculated _value."
  },
  {
    "objectID": "reference/api/aut/index.html",
    "href": "reference/api/aut/index.html",
    "title": "Autonity Contract Interface",
    "section": "",
    "text": "Interface for interacting with Autonity Contract functions using:"
  },
  {
    "objectID": "reference/api/aut/index.html#activatevalidator",
    "href": "reference/api/aut/index.html#activatevalidator",
    "title": "Autonity Contract Interface",
    "section": "activateValidator",
    "text": "activateValidator\n    Changes the state of a paused validator on an Autonity Network from paused to active. (See pauseValidator method.)\n    The activateValidator method provides as argument the validator identifier address.\n    On method execution the Validator.state object data property is updated in memory and set to active.\n    Constraint checks are applied:\n    \n    the address of the validator is registered\n    the msg.sender address of the transaction is equal to the validator’s treasury address\n    the validator state must not be active; it must be paused or jailed\n    if the validator state is jailed, the validator’s jailReleaseBlock is less than the current block number at the time of the call\n    \n    Validator re-activation is executed on transaction commit. New stake delegations to the validator are accepted and the validator is included in the consensus committee selection algorithm at epoch end.\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _address\n    address\n    the validator identifier account address\n    \n    \n    \n    \n    \n    Response\n    No response object is returned on successful execution of the method call.\n    The updated state can be viewed by calling the getValidator method.\n    \n    \n    Event\n    On a successful call the function emits an ActivatedValidator event, logging: val.treasury, _address, effectiveBlock.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut validator activate --validator _address\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut validator activate --validator 0x49454f01a8F1Fbab21785a57114Ed955212006be | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n\n0x0849c0307bc446bb3fbb61b5c1518847574356aedb0b986248158d36f1eb2a5b"
  },
  {
    "objectID": "reference/api/aut/index.html#allowance",
    "href": "reference/api/aut/index.html#allowance",
    "title": "Autonity Contract Interface",
    "section": "allowance",
    "text": "allowance\n    Returns the amount of stake token that remains available for a spender to withdraw from a Newton stake token owner’s account.\n    Using aut you can return the allowance for an ERC20 token contract account, e.g. a Liquid Newton account.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    owner\n    address\n    address of a Newton stake token owner account from which a spender account has approval to transfer token\n    \n    \n    spender\n    address\n    address of an account with approval to transfer Newton stake token from a token owner’s account\n    \n    \n    \n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    amount\n    uint256\n    the amount of Newton stake token the spender is able to withdraw\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut token allowance [OPTIONS] OWNER\n    \n    \n    {\"method\": \"aut_allowance\", \"params\":[\"owner\", \"spender\"]}\n    \n    \n    \n    \n    \n    Example\n    To return a spender’s allowance for a Newton stake token account specify the --ntn option:\n    \n    autRPC\n    \n    \n    $ aut token allowance --ntn 0x11A87b260Dd85ff7189d848Fd44b28Cc8505fa9C\n100.000000000000000000\n    \n    \n    curl -X GET 'https://rpc1.bakerloo.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_allowance\", \"params\":[\"0x11A87b260Dd85ff7189d848Fd44b28Cc8505fa9C\",\"0xD9B99BAe9E9550A6Ac2F74bA7DdE483a4462C548\"], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":100}\n    \n    \n    \n    To return a spender’s allowance for an ERC20 contract token (e.g. Liquid Newton) account specify the --token option:\n    \n    aut\n    \n    \n    $ aut token allowance --token 0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37  0x11A87b260Dd85ff7189d848Fd44b28Cc8505fa9C\n1000.000000000000000000"
  },
  {
    "objectID": "reference/api/aut/index.html#approve",
    "href": "reference/api/aut/index.html#approve",
    "title": "Autonity Contract Interface",
    "section": "approve",
    "text": "approve\n    Approves a spender account to withdraw Newton stake token from the token owner’s account up to the designated amount. The amount is set as the spender’s allowance over the caller’s tokens. The owner calls the function again to set a new amount allowance.\n    Constraint checks:\n    \n    The owner cannot be the zero address\n    The spender cannot be the zero address\n    \n    Using aut you can approve a spender account allowance for an ERC20 token contract account, e.g. a Liquid Newton account.\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    spender\n    address\n    address of spender\n    \n    \n    amount\n    uint256\n    amount available\n    \n    \n    \n    \n    \n    Response\n    The method returns a boolean flag specifying whether the spender was approved or not.\n    \n    \n    Event\n    On a successful call the function emits an Approval event, logging: owner, spender, amount.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut token approve [OPTIONS] SPENDER AMOUNT\n    \n    \n    \n    \n    \n    Example\n    To approve a spender for a Newton stake token account specify the --ntn option:\n    \n    aut\n    \n    \n    aut token approve --ntn 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 100 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x715749a9aed398da7f25e66767c2ed9d3cd00c02f7306453949b9203b9a034a6\n    \n    \n    \n    To approve a spender for an ERC20 contract token (e.g. Liquid Newton) account specify the --token option:\n    \n    aut\n    \n    \n    aut token approve --token 0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 1000 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xa20ae3a75009fb967ed53897b980e6e88dd580fada133c08071183b5b452ca2c"
  },
  {
    "objectID": "reference/api/aut/index.html#balanceof",
    "href": "reference/api/aut/index.html#balanceof",
    "title": "Autonity Contract Interface",
    "section": "balanceOf",
    "text": "balanceOf\n    Returns the amount of unbonded Newton stake token held by an account.\n    Using aut you can return the account balance for an ERC20 token contract account, e.g. a Liquid Newton account.\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _addr\n    address\n    address of token account\n    \n    \n    \n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    amount\n    uint256\n    the amount of unbonded Newton token held by the account\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut token balance-of [OPTIONS] ACCOUNT\n    \n    \n    {\"method\": \"aut_balanceOf\", \"params\":[\"_addr\"]}\n    \n    \n    \n    \n    \n    Example\n    To return the Newton stake token balance for an account specify the --ntn option:\n    \n    autRPC\n    \n    \n    aut token balance-of --ntn 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4\n1000.000000000000000000\n    \n    \n    curl -X GET 'https://rpc1.bakerloo.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_balanceOf\", \"params\":[\"0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4\"], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":1000}\n    \n    \n    \n    To return an ERC20 contract token (e.g. Liquid Newton) balance for an account specify the --token option:\n    \n    aut\n    \n    \n    aut token balance-of --token 0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37 0x11a87b260dd85ff7189d848fd44b28cc8505fa9c\n999.000000000000000000\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    All Liquid Newton balances for an account can be returned in one call using the aut command aut account lntn-balances [OPTIONS] ACCOUNT."
  },
  {
    "objectID": "reference/api/aut/index.html#bond",
    "href": "reference/api/aut/index.html#bond",
    "title": "Autonity Contract Interface",
    "section": "bond",
    "text": "bond\n    Delegates an amount of Newton stake token to a designated validator. If the delegator’s msg.Sender address is the validator treasury account then the stake is self-bonded and no Liquid Newton will be issued.\n    Constraint checks:\n    \n    the validator address is registered as a validator\n    the validator state is active. A bonding operation submitted to a validator in a paused, jailed or jailbound state will revert\n    the amount is a positive integer value &gt; 0\n    the Newton balance of the account submitting the bond() method call has a Newton balance&gt;= to the amount being bonded.\n    \n    On successful processing of the method call:\n    \n    the bonded Newton amount is locked in the msg.Sender’s Newton account\n    a BondingRequest object for the necessary voting power change is created:\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    delegator\n    address payable\n    account address of the account bonding stake\n    \n    \n    delegatee\n    address\n    validator identifier account address of the validator to which stake is being bonded\n    \n    \n    amount\n    uint256\n    the amount of Newton stake token being bonded to the delegatee account\n    \n    \n    requestBlock\n    uint256\n    the block number at which a bonding transaction was committed\n    \n    \n    \n    The BondingRequest is tracked in memory until applied at epoch end. At that block point, if the stake delegation is delegated and not self-bonded, then Liquid Newton will be minted to the delegator for the bonded stake amount.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Liquid Newton is not issued for self-bonded stake. See Concept Staking and Penalty Absorbing Stake (PAS).\n    \n    \n    \n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    validator\n    address\n    the validator identifier address\n    \n    \n    amount\n    uint256\n    the amount of Newton bonded to the validator\n    \n    \n    \n    \n    \n    Response\n    No response object is returned on successful execution of the method call.\n    The pending voting power change is tracked in memory until applied.\n    \n    \n    Event\n    The function emits events:\n    \n    on success, a NewBondingRequest event, logging: validator address, delegator address, selfBonded (boolean), amount bonded.\n    on revert, a BondingRejected event, logging: delegator address, delegatee address, amount bonded, validator state.\n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut validator bond [OPTIONS] AMOUNT\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut validator bond --validator 0xA9F070101236476fe077F4A058C0C22E81b8A6C9 1 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xaa3705ef2d38cf2d98925660e6ca55de8948e8a075e7ee9edf6be7fa540ffe51"
  },
  {
    "objectID": "reference/api/aut/index.html#changecommissionrate",
    "href": "reference/api/aut/index.html#changecommissionrate",
    "title": "Autonity Contract Interface",
    "section": "changeCommissionRate",
    "text": "changeCommissionRate\n    Changes the percentage fee of staking rewards deducted by a validator as commission from delegated stake. At registration all validators have commission set to a default rate specified by the Autonity network’s genesis configuration. (See Reference Genesis, delegationRate.)\n    Validators may change commission rate at any time after registration.\n    The changeCommissionRate method provides as arguments the validator identifier address and the new commission rate expressed as basis points (bps).\n    On method execution the Validator.commissionRate object data property is updated in memory and set to the new rate.\n    Constraint checks are applied:\n    \n    the address of the validator is registered\n    the msg.sender address of the transaction is equal to the validator’s treasury address\n    the commission rate precision is correctly expressed in basis points as an integer value in the range 0-10000 (10000 = 100%).\n    \n    The rate change is applied at the next unbonding period modulo epoch.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _validator\n    address\n    the validator identifier account address\n    \n    \n    _rate\n    uint256\n    the new commission rate in basis points (bps), value range between 0-10000 (10000 = 100%)\n    \n    \n    \n    \n    \n    Response\n    No response object is returned on successful execution of the method call.\n    The updated state can be viewed by calling the getValidator method.\n    \n    \n    Event\n    On a successful call the function emits a CommissionRateChange event, logging: _validator, _rate.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut validator change-commission-rate [OPTIONS] RATE\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut validator change-commission-rate --validator 0xA9F070101236476fe077F4A058C0C22E81b8A6C9 900 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x7a4c6bb2e19eb8a4a160723b07eeb538e835db512541621aef0062cd9e1e15f2"
  },
  {
    "objectID": "reference/api/aut/index.html#config",
    "href": "reference/api/aut/index.html#config",
    "title": "Autonity Contract Interface",
    "section": "config",
    "text": "config\n    Returns the Autonity Network configuration at the block height the call was submitted.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    Returns a Config object consisting of:\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    treasuryFee\n    uint256\n    the percentage of staking rewards deducted from staking rewards and sent to the Autonity Treasury account for community funding before staking rewards are distributed\n    \n    \n    minBaseFee\n    uint256\n    the minimum gas price for a unit of gas used to compute a transaction on the network, denominated in ton\n    \n    \n    delegationRate\n    uint256\n    the percentage of staking rewards deducted by validators as a commission from delegated stake\n    \n    \n    unbondingPeriod\n    uint256\n    the period of time for which bonded stake must wait before it can be redeemed for Newton after processing a stake redeem transaction, defined as a number of blocks\n    \n    \n    treasuryAccount\n    address payable\n    the address of the Autonity Treasury account for community funds\n    \n    \n    accountabilityContract\n    address\n    the address of the Autonity Accountability Contract\n    \n    \n    oracleContract\n    address\n    the address of the Autonity Oracle Contract\n    \n    \n    acuContract\n    address\n    the address of the Autonity ASM ACU Contract\n    \n    \n    supplyControlContract\n    address\n    the address of the Autonity ASM Supply Control Contract\n    \n    \n    stabilizationContract\n    address\n    the address of the Autonity ASM Stabilization Contract\n    \n    \n    operatorAccount\n    address\n    the address of the Autonity governance account\n    \n    \n    epochPeriod\n    uint256\n    the period of time for which a consensus committee is elected, defined as a number of blocks\n    \n    \n    blockPeriod\n    uint256\n    the minimum time interval between two consecutive blocks, measured in seconds\n    \n    \n    committeeSize\n    uint256\n    the maximum number of validators that may be members of a consensus committee on the network\n    \n    \n    contractVersion\n    uint256\n    the version number of the Autonity Protocol Contract. An integer value set by default to 1 and incremented by 1 on contract upgrade\n    \n    \n    \n    \n    \n    Usage\n    \n    RPC\n    \n    \n    {\"method\":\"aut_config\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol config -r https://rpc1.piccadilly.autonity.org\n{\n  \"policy\": {\n    \"treasury_fee\": 10000000000000000,\n    \"min_basefee\": 500000000,\n    \"delegation_rate\": 1000,\n    \"unbonding_period\": 21600,\n    \"treasury_account\": \"0xF74c34Fed10cD9518293634C6f7C12638a808Ad5\"\n  },\n  \"contracts\": {\n    \"accountability_contract\": \"0x5a443704dd4B594B382c22a083e2BD3090A6feF3\",\n    \"oracle_contract\": \"0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D\",\n    \"acu_contract\": \"0x8Be503bcdEd90ED42Eff31f56199399B2b0154CA\",\n    \"supply_control_contract\": \"0x47c5e40890bcE4a473A49D7501808b9633F29782\",\n    \"stabilization_contract\": \"0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f\"\n  },\n  \"protocol\": {\n    \"operator_account\": \"0xd32C0812Fa1296F082671D5Be4CbB6bEeedC2397\",\n    \"epoch_period\": 1800,\n    \"block_period\": 1,\n    \"committee_size\": 100\n  },\n  \"contract_version\": 1\n}\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_config\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":[{\"treasuryFee\":10000000000000000,\"minBaseFee\":500000000,\"delegationRate\":1000,\"unbondingPeriod\":21600,\"treasuryAccount\":\"0xf74c34fed10cd9518293634c6f7c12638a808ad5\"},{\"accountabilityContract\":\"0x5a443704dd4b594b382c22a083e2bd3090a6fef3\",\"oracleContract\":\"0x47e9fbef8c83a1714f1951f142132e6e90f5fa5d\",\"acuContract\":\"0x8be503bcded90ed42eff31f56199399b2b0154ca\",\"supplyControlContract\":\"0x47c5e40890bce4a473a49d7501808b9633f29782\",\"stabilizationContract\":\"0x29b2440db4a256b0c1e6d3b4cdcaa68e2440a08f\"},{\"operatorAccount\":\"0xd32c0812fa1296f082671d5be4cbb6beeedc2397\",\"epochPeriod\":1800,\"blockPeriod\":1,\"committeeSize\":100},1]}"
  },
  {
    "objectID": "reference/api/aut/index.html#deployer",
    "href": "reference/api/aut/index.html#deployer",
    "title": "Autonity Contract Interface",
    "section": "deployer",
    "text": "deployer\n    Returns the address of the account deploying the contract. The address is used to restrict access to functions that can only be invoked by the protocol (the msg.sender of a transaction is checked against the deployer address by the onlyProtocol access modifier), bypassing transaction processing and signature verification. It is set to the zero address.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    address\n    the address of the account deploying the Autonity contract\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol deployer [OPTIONS]\n    \n    \n    {\"method\":\"aut_deployer\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol deployer --rpc-endpoint https://rpc1.piccadilly.autonity.org\n0x0000000000000000000000000000000000000000\n    \n    \n    curl -X GET 'https://rpc1.bakerloo.autonity.org/'  --header 'Content-Type: application/json' --data '{\"method\":\"aut_deployer\", \"params\":[], \"jsonrpc\":\"2.0\", \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"0x0000000000000000000000000000000000000000\"}"
  },
  {
    "objectID": "reference/api/aut/index.html#epochid",
    "href": "reference/api/aut/index.html#epochid",
    "title": "Autonity Contract Interface",
    "section": "epochID",
    "text": "epochID\n    Returns the unique identifier of a block epoch as an integer value.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    uint256\n    the identifier of a block epoch. Initial value is 0.\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol epoch-id [OPTIONS]\n    \n    \n    {\"method\":\"aut_epochID\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol epoch-id --rpc-endpoint https://rpc1.bakerloo.autonity.org\n7371\n    \n    \n    curl -X GET 'https://rpc1.bakerloo.autonity.org/'  --header 'Content-Type: application/json' --data '{\"method\":\"aut_epochID\", \"params\":[], \"jsonrpc\":\"2.0\", \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":7371}"
  },
  {
    "objectID": "reference/api/aut/index.html#epochreward",
    "href": "reference/api/aut/index.html#epochreward",
    "title": "Autonity Contract Interface",
    "section": "epochReward",
    "text": "epochReward\n    Returns the amount of Auton transaction fees available for distribution as staking rewards for stake bonded to validators in the consensus committee at the block height of the call. Actual reward distribution takes place as the last block of an epoch is finalised.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    uint256\n    the amount of Auton transaction fees available for distribution to consensus committee members at the block height of the call\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol epoch-reward [OPTIONS]\n    \n    \n    {\"method\":\"aut_epochReward\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol epoch-reward --rpc-endpoint https://rpc1.piccadilly.autonity.org\n121166000000000\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"method\":\"aut_epochReward\", \"params\":[], \"jsonrpc\":\"2.0\", \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":121166000000000}"
  },
  {
    "objectID": "reference/api/aut/index.html#epochtotalbondedstake",
    "href": "reference/api/aut/index.html#epochtotalbondedstake",
    "title": "Autonity Contract Interface",
    "section": "epochTotalBondedStake",
    "text": "epochTotalBondedStake\n    Returns the amount of Newton stake token bonded to consensus committee members and securing the network during the epoch of the call.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    uint256\n    the amount of Newton stake token bonded to consensus committee validators in the epoch of the call\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol epoch-total-bonded-stake [OPTIONS]\n    \n    \n    {\"method\":\"aut_epochTotalBondedStake\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol epoch-total-bonded-stake --rpc-endpoint https://rpc1.piccadilly.autonity.org\n61338\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"method\":\"aut_epochTotalBondedStake\", \"params\":[], \"jsonrpc\":\"2.0\", \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":61338}"
  },
  {
    "objectID": "reference/api/aut/index.html#getblockperiod",
    "href": "reference/api/aut/index.html#getblockperiod",
    "title": "Autonity Contract Interface",
    "section": "getBlockPeriod",
    "text": "getBlockPeriod\n    Returns the block period from the protocol configuration.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    blockPeriod\n    uint256\n    the minimum time interval between two consecutive blocks, measured in seconds\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-block-period [OPTIONS]\n    \n    \n    {\"method\": \"aut_getBlockPeriod\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-block-period --rpc-endpoint https://rpc1.piccadilly.autonity.org\n1\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"method\":\"aut_getBlockPeriod\", \"params\":[], \"jsonrpc\":\"2.0\", \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":1}"
  },
  {
    "objectID": "reference/api/aut/index.html#getcommittee",
    "href": "reference/api/aut/index.html#getcommittee",
    "title": "Autonity Contract Interface",
    "section": "getCommittee",
    "text": "getCommittee\n    Returns a list of the validators selected as members of the consensus committee at the block height of the method call.\n    The method returns the current consensus committee if called before the Autonity Protocol has invoked the finalize() method, the consensus committee for the next epoch if called after.\n    See also the onlyProtocol function finalize.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    Returns a committee array of CommitteeMember objects, each object consisting of:\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    addr\n    address\n    account address of the committee member\n    \n    \n    votingPower\n    uint256\n    the amount of Newton stake token bonded to the committee member\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-committee [OPTIONS]\n    \n    \n    {\"method\": \"aut_getCommittee\", \"params\":[]}\n\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-committee -r https://rpc1.bakerloo.autonity.org\n[\n  {\n    \"address\": \"0x4b7275d5F5292C3027a16E0eb891D75a0Ef39cc7\",\n    \"voting_power\": 10000\n  },\n  {\n    \"address\": \"0x5e08564Ee99E96e690E9b25591191aE0c78351a3\",\n    \"voting_power\": 10000\n  },\n  {\n    \"address\": \"0x33BF54630991f0a1A23B9f102873b3B54C4b94B3\",\n    \"voting_power\": 10000\n  },\n  {\n    \"address\": \"0x1ae9B1B3207195430a36D82Fc0bDA1f857D0AA72\",\n    \"voting_power\": 10000\n  },\n  {\n    \"address\": \"0x0c7dC2aB00c7b5934EDA097a8585f56367A94dA4\",\n    \"voting_power\": 10000\n  },\n  {\n    \"address\": \"0xf5A48b1Df2a3a616AdB92E57d6ce36E17c3C2a0b\",\n    \"voting_power\": 10000\n  },\n  {\n    \"address\": \"0x5FE87eE4f61Da6E640Aec02CE818CdcD30B8cB13\",\n    \"voting_power\": 10000\n  },\n  {\n    \"address\": \"0xEbF9dD85cc99a15f1AFB78A6A7cb28a9103e9a12\",\n    \"voting_power\": 10000\n  },\n  {\n    \"address\": \"0x9f26942A9710099A7F2b4b64e53522bB16d2Af7d\",\n    \"voting_power\": 10005\n  }\n]\n    \n    \n    curl -X GET 'https://rpc1.bakerloo.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_getCommittee\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":[{\"addr\":\"0x4b7275d5f5292c3027a16e0eb891d75a0ef39cc7\",\"votingPower\":10000},{\"addr\":\"0x5e08564ee99e96e690e9b25591191ae0c78351a3\",\"votingPower\":10000},{\"addr\":\"0x33bf54630991f0a1a23b9f102873b3b54c4b94b3\",\"votingPower\":10000},{\"addr\":\"0x1ae9b1b3207195430a36d82fc0bda1f857d0aa72\",\"votingPower\":10000},{\"addr\":\"0x0c7dc2ab00c7b5934eda097a8585f56367a94da4\",\"votingPower\":10000},{\"addr\":\"0xf5a48b1df2a3a616adb92e57d6ce36e17c3c2a0b\",\"votingPower\":10000},{\"addr\":\"0x5fe87ee4f61da6e640aec02ce818cdcd30b8cb13\",\"votingPower\":10000},{\"addr\":\"0xebf9dd85cc99a15f1afb78a6a7cb28a9103e9a12\",\"votingPower\":10000},{\"addr\":\"0x9f26942a9710099a7f2b4b64e53522bb16d2af7d\",\"votingPower\":10005}]}"
  },
  {
    "objectID": "reference/api/aut/index.html#getcommitteeenodes",
    "href": "reference/api/aut/index.html#getcommitteeenodes",
    "title": "Autonity Contract Interface",
    "section": "getCommitteeEnodes",
    "text": "getCommitteeEnodes\n    Returns the enode URLs of validators selected as members of the consensus committee at the block height of the method call.\n    The protocol uses this function to inform committee nodes which other committee nodes to connect to.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    Returns a committeeNodes list of committee member enode URL addresses consisting of:\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    string\n    enode url for the committee member\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-committee-enodes [OPTIONS]\n    \n    \n    {\"method\": \"aut_getCommitteeEnodes\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-committee-enodes -r https://rpc1.bakerloo.autonity.org\n['enode://181dd52828614267b2e3fe16e55721ce4ee428a303b89a0cba3343081be540f28a667c9391024718e45ae880088bd8b6578e82d395e43af261d18cedac7f51c3@35.246.21.247:30303', 'enode://e3b8ea9ddef567225530bcbae68af5d46f59a2b39acc04113165eba2744f6759493027237681f10911d4c12eda729c367f8e64dfd4789c508b7619080bb0861b@35.189.64.207:30303', 'enode://00c6c1704c103e74a26ad072aa680d82f6c677106db413f0afa41a84b5c3ab3b0827ea1a54511f637350e4e31d8a87fdbab5d918e492d21bea0a399399a9a7b5@34.105.163.137:30303', 'enode://dffaa985bf36c8e961b9aa7bcdd644f1ad80e07d7977ce8238ac126d4425509d98da8c7f32a3e47e19822bd412ffa705c4488ce49d8b1769b8c81ee7bf102249@35.177.8.113:30308', 'enode://1bd367bfb421eb4d21f9ace33f9c3c26cd1f6b257cc4a1af640c9af56f338d865c8e5480c7ee74d5881647ef6f71d880104690936b72fdc905886e9594e976d1@35.179.46.181:30309', 'enode://a7465d99513715ece132504e47867f88bb5e289b8bca0fca118076b5c733d901305db68d1104ab838cf6be270b7bf71e576a44644d02f8576a4d43de8aeba1ab@3.9.98.39:30310', 'enode://c6ae16b58cf2e073649ec34ed59550c57389fcb949f51b806d6f7de26e7961cfc33794fde67b484ce9966a30e5ab5331c610b1b659249a6d66cc9e6d8a3d23d1@143.198.240.242:30303', 'enode://06facaec377a55fe8fd9e30cc922bedc7ee97e292294435635fa3b053c30215b87954daa27c79a73e3a5013124318b084907c81f518bcf36f88dad4d01e952ec@138.68.118.4:30303', 'enode://0c71d8076f0543505aae22901471d5437f1fd92b3d154d154edcec5baf0d7b121e6e8dc85ae725daf77cbc50ff5616727d59d36c2606751401000580e155e2bc@5.181.104.29:30303']\n    \n    \n    curl -X GET 'https://rpc1.bakerloo.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_getCommitteeEnodes\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":[\"enode://181dd52828614267b2e3fe16e55721ce4ee428a303b89a0cba3343081be540f28a667c9391024718e45ae880088bd8b6578e82d395e43af261d18cedac7f51c3@35.246.21.247:30303\",\"enode://e3b8ea9ddef567225530bcbae68af5d46f59a2b39acc04113165eba2744f6759493027237681f10911d4c12eda729c367f8e64dfd4789c508b7619080bb0861b@35.189.64.207:30303\",\"enode://00c6c1704c103e74a26ad072aa680d82f6c677106db413f0afa41a84b5c3ab3b0827ea1a54511f637350e4e31d8a87fdbab5d918e492d21bea0a399399a9a7b5@34.105.163.137:30303\",\"enode://dffaa985bf36c8e961b9aa7bcdd644f1ad80e07d7977ce8238ac126d4425509d98da8c7f32a3e47e19822bd412ffa705c4488ce49d8b1769b8c81ee7bf102249@35.177.8.113:30308\",\"enode://1bd367bfb421eb4d21f9ace33f9c3c26cd1f6b257cc4a1af640c9af56f338d865c8e5480c7ee74d5881647ef6f71d880104690936b72fdc905886e9594e976d1@35.179.46.181:30309\",\"enode://a7465d99513715ece132504e47867f88bb5e289b8bca0fca118076b5c733d901305db68d1104ab838cf6be270b7bf71e576a44644d02f8576a4d43de8aeba1ab@3.9.98.39:30310\",\"enode://c6ae16b58cf2e073649ec34ed59550c57389fcb949f51b806d6f7de26e7961cfc33794fde67b484ce9966a30e5ab5331c610b1b659249a6d66cc9e6d8a3d23d1@143.198.240.242:30303\",\"enode://06facaec377a55fe8fd9e30cc922bedc7ee97e292294435635fa3b053c30215b87954daa27c79a73e3a5013124318b084907c81f518bcf36f88dad4d01e952ec@138.68.118.4:30303\",\"enode://0c71d8076f0543505aae22901471d5437f1fd92b3d154d154edcec5baf0d7b121e6e8dc85ae725daf77cbc50ff5616727d59d36c2606751401000580e155e2bc@5.181.104.29:30303\"]}"
  },
  {
    "objectID": "reference/api/aut/index.html#getepochfromblock",
    "href": "reference/api/aut/index.html#getepochfromblock",
    "title": "Autonity Contract Interface",
    "section": "getEpochFromBlock",
    "text": "getEpochFromBlock\n    Returns the unique identifier of the epoch block epoch associated with a block as an integer value.\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _block\n    uint256\n    the input block number\n    \n    \n    \n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    epochID\n    uint256\n    the identifier of the epoch in which the block was committed to state\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-epoch-from-block [OPTIONS] BLOCK\n    \n    \n    {\"method\": \"aut_getEpochFromBlock\", \"params\":[_block]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-epoch-from-block --rpc-endpoint https://rpc1.piccadilly.autonity.org 3293857\n1829\n    \n    \n    curl --location --request GET 'https://rpc1.bakerloo.autonity.org/' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n        \"jsonrpc\":\"2.0\",\n        \"method\":\"aut_getEpochFromBlock\",\n        \"params\":[1900],\n        \"id\":1500\n}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":1}"
  },
  {
    "objectID": "reference/api/aut/index.html#getepochperiod",
    "href": "reference/api/aut/index.html#getepochperiod",
    "title": "Autonity Contract Interface",
    "section": "getEpochPeriod",
    "text": "getEpochPeriod\n    Returns the epoch period from the protocol configuration.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    epochPeriod\n    uint256\n    the period of time for which a consensus committee is elected, defined as a number of blocks\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-epoch-period [OPTIONS]\n    \n    \n    {\"method\": \"aut_getEpochPeriod\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-epoch-period --rpc-endpoint https://rpc1.piccadilly.autonity.org\n1800\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"method\":\"aut_getEpochPeriod\", \"params\":[], \"jsonrpc\":\"2.0\", \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":1800}"
  },
  {
    "objectID": "reference/api/aut/index.html#getlastepochblock",
    "href": "reference/api/aut/index.html#getlastepochblock",
    "title": "Autonity Contract Interface",
    "section": "getLastEpochBlock",
    "text": "getLastEpochBlock\n    Returns the number of the last block in the preceding epoch at the block height of the call.\n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    lastEpochBlock\n    uint256\n    the number of the last block in the preceding epoch\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-last-epoch-block [OPTIONS]\n    \n    \n    {\"method\":\"aut_getLastEpochBlock\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-last-epoch-block -r https://rpc1.piccadilly.autonity.org\n12981684\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"method\":\"aut_getLastEpochBlock\", \"params\":[], \"jsonrpc\":\"2.0\", \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":12981684}"
  },
  {
    "objectID": "reference/api/aut/index.html#getmaxcommitteesize",
    "href": "reference/api/aut/index.html#getmaxcommitteesize",
    "title": "Autonity Contract Interface",
    "section": "getMaxCommitteeSize",
    "text": "getMaxCommitteeSize\n    Returns the protocol setting for the maximum number of validators that can be selected to the consensus committee.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    committeeSize\n    uint256\n    the maximum number of validators allowed in the consensus committee\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-max-committee-size [OPTIONS]\n    \n    \n    {\"method\": \"aut_getMaxCommitteeSize\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-max-committee-size --rpc-endpoint https://rpc1.bakerloo.autonity.org/\n50\n    \n    \n    curl --location --request GET 'https://rpc1.bakerloo.autonity.org/' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n        \"jsonrpc\":\"2.0\",\n        \"method\":\"aut_getMaxCommitteeSize\",\n        \"params\":[],\n        \"id\":1\n}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":50}"
  },
  {
    "objectID": "reference/api/aut/index.html#getminimumbasefee",
    "href": "reference/api/aut/index.html#getminimumbasefee",
    "title": "Autonity Contract Interface",
    "section": "getMinimumBaseFee",
    "text": "getMinimumBaseFee\n    Returns the protocol setting for the minimum price per unit of gas for computing a transaction on an Autonity network.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    minBaseFee\n    uint256\n    the minimum price per unit of gas, denominated in ton\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-minimum-base-fee [OPTIONS]\n    \n    \n    {\"method\": \"aut_getMinimumBaseFee\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-minimum-base-fee --rpc-endpoint https://rpc1.bakerloo.autonity.org/\n500000000\n    \n    \n    curl --location --request GET 'https://rpc1.bakerloo.autonity.org/' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n        \"jsonrpc\":\"2.0\",\n        \"method\":\"aut_getMinimumBaseFee\",\n        \"params\":[],\n        \"id\":1\n}'\n\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":500000000}"
  },
  {
    "objectID": "reference/api/aut/index.html#getnewcontract",
    "href": "reference/api/aut/index.html#getnewcontract",
    "title": "Autonity Contract Interface",
    "section": "getNewContract",
    "text": "getNewContract\n    The getNewContract method is used as part of the Autonity Protocol Contract upgrade process. It provides a getter function to retrieve the compiled EVM bytecode and Contract ABI of a new Autonity Protocol Contract when an upgrade is initiated.\n    The method retrieves the compiled Solidity code and JSON formatted Contract ABI representation, and performs an upgrade.\n    See also the onlyOperator function upgradeContract.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    newContractBytecode\n    bytes\n    the EVM bytecode compiled from the new Autonity Protocol Contract’s source Solidity\n    \n    \n    newContractABI\n    string\n    the Application Binary Interface (ABI) of the new Autonity Protocol Contract as a JSON representation\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    {\"method\": \"aut_getNewContract\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    RPC\n    \n    \n    curl --location --request GET 'https://rpc1.bakerloo.autonity.org/' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n        \"jsonrpc\":\"2.0\",\n        \"method\":\"aut_getNewContract\",\n        \"params\":[],\n        \"id\":1\n}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":[\"\",\"\"]}"
  },
  {
    "objectID": "reference/api/aut/index.html#getoperator",
    "href": "reference/api/aut/index.html#getoperator",
    "title": "Autonity Contract Interface",
    "section": "getOperator",
    "text": "getOperator\n    Returns the address of the Autonity governance account.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    address\n    the operator governance account address\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-operator [OPTIONS]\n    \n    \n    {\"method\":\"aut_getOperator\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-operator -r https://rpc1.bakerloo.autonity.org/\n0x293039dDC627B1dF9562380c0E5377848F94325A\n    \n    \n    curl -X GET 'https://rpc1.bakerloo.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_getOperator\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"0x293039dDC627B1dF9562380c0E5377848F94325A\"}"
  },
  {
    "objectID": "reference/api/aut/index.html#getoracle",
    "href": "reference/api/aut/index.html#getoracle",
    "title": "Autonity Contract Interface",
    "section": "getOracle",
    "text": "getOracle\n    Returns the address of the Autonity Oracle Contract.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    address\n    the oracle contract account address\n    \n    \n    \n    \n    \n    Usage\n    \n    RPC\n    \n    \n    {\"method\": \"aut_getOracle\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    RPC\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"method\":\"aut_getOracle\", \"params\":[], \"jsonrpc\":\"2.0\", \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"0x47e9fbef8c83a1714f1951f142132e6e90f5fa5d\"}"
  },
  {
    "objectID": "reference/api/aut/index.html#getproposer",
    "href": "reference/api/aut/index.html#getproposer",
    "title": "Autonity Contract Interface",
    "section": "getProposer",
    "text": "getProposer\n    Returns the address of the consensus committee member proposing a new block for a specified block height and consensus round.\n    The proposer is selected from the committee via weighted random sampling, with selection probability determined by the voting power of each committee member. The selection mechanism is deterministic and will always select the same address, given the same height, round and contract state.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    height\n    uint256\n    the block number for which the proposer is requested\n    \n    \n    round\n    uint256\n    the consensus round number for which the proposer is requested\n    \n    \n    \n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    address\n    the address of the proposer at the designated block height and consensus round\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-proposer [OPTIONS] HEIGHT ROUND\n    \n    \n    {\"method\": \"aut_getProposer\", \"params\":[height, round]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-proposer -r https://rpc1.bakerloo.autonity.org/ 4576868 0\n0x0c7dC2aB00c7b5934EDA097a8585f56367A94dA4\n    \n    \n    curl --location --request GET 'https://rpc1.bakerloo.autonity.org/' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n        \"jsonrpc\":\"2.0\",\n        \"method\":\"aut_getProposer\",\n        \"params\":[4576868,0],\n        \"id\":1\n}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"0x0c7dc2ab00c7b5934eda097a8585f56367a94da4\"}"
  },
  {
    "objectID": "reference/api/aut/index.html#gettreasuryaccount",
    "href": "reference/api/aut/index.html#gettreasuryaccount",
    "title": "Autonity Contract Interface",
    "section": "getTreasuryAccount",
    "text": "getTreasuryAccount\n    Returns the address of the Autonity treasury account.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    address\n    the Autonity treasury account address\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-treasury-account [OPTIONS]\n    \n    \n    {\"method\":\"aut_getTreasuryAccount\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-treasury-account -r https://rpc1.piccadilly.autonity.org/\n0xF74c34Fed10cD9518293634C6f7C12638a808Ad5\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_getTreasuryAccount\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"0xf74c34fed10cd9518293634c6f7c12638a808ad5\"}"
  },
  {
    "objectID": "reference/api/aut/index.html#gettreasuryfee",
    "href": "reference/api/aut/index.html#gettreasuryfee",
    "title": "Autonity Contract Interface",
    "section": "getTreasuryFee",
    "text": "getTreasuryFee\n    Returns the percentage of staking rewards deducted from staking rewards by the protocol. Treasury fees ared sent to the Autonity Treasury account for community funding before staking rewards are distributed.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    treasuryFee\n    uint256\n    the Autonity treasury account address. The value is returned in 10^18 format.\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-treasury-fee [OPTIONS]\n    \n    \n    {\"method\":\"aut_getTreasuryFee\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-treasury-fee -r https://rpc1.piccadilly.autonity.org/\n10000000000000000\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_getTreasuryFee\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":10000000000000000}"
  },
  {
    "objectID": "reference/api/aut/index.html#getunbondingperiod",
    "href": "reference/api/aut/index.html#getunbondingperiod",
    "title": "Autonity Contract Interface",
    "section": "getUnbondingPeriod",
    "text": "getUnbondingPeriod\n    Returns the unbonding period from the protocol configuration.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    unbondingPeriod\n    uint256\n    the period of time for which bonded stake must wait before it can be redeemed for Newton after processing a stake redeem transaction, defined as a number of blocks\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-unbonding-period [OPTIONS]\n    \n    \n    {\"method\": \"aut_getUnbondingPeriod\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-unbonding-period -r https://rpc1.piccadilly.autonity.org/\n21600\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"method\":\"aut_getUnbondingPeriod\", \"params\":[], \"jsonrpc\":\"2.0\", \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":21600}"
  },
  {
    "objectID": "reference/api/aut/index.html#getvalidator",
    "href": "reference/api/aut/index.html#getvalidator",
    "title": "Autonity Contract Interface",
    "section": "getValidator",
    "text": "getValidator\n    Returns the data for a designated validator identifier address from system state. The method response may be empty if there is no associated validator object for the address argument provided.\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _addr\n    address\n    the validator identifier account address\n    \n    \n    \n    \n    \n    Response\n    Returns a Validator object consisting of:\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    treasury\n    address payable\n    the address that will receive staking rewards the validator earns\n    \n    \n    nodeAddress\n    address\n    the validator identifier account address\n    \n    \n    oracleAddress\n    address\n    the identifier account address of the validator’s oracle server\n    \n    \n    enode\n    string\n    the enode url of the validator node\n    \n    \n    commissionRate\n    uint256\n    the percentage commission that the validator will charge on staking rewards from delegated stake\n    \n    \n    bondedStake\n    uint256\n    the total amount of delegated and self-bonded stake that has been bonded to the validator\n    \n    \n    unbondingStake\n    uint256\n    the total amount of NTN in the unbonding staking pool\n    \n    \n    unbondingShares\n    uint256\n    the total amount of shares issued for the unbonding staking pool\n    \n    \n    selfBondedStake\n    uint256\n    the total amount of ‘self-bonded’ stake that has been bonded to the validator by the validator operator\n    \n    \n    selfUnbondingStake\n    uint256\n    the total amount of NTN in the self-unbonding staking pool\n    \n    \n    selfUnbondingShares\n    uint256\n    the total amount of shares in the self-unbonding staking pool\n    \n    \n    selfUnbondingStakeLocked\n    uint256\n    the total amount of NTN in the self-unbonding staking pool that is locked pending unbonding\n    \n    \n    liquidContract\n    Liquid\n    the address of the validator’s Liquid Newton contract\n    \n    \n    liquidSupply\n    uint256\n    the total amount of Liquid Newton in circulation\n    \n    \n    registrationBlock\n    uint256\n    the block number in which the registration of the validator was committed to state\n    \n    \n    totalSlashed\n    uint256\n    the total amount of stake that a validator has had slashed for accountability and omission faults since registration\n    \n    \n    jailReleaseBlock\n    uint256\n    the block number at which a validator jail period applied for an accountability or omission fault ends (the validator can be re-activated after this block height). Set to 0 when the validator is in an active or jailbound state\n    \n    \n    provableFaultCount\n    uint256\n    a counter of the number of times that a validator has been penalised for accountability and omission faults since registration\n    \n    \n    consensusKey\n    bytes\n    the public consensus key of the validator\n    \n    \n    state\n    ValidatorState\n    the state of the validator. ValidatorState is an enumerated type with enumerations: 0: active, 1: paused, 2: jailed, 3: jailbound\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut validator info [OPTIONS]\n    \n    \n    {\"method\": \"aut_getValidator\", \"params\":[_addr]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut validator info --rpc-endpoint https://rpc1.piccadilly.autonity.org --validator 0x21bb01ae8eb831fff68ebe1d87b11c85a766c94c\n{\n  \"treasury\": \"0x61EE7d3244642E5f6D654416a098DEabFBF5306e\",\n  \"node_address\": \"0x21bb01Ae8EB831fFf68EbE1D87B11c85a766C94C\",\n  \"oracle_address\": \"0x9b844631B7279576330B9B822bE79266696fF8C2\",\n  \"enode\": \"enode://b2748268c31ebab8603058335bb4bed062e05b9ceaa3562f69868a01d1038a84136fc587fb913e1cb8ce821f1eb0bf9879e3249f18adcd39f1211a104ceb57a9@35.197.223.249:30303\",\n  \"commission_rate\": 1000,\n  \"bonded_stake\": 10000000000000000000000,\n  \"unbonding_stake\": 0,\n  \"unbonding_shares\": 0,\n  \"self_bonded_stake\": 10000000000000000000000,\n  \"self_unbonding_stake\": 0,\n  \"self_unbonding_shares\": 0,\n  \"liquid_contract\": \"0x0000000000000000000000000000000000000000\",\n  \"liquid_supply\": 1397840815523076466699159265359708166239426845751,\n  \"registration_block\": 0,\n  \"total_slashed\": 0,\n  \"jail_release_block\": 0,\n  \"provable_fault_count\": 0,\n  \"state\": 0\n}\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_getValidator\", \"params\":[\"0x439926f9a819e86ae284ceaa7e87909777cf8c84\"], \"id\":1}' .|jq\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"treasury\": \"0xf47fdd88c8f6f80239e177386cc5ae3d6bcdeeea\",\n    \"nodeAddress\": \"0x439926f9a819e86ae284ceaa7e87909777cf8c84\",\n    \"oracleAddress\": \"0xf75cadcbf252708d7f030978929dd68d5046fbca\",\n    \"enode\": \"enode://02ad2d5ae371983f9aecadaee6fd300d3241b946d10c29ec59724ed6bcc41c05bedae9318fe566a2f2180be9783fd552f05a0d212a094304cdfbc8d87e70b0a3@86.182.102.239:30303\",\n    \"commissionRate\": 1000,\n    \"bondedStake\": 0,\n    \"unbondingStake\": 0,\n    \"unbondingShares\": 0,\n    \"selfBondedStake\": 0,\n    \"selfUnbondingStake\": 0,\n    \"selfUnbondingShares\": 0,\n    \"selfUnbondingStakeLocked\": 0,\n    \"liquidContract\": \"0x2b0f159443599fbb6723cdb33d0db94f96b95d0f\",\n    \"liquidSupply\": 0,\n    \"registrationBlock\": 171322,\n    \"totalSlashed\": 0,\n    \"jailReleaseBlock\": 0,\n    \"provableFaultCount\": 0,\n    \"consensusKey\": \"reWv9AU/mGkTEaSlmcXAghXQrXITz6WOABRU51+Scig/1LeC4gia6FQKQDzQj83W\",\n    \"state\": 0\n  }\n}"
  },
  {
    "objectID": "reference/api/aut/index.html#getvalidators",
    "href": "reference/api/aut/index.html#getvalidators",
    "title": "Autonity Contract Interface",
    "section": "getValidators",
    "text": "getValidators\n    Returns the current list of validators from system state.\n    The response is returned as a list of validator identifier addresses, sorted by registration index in ascending order. I.E. the last value in the array is always the last processed registration request.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    validatorList\n    address array\n    an array of registered validators, sorted by registration index in ascending order\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut validator list [OPTIONS]\n    \n    \n    {\"method\": \"aut_getValidators\", \"params\":[]}\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    getValidators can also be called using the aut command aut protocol get-validators.\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut validator list --rpc-endpoint https://rpc1.piccadilly.autonity.org\n0x32F3493Ef14c28419a98Ff20dE8A033cf9e6aB97\n0x31870f96212787D181B3B2771F58AF2BeD0019Aa\n0x6EBb5A45728be7Cd9fE9c007aDD1e8b3DaFF6B3B\n0xAC245aF88265E72881CD9D21eFb9DDC32E174B69\n0x36288C1F8C990fd66A1C5040a61d6f3EcF3A49c1\n0xb3A3808c698d82790Ac52a42C05E4BCb3dfCd3db\n0x467D99EA9DACC495E6D1174b8f3Dd20DDd531335\n0xa940eB48368324E2032b97723BE487505981edce\n0xba35a25badB802Cb3C0702e0e2df392e00511CA2\n0x1114fE559b302403BB3a89806bC08F7fA5299E99\n0x9fd408Bdb83Be1c8504Ff13eBcCe7f490DCCC2cF\n0xE03D1DE3A2Fb5FEc85041655F218f18c9d4dac55\n0x52b89AFA0D1dEe274bb5e4395eE102AaFbF372EA\n0x914d06dBaaA3c51085692F59230769EAa32f3A94\n0xFae912BAdB5e0Db5EC0116fe6552e8D6Bdb4e82b\n0x7fc0ae4918C0D8eAa1A259fa455B32A2cEB58eA4\n0x82b6eacA5014DCa39b3A37d68C246f1466B15aA9\n0xE4Ece2266Ea7B7468aD3E381d08C962641b567f2\n0xCD46183D0075116175c62dCDe568f2e0c4736597\n0xcd50C31356fDdBD9e704cf58751a0ED2B178d8b0\n0xaB471b6F6E59dfD81ba9988f0D0B6950C5c3FEC1\n0xeb25090AA0fD5c940F87A172Aaf62413Eb625b63\n0x2AF517e6EdF3C01f8256E609122f004457024E67\n0x9d458E21b15C0C1A95db65c5fAe639d1477cE4DC\n0x724E26894a5fcf0233fdc5849Aaf0fbB2dd5b0E8\n0xE9Ce74FBA6F04345516c9a3028292a1d62A409B3\n0x9f793D2c7E1D5a72A020281F383bfc5e3086AcA9\n0xde5aeb71cc4Aaa99cf6a23F68bFfDdDD7e8231Fe\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_getValidators\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":[\"0x32f3493ef14c28419a98ff20de8a033cf9e6ab97\",\"0x31870f96212787d181b3b2771f58af2bed0019aa\",\"0x6ebb5a45728be7cd9fe9c007add1e8b3daff6b3b\",\"0xac245af88265e72881cd9d21efb9ddc32e174b69\",\"0x36288c1f8c990fd66a1c5040a61d6f3ecf3a49c1\",\"0xb3a3808c698d82790ac52a42c05e4bcb3dfcd3db\",\"0x467d99ea9dacc495e6d1174b8f3dd20ddd531335\",\"0xa940eb48368324e2032b97723be487505981edce\",\"0xba35a25badb802cb3c0702e0e2df392e00511ca2\",\"0x1114fe559b302403bb3a89806bc08f7fa5299e99\",\"0x9fd408bdb83be1c8504ff13ebcce7f490dccc2cf\",\"0xe03d1de3a2fb5fec85041655f218f18c9d4dac55\",\"0x52b89afa0d1dee274bb5e4395ee102aafbf372ea\",\"0x914d06dbaaa3c51085692f59230769eaa32f3a94\",\"0xfae912badb5e0db5ec0116fe6552e8d6bdb4e82b\",\"0x7fc0ae4918c0d8eaa1a259fa455b32a2ceb58ea4\",\"0x82b6eaca5014dca39b3a37d68c246f1466b15aa9\",\"0xe4ece2266ea7b7468ad3e381d08c962641b567f2\",\"0xcd46183d0075116175c62dcde568f2e0c4736597\",\"0xcd50c31356fddbd9e704cf58751a0ed2b178d8b0\",\"0xab471b6f6e59dfd81ba9988f0d0b6950c5c3fec1\",\"0xeb25090aa0fd5c940f87a172aaf62413eb625b63\",\"0x2af517e6edf3c01f8256e609122f004457024e67\",\"0x9d458e21b15c0c1a95db65c5fae639d1477ce4dc\",\"0x724e26894a5fcf0233fdc5849aaf0fbb2dd5b0e8\",\"0xe9ce74fba6f04345516c9a3028292a1d62a409b3\",\"0x9f793d2c7e1d5a72a020281f383bfc5e3086aca9\",\"0xde5aeb71cc4aaa99cf6a23f68bffdddd7e8231fe\"]}"
  },
  {
    "objectID": "reference/api/aut/index.html#getversion",
    "href": "reference/api/aut/index.html#getversion",
    "title": "Autonity Contract Interface",
    "section": "getVersion",
    "text": "getVersion\n    Returns the version of the Autonity Protocol Contract.\n    Versioning is recorded by a single-digit incrementing version number.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    contractVersion\n    uint256\n    the version number of the Autonity Protocol Contract. An integer value set by default to 1 and incremented by 1 on contract upgrade\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol get-version [OPTIONS]\n    \n    \n    {\"method\": \"aut_getVersion\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol get-version -r https://rpc1.piccadilly.autonity.org/8545/\n1\n    \n    \n    curl -X GET 'https://rpc1.bakerloo.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_getVersion\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":1}"
  },
  {
    "objectID": "reference/api/aut/index.html#name",
    "href": "reference/api/aut/index.html#name",
    "title": "Autonity Contract Interface",
    "section": "name",
    "text": "name\n    Returns the name of the Newton stake token as a human-readable string. Set as contract metadata to the value of Newton.\n    Using aut you can return the name for an ERC20 token contract account, e.g. a Liquid Newton contract.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    Returns\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    string\n    the name of the Newton stake token\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut token name [OPTIONS]\n    \n    \n    {\"method\":\"aut_name\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut token name --ntn -r https://rpc1.piccadilly.autonity.org\nNewton\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"method\":\"aut_name\", \"params\":[], \"jsonrpc\":\"2.0\", \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"Newton\"}\n    \n    \n    \n    To return the name for an ERC20 (e.g. a Liquid Newton token) token contract specify the --token option:\n    \n    aut\n    \n    \n    aut token name --rpc-endpoint https://rpc1.piccadilly.autonity.org --token 0xC500751c4F96d49B954D20EAE42Fa29278B96beB\nLNTN-4"
  },
  {
    "objectID": "reference/api/aut/index.html#pausevalidator",
    "href": "reference/api/aut/index.html#pausevalidator",
    "title": "Autonity Contract Interface",
    "section": "pauseValidator",
    "text": "pauseValidator\n    Changes the state of a registered validator on an Autonity Network from active to paused. (A paused validator can be re-activated by calling the activateValidator method.)\n    The pauseValidator method provides as argument the validator identifier address.\n    On method execution the Validator.state object data property is updated in memory and set to paused.\n    Constraint checks are applied:\n    \n    the address of the validator is registered\n    the msg.sender address of the transaction is equal to the validator’s treasury address\n    the validator state must be active\n    \n    Validator pausing is executed on transaction commit. New stake delegations are reverted from submission of the pausing transaction. Exclusion of the validator from the consensus committee selection algorithm takes effect at epoch end (i.e. the ‘effective block’).\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _address\n    address\n    the validator identifier account address\n    \n    \n    \n    \n    \n    Response\n    No response object is returned on successful execution of the method call.\n    The updated state can be viewed by calling the getValidator method.\n    \n    \n    Event\n    On a successful call the function emits a PausedValidator event, logging: val.treasury, _address, effectiveBlock.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut validator pause [OPTIONS]\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut validator pause --validator 0x49454f01a8F1Fbab21785a57114Ed955212006be | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x942328bea54a0096ca9b2fb88acd337c883f7923c2ef6b8290a340c5baec2d20"
  },
  {
    "objectID": "reference/api/aut/index.html#registervalidator",
    "href": "reference/api/aut/index.html#registervalidator",
    "title": "Autonity Contract Interface",
    "section": "registerValidator",
    "text": "registerValidator\n    Registers a validator on an Autonity Network.\n    The registerValidator method provides as argument the enode URL of the validator node, the validator’s oracle server address, the validator’s BLS public key used for consensus gossiping, and a proof of node ownership generated using the private key of the validator node’s P2P node keys, autonitykeys and the validator’s oracle server key.\n    On method execution a Validator object data structure is constructed in memory, populated with method arguments and default values ready for validator registration processing:\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    treasury\n    address payable\n    Set to the msg.sender address submitting the registerValidator method call transaction\n    \n    \n    nodeAddress\n    address\n    Set to temporary value of 0 before assignment of the actual validator node identifier address value\n    \n    \n    oracleAddress\n    string\n    Assigned the value of the _oracleAddress argument to the method call\n    \n    \n    enode\n    string\n    Assigned the value of the _enode argument to the method call\n    \n    \n    commissionRate\n    \n    Assigned the value of the delegationRate parameter in the genesis configuration file\n    \n    \n    bondedStake\n    uint256\n    Set to 0. There is no stake bonded to the newly registered validator at this point.\n    \n    \n    unbondingStake\n    uint256\n    Set to 0. There is no stake in the unbonding staking pool at this point\n    \n    \n    unbondingShares\n    uint256\n    Set to 0. There are no shares issued for the unbonding staking pool at this point\n    \n    \n    selfBondedStake\n    uint256\n    Set to 0. There is no self-bonded stake to the newly registered validator at this point\n    \n    \n    selfUnbondingStake\n    uint256\n    Set to 0. There is no stake in the self-unbonding staking pool at this point\n    \n    \n    selfUnbondingShares\n    uint256\n    Set to 0. There are no shares issued for the self-unbonding staking pool at this point\n    \n    \n    selfUnbondingStakeLocked\n    uint256\n    Set to 0. There is no stake in the self-unbonding staking pool at this point that is locked pending unbonding\n    \n    \n    liquidContract\n    address\n    Set to the contract address of the newly registered validator’s Liquid Newton Contract\n    \n    \n    liquidSupply\n    uint256\n    Set to 0. There is no liquid token supply until stake is bonded to the newly registered validator\n    \n    \n    registrationBlock\n    uint256\n    Set to current block number (the number of the block that the register validator transaction will be committed in)\n    \n    \n    totalSlashed\n    uint256\n    Set to 0. (The total amount of stake that a validator has had slashed for accountability and omission faults since registration.)\n    \n    \n    jailReleaseBlock\n    uint256\n    Set to 0. (The block number at which a validator jail period applied for an accountability or omission fault ends.)\n    \n    \n    provableFaultCount\n    uint256\n    Set to 0. (Counter recording the number of times the validator has been penalised for accountability and omission faults.)\n    \n    \n    consensusKey\n    bytes\n    Set to the _consensusKey parameter value provided in the registerValidator method call transaction\n    \n    \n    ValidatorState\n    state\n    Set to active.\n    \n    \n    \n    Constraint checks are applied:\n    \n    the enode URL is not empty and is correctly formed\n    the address of the validator is not already registered\n    the consensusKey is valid\n    the proof of node ownership is valid: a cryptographic proof containing the string of the validator’s treasury account address signed by (a) the validator’s private P2P node key and (2) the validator’s oracle server private key. The two signatures are concatenated together to create the ownership proof. The validator’s treasury account address is recovered from the proof using the public key of (1) the validator’s P2P node key and (2) the oracle server key.\n    \n    Validator registration is then executed, the temporary address assignments updated, and the new validator object appended to the indexed validator list recorded in system state. I.E. the most recently registered validator will always have the highest index identifier value and will always be the last item in the validator list returned by a call to get a network’s registered validators (see getValidators).\n    A validator-specific Liquid Newton contract is deployed; the contract’s name and symbol properties are both set to LNTN-&lt;ID&gt; where &lt;ID&gt; is the validator’s registration index identifier.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _enode\n    string\n    the enode url for the validator node\n    \n    \n    _oracleAddress\n    address\n    the oracle server identifier account address\n    \n    \n    _consensusKey\n    bytes\n    the BLS public key from autonitykeys used for P2P consensus gossiping\n    \n    \n    _signatures\n    bytes\n    the proof of node ownership. A combination of two ECDSA signatures and a bls signature appended sequentially to provide the ownership proof of the validator node key (autonitykeys). The first two ECDSA signatures are in the order: (1) a message containing the treasury account address signed by the validator P2P autonitykeys private key; (2) a message containing the treasury account address signed by the Oracle Server account private key.\n    \n    \n    \n    \n    \n    Response\n    No response object is returned on successful execution of the method call.\n    The validator registration entry can be retrieved from state by calling the getValidator method.\n    \n    \n    Event\n    On a successful call the function emits a RegisteredValidator event, logging: msg.sender, _val.nodeAddress, _oracleAddress, _enode, address(_val.liquidContract).\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut validator register [OPTIONS] ENODE ORACLE CONSENSUS_KEY PROOF\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut validator register enode://c36481d70943dd046d8013f3d302cf0d2a17f5f5f3398cd47fbcb38edfe4e5b4207ea4e762ec52efb65f72bede5cd5a65e8380eaf0db9ef39a77cb6ec5694af9@11.19.111.18:30303 0xFe91928d58Af4AFbD78C96121k3147ef1f517072 0x978191bff952cd9614b36ff2cc57a47820204bc71b0131625964e6801c304836a7fa11a9c47ca2561cbfc71eb0b314ab 0xfc93396148320f466f10f25abd312ed15ef31f6b29e8924b6f0592e585580f873f807304a540a8a436d92aed969aef0148ca8a2884fc7ad56f1cffa50bb7aa9a01a5189e8d50880faf97ad42501375b216b89304c3fd4acf548a1d7fd7136e74771791422819134e2e3fbf720c35652d8c163e3d4f22c798a3c648958f7abcda2c00b1e8cd80be821c23d41d4ccb6587685960519375762e9ccd8a95ba3fbeb7d47955990b33af65db5155d3d79d498152760d83ab8c92a132e94aeb458f556ff7ef9d5b78b2544a47939ae71a01faf5172c25b5102bc7eed886ff105e91283b3916 | aut tx sign - | aut tx send -"
  },
  {
    "objectID": "reference/api/aut/index.html#symbol",
    "href": "reference/api/aut/index.html#symbol",
    "title": "Autonity Contract Interface",
    "section": "symbol",
    "text": "symbol\n    Returns the three-letter symbol of the Newton stake token as a string. Set as contract metadata to the value of NTN.\n    Using aut you can return the symbol for an ERC20 token contract account, e.g. a Liquid Newton contract.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    Returns\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    string\n    the symbol for the Newton stake token - NTN\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut token symbol [OPTIONS]\n    \n    \n    {\"method\":\"aut_symbol\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut token symbol --ntn --rpc-endpoint https://rpc1.piccadilly.autonity.org\nNTN\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_symbol\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"NTN\"}\n    \n    \n    \n    To return the symbol for an ERC20 (e.g. a Liquid Newton token) token contract specify the --token option:\n    \n    aut\n    \n    \n    aut token symbol --token 0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37\nLNTN-0"
  },
  {
    "objectID": "reference/api/aut/index.html#totalredistributed",
    "href": "reference/api/aut/index.html#totalredistributed",
    "title": "Autonity Contract Interface",
    "section": "totalRedistributed",
    "text": "totalRedistributed\n    Returns the total amount of staking rewards distributed since genesis minus treasury fee.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    value\n    uint256\n    the amount of Auton utility token distributed as staking rewards\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut protocol total-redistributed [OPTIONS]\n    \n    \n    {\"method\":\"aut_totalRedistributed\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    \n    autRPC\n    \n    \n    aut protocol total-redistributed -r https://rpc1.piccadilly.autonity.org\n47981813599875371606\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_totalRedistributed\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":47981813599875371606}"
  },
  {
    "objectID": "reference/api/aut/index.html#totalsupply",
    "href": "reference/api/aut/index.html#totalsupply",
    "title": "Autonity Contract Interface",
    "section": "totalSupply",
    "text": "totalSupply\n    Returns the total supply of Newton stake token in circulation.\n    Using aut you can return the allowance for an ERC20 token contract account, e.g. a Liquid Newton account.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    stakeSupply\n    uint256\n    the total supply of Newton in circulation\n    \n    \n    \n    \n    \n    Usage\n    \n    autRPC\n    \n    \n    aut token total-supply [OPTIONS]\n    \n    \n    {\"method\": \"aut_totalSupply\", \"params\":[]}\n    \n    \n    \n    \n    \n    Example\n    To return total supply for the Newton stake token specify the --ntn option:\n    \n    autRPC\n    \n    \n    aut token total-supply --ntn -r https://rpc1.piccadilly.autonity.org\n63402\n    \n    \n    curl -X GET 'https://rpc1.piccadilly.autonity.org/'  --header 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"method\":\"aut_totalSupply\", \"params\":[], \"id\":1}'\n{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":63402}\n    \n    \n    \n    To return the total supply for an ERC20 contract token (e.g. Liquid Newton) specify the --token option:\n    \n    aut\n    \n    \n    aut token total-supply --token 0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37   -r https://rpc1.piccadilly.autonity.org\n10087"
  },
  {
    "objectID": "reference/api/aut/index.html#transfer",
    "href": "reference/api/aut/index.html#transfer",
    "title": "Autonity Contract Interface",
    "section": "transfer",
    "text": "transfer\n    Transfers a designated amount of Newton stake token from the caller account to a recipient account.\n    Constraint checks:\n    \n    the amount value is &gt;= 0\n    the caller’s account balance is &gt;= amount\n    \n    Using aut you can transfer from an ERC20 token contract account, e.g. a Liquid Newton account.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _recipient\n    address\n    the recipient address\n    \n    \n    _amount\n    uint256\n    the value amount of Newton stake tokens being transferred\n    \n    \n    \n    \n    \n    Response\n    The method returns a boolean flag specifying whether the transfer was executed or not.\n    \n    \n    Event\n    On a successful call the function emits a Transfer event, logging: msg.sender, _recipient, amount.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut token transfer [OPTIONS] RECIPIENT AMOUNT\n    \n    \n    \n    \n    \n    Example\n    To transfer an amount of Newton stake token to a recipient specify the --ntn option:\n    \n    aut\n    \n    \n    aut token transfer --ntn 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 1| aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x17092d181653c4f13642698233966010a83a39f34846f65cef7dc860ad13644d\n    \n    \n    \n    To transfer an amount from an ERC20 contract token (e.g. Liquid Newton) to a recipient specify the contract address with the --token option:\n    \n    aut\n    \n    \n    aut token transfer --token 0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 10 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x2d78e64d82d1e54aeb487c4c10834dc3a1e17fabbd1f5775a2d72c6390db7b26"
  },
  {
    "objectID": "reference/api/aut/index.html#transferfrom",
    "href": "reference/api/aut/index.html#transferfrom",
    "title": "Autonity Contract Interface",
    "section": "transferFrom",
    "text": "transferFrom\n    Transfers a designated amount of Newton stake token from a specified sender account to a recipient account using the ERC20 approve()'](/reference/api/aut/#approve) and [allowance()’ mechanisms.\n    The transferFrom method is used for withdraw workflows where the token owner account (the sender) has authorised the method caller, the spender (the msg.sender), to transfer tokens on the owner’s behalf.\n    Constraint checks:\n    \n    sender and recipient accounts must be allowed to hold Newton stake token\n    the msg.sender (spender) has been approved by the owner (the sender) to withdraw tokens from their account\n    the msg.sender’s remaining allowance to withdraw the owner’s tokens is &gt;= amount\n    \n    Using aut you can call transferFrom on an ERC20 token contract (e.g. Liquid Newton) account.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    sender\n    address\n    the account from which Newton stake token are being transferred\n    \n    \n    recipient\n    address\n    the account to which Newton stake token are being transferred\n    \n    \n    amount\n    uint256\n    the value amount of Newton stake tokens being transferred\n    \n    \n    \n    \n    \n    Response\n    The method returns a boolean flag specifying whether the transfer was executed or not.\n    \n    \n    Event\n    On a successful call the function emits:\n    \n    a Transfer event, logging: msg.sender, _recipient, amount.\n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut token transfer-from [OPTIONS] SENDER RECIPIENT AMOUNT\n    \n    \n    \n    \n    \n    Example\n    To transfer an amount of Newton stake token to a recipient specify the --ntn option:\n    \n    aut\n    \n    \n    aut token transfer-from --ntn --from 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 0x11a87b260dd85ff7189d848fd44b28cc8505fa9c 0xbf2f718f948de541123f3e0a06a9100ee1df128c 1 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x2d277f8eee73d900f3cb3994796cfbb4ddef22ca78870344bf910bbd1b64f22c\n    \n    \n    \n    To transfer an amount from an ERC20 contract token (e.g. Liquid Newton) to a recipient specify the contract address with the --token option:\n    \n    aut\n    \n    \n    aut token transfer-from --token 0xf4D9599aFd90B5038b18e3B551Bc21a97ed21c37  --from 0xd4eddde5d1d0d7129a7f9c35ec55254f43b8e6d4 0x11a87b260dd85ff7189d848fd44b28cc8505fa9c 0xbf2f718f948de541123f3e0a06a9100ee1df128c 1 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x64a88723d7dd99e026029db531b6415e6e7a19fe131395059742065fcfe6575c"
  },
  {
    "objectID": "reference/api/aut/index.html#unbond",
    "href": "reference/api/aut/index.html#unbond",
    "title": "Autonity Contract Interface",
    "section": "unbond",
    "text": "unbond\n    Unbonds an amount of bonded stake from a designated validator.\n    The amount specifies Newton stake token if the delegator is unbonding self-bonded stake, else Liquid Newton if delegated stake is being unbonded.\n    \n    \n    \n    \n    \n    \n    Warning\n    \n    \n    \n    \n    \n    The unbonding request will only be effective after the unbonding period, rounded to the next epoch.\n    If the validator has a slashing event before this period expires, then the released Newton stake token amount may or may not correspond to the amount requested.\n    See Concept Accountability and fault detection (AFD) for Autonity’s slashing mechanism.\n    \n    \n    \n    Constraint checks are applied. The validator address provided is verified as a registered validator address and the requested unbonding amount is checked to verify it is &lt;= to the msg.sender’s bonded stake amount. For delegated stake this is done by checking the msg.Sender’s Liquid Newton balance is &gt;= to the requested amount, and for self-bonded stake this is done by checking the validator’s selfBondedStake balance is&gt;= to the requested unbonding amount.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If msg.Sender is the validator treasury account, then Liquid Newton balance and supply checks are not required.\n    This is because Liquid Newton is not issued for self-bonded stake. See Concept Staking and Penalty Absorbing Stake (PAS).\n    \n    \n    \n    On successful processing of the method call, an UnbondingRequest object for the necessary voting power change is created:\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    delegator\n    address payable\n    account address of the account unbonding stake\n    \n    \n    delegatee\n    address\n    validator identifier account address of the validator from which stake is being unbonded\n    \n    \n    amount\n    uint256\n    the amount of stake being unbonded from the delegatee account. It records the amount unbound in (a) Newton stake token for self-bonded stake, or (b) Liquid Newton for delegated stake\n    \n    \n    unbondingShare\n    uint256\n    the amount of shares issued for the unbonding staking pool that the unbonding amount represents\n    \n    \n    requestBlock\n    uint256\n    the block number at which an unbonding transaction was committed and from which the unbonding period begins\n    \n    \n    unlocked\n    bool\n    Boolean value indicating if the stake being unbonded is subject to a lock or not\n    \n    \n    selfDelegation\n    bool\n    Boolean value indicating if the unbonding is for self-bonded stake\n    \n    \n    \n    The unbonding period begins in the next block. The UnbondingRequest is tracked in memory. At the end of the epoch in which the unbond request was processed: - the designated amount of Liquid Newton amount is unlocked and burnt if the stake being unbonded is delegated and not self-bonded stake - calculation of the amount of stake to deduct from the unbonding pool, as well as the delegator’s share of the unbonding pool - the amount of Newton bonded to the validator is reduced by the unbonding amount\n    Then, at the end of the epoch in which the unbonding period expires Newton redemption occurs and the Newton that is due is minted to the staker’s Newton account.\n    \n    \n    \n    \n    \n    \n    Warning\n    \n    \n    \n    \n    \n    The amount of Newton released may be less than the unbonded amount if the validator has been slashed.\n    \n    \n    \n    \n    due Newton is minted to the delegator’s Newton account.\n    \n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _validator\n    address\n    the validator identifier address\n    \n    \n    amount\n    uint256\n    the amount of stake to be unbonded from the validator. Depending on the msg.Sender address the amount is for: (a) Newton stake token if the msg.Sender is the validator treasury and the unbond request is for self-bonded stake, or (b) Liquid Newton and the unbond request is for delegated stake\n    \n    \n    \n    \n    \n    Response\n    No response object is returned on successful execution of the method call.\n    The pending voting power change is tracked in memory until applied.\n    \n    \n    Event\n    On a successful call the function emits a NewUnbondingRequest event, logging: validator address, delegator address, selfBonded (boolean), amount unbonded.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut validator unbond [OPTIONS] AMOUNT\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut validator unbond --validator 0xA9F070101236476fe077F4A058C0C22E81b8A6C9  1 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0x3ac340e33f5ddfdab04ffe85ce4b564986b2f1a877720cb79bc9d31c11c8f318"
  },
  {
    "objectID": "reference/api/accountability/index.html",
    "href": "reference/api/accountability/index.html",
    "title": "Accountability Contract Interface",
    "section": "",
    "text": "Interface for interacting with Autonity Accountability Contract functions using:"
  },
  {
    "objectID": "reference/api/accountability/index.html#canaccuse",
    "href": "reference/api/accountability/index.html#canaccuse",
    "title": "Accountability Contract Interface",
    "section": "canAccuse",
    "text": "canAccuse\n    Called by a reporting validator to determine if (a) an offending validator can be accused of a rule infraction, and, (b) the number of blocks before which an accusation can be submitted.\n    Returns (a) a boolean flag specifying if the validator is accusable or not, and, (b) the number of blocks remaining in the innocence proof submission window before a new Accusation proof can be be submitted on-chain.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    A reporting validator can only submit an accusation against an offending validator if the offending validator:\n    \n    has not already been slashed in the epoch in which the accusation is being made for an offence with a higher severity. Slashing history is checked to determine this.\n    is not currently already under accusation. In this case, a new accusation cannot be made until expiry of the innocence window during which an accused validator is able to submit an Innocence proof refuting the accusation. This creates a deadline before which a new Accusation proof cannot be submitted. Pending validator accusations are checked to determine this.\n    \n    Accusations do not automatically cause slashing. The innocence proof window is measured in blocks and gives the accused offending validator a window to detect an accusation and prove innocence by submitting an Innocence proof on-chain. If the offending validator already has an accusation pending, the accountability protocol determines the offender is not currently accusable. Protocol has to wait to determine if the accusation has been defended or, if not, promoted to a fault. Until then, it cannot determine if the offending validator has committed a rule infraction with a higher severity or not.\n    \n    \n    \n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _offender\n    address\n    identifier address of the offending validator\n    \n    \n    _rule\n    Rule\n    enumerated value providing the ID for the protocol rule\n    \n    \n    _block\n    uint256\n    block number at which the rule infraction occurred\n    \n    \n    \n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _result\n    bool\n    a boolean value specifying whether the reported infraction is accusable (true) or not (false)\n    \n    \n    _deadline\n    uint256\n    the number of blocks before the validator becomes acusable. Returns (a) a non zero value indicating the block height at which a pending accusation’s innocence window expires, or, (b) 0 indicating that there is no pending innocence window expiry\n    \n    \n    \n    \n    \n    Usage\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    To add - see Issue Accountability Contract Interface: add Usage and Examples to canAccuse, canSlash, getValidatorAccusation #103.\n    \n    \n    \n    \n    \n    Example\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    To add - see Issue Accountability Contract Interface: add Usage and Examples to canAccuse, canSlash, getValidatorAccusation #103."
  },
  {
    "objectID": "reference/api/accountability/index.html#canslash",
    "href": "reference/api/accountability/index.html#canslash",
    "title": "Accountability Contract Interface",
    "section": "canSlash",
    "text": "canSlash\n    Called by a reporting validator to determine if the infraction of a protocol rule by a designated offending validator has a severity higher than any rule infraction committed by the offending validator in the current epoch.\n    Returns true if the severity of the reported rule infraction is higher than that of any already reported.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Protocol only applies an accountability slashing for the fault with the highest severity committed in an epoch.\n    If the severity of the rule infraction reported is higher than any infraction faults committed by the offending validator in the current epoch, then it can lead to a slashing until a rule infraction with a higher severity is reported.\n    \n    \n    \n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _offender\n    address\n    identifier address of the offending validator\n    \n    \n    _rule\n    Rule\n    enumerated value providing the ID for the protocol rule\n    \n    \n    _block\n    uint256\n    block number at which the rule infraction occurred\n    \n    \n    \n    \n    \n    Response\n    The method returns a boolean flag specifying whether the reported infraction is slashable (true) or not (false).\n    \n    \n    Usage\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    To add - see Issue Accountability Contract Interface: add Usage and Examples to canAccuse, canSlash, getValidatorAccusation #103.\n    \n    \n    \n    \n    \n    Example\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    To add - see Issue Accountability Contract Interface: add Usage and Examples to canAccuse, canSlash, getValidatorAccusation #103."
  },
  {
    "objectID": "reference/api/accountability/index.html#getvalidatoraccusation",
    "href": "reference/api/accountability/index.html#getvalidatoraccusation",
    "title": "Accountability Contract Interface",
    "section": "getValidatorAccusation",
    "text": "getValidatorAccusation\n    Returns the most recent pending accusation reported for a validator. The method response may be empty if there is no associated validator accusation event object for the address argument provided.\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _val\n    address\n    identifier address of the validator\n    \n    \n    \n    \n    \n    Response\n    Returns an Event object of type Accusation consisting of:\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    chunks\n    uint8\n    counter of number of chunks in the event (for oversize accountability event)\n    \n    \n    chunkId\n    uint8\n    chunk index to construct the oversize accountability event\n    \n    \n    eventType\n    EventType\n    accountability event type: Accusation\n    \n    \n    rule\n    Rule\n    the identifier of the accountability Rule defined in the Accountability Fault Detector (AFD) rule engine.\n    \n    \n    reporter\n    address\n    the node address of the validator that reported this accountability event\n    \n    \n    offender\n    address\n    the node address of the validator accused of the accountability event.\n    \n    \n    rawProof\n    bytes\n    the rlp encoded bytes of the accountability proof object\n    \n    \n    block\n    uint256\n    block number at which the accountability event occurred\n    \n    \n    epoch\n    uint256\n    identifier of the epoch in which the accountability event occurred\n    \n    \n    reportingBlock\n    uint256\n    block number at which the accountability event was reported\n    \n    \n    messageHash\n    uint256\n    hash of the main evidence for the accountability event\n    \n    \n    \n    \n    \n    Usage\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    To add - see Issue Accountability Contract Interface: add Usage and Examples to canAccuse, canSlash, getValidatorAccusation #103.\n    \n    \n    \n    \n    \n    Example\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    To add - see Issue Accountability Contract Interface: add Usage and Examples to canAccuse, canSlash, getValidatorAccusation #103."
  },
  {
    "objectID": "reference/api/accountability/index.html#getvalidatorfaults",
    "href": "reference/api/accountability/index.html#getvalidatorfaults",
    "title": "Accountability Contract Interface",
    "section": "getValidatorFaults",
    "text": "getValidatorFaults\n    Returns proven misbehaviour faults reported for a validator. The method response may be empty if there are no associated validator FaultProof event object(s) for the address argument provided.\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _val\n    address\n    identifier address of the validator\n    \n    \n    \n    Returns an array of Event object(s) of type FaultProof consisting of:\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    chunks\n    uint8\n    counter of number of chunks in the event (for oversize accountability event)\n    \n    \n    chunkId\n    uint8\n    chunk index to construct the oversize accountability event\n    \n    \n    eventType\n    EventType\n    accountability event type: FaultProof\n    \n    \n    rule\n    Rule\n    the identifier of the accountability Rule defined in the Accountability Fault Detector (AFD) rule engine.\n    \n    \n    reporter\n    address\n    the node address of the validator that reported this accountability event\n    \n    \n    offender\n    address\n    the node address of the validator accused of the accountability event.\n    \n    \n    rawProof\n    bytes\n    the rlp encoded bytes of the accountability proof object\n    \n    \n    block\n    uint256\n    block number at which the accountability event occurred\n    \n    \n    epoch\n    uint256\n    identifier of the epoch in which the accountability event occurred\n    \n    \n    reportingBlock\n    uint256\n    block number at which the accountability event was reported\n    \n    \n    messageHash\n    uint256\n    hash of the main evidence for the accountability event\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x5a443704dd4B594B382c22a083e2BD3090A6feF3 getValidatorFaults _val\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x5a443704dd4B594B382c22a083e2BD3090A6feF3 getValidatorFaults 0x21bb01Ae8EB831fFf68EbE1D87B11c85a766C94C\n[]"
  },
  {
    "objectID": "reference/api/asm/stabilization/index.html",
    "href": "reference/api/asm/stabilization/index.html",
    "title": "Stabilization Contract Interface",
    "section": "",
    "text": "Interfaces for interacting with the ASM Stabilization Contract functions using:"
  },
  {
    "objectID": "reference/api/asm/stabilization/index.html#cdp-owner",
    "href": "reference/api/asm/stabilization/index.html#cdp-owner",
    "title": "Stabilization Contract Interface",
    "section": "CDP Owner",
    "text": "CDP Owner\n    \n    deposit\n    Deposit Collateral Token to a CDP using the ERC20 allowance mechanism.\n    Before calling this function, the CDP owner must approve the Stabilization contract to spend Collateral Token on their behalf for the full amount to be deposited.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    You can approve the Stabilization Contract as a spender of Newton Collateral Token using the aut command aut token approve [OPTIONS] SPENDER AMOUNT.\n    \n    \n    \n    Constraint checks are applied:\n    \n    the amount deposited is a non-zero amount\n    the amount deposited is &lt; the allowance amount that the CDP owner has approved the CDP contract to transfer.\n    \n    The CDP’s collateral balance is then incremented by the deposited amount.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    amount\n    uint256\n    Units of Collateral Token to deposit (non-zero)\n    \n    \n    \n    \n    \n    Response\n    None.\n    \n    \n    Event\n    On a successful call the function emits a Deposit event, logging: msg.sender, amount.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f deposit amount\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f --abi Stabilization.abi deposit 1000000000000000000 | aut tx sign - | aut tx send -\n    \n    \n    \n    \n    \n    \n    withdraw\n    Request a withdrawal of Collateral Token from a CDP.\n    On method execution, state is inspected to retrieve:\n    \n    the CDP principal, collateral, and debt amounts\n    the minimum collateralization and liquidation ratios from the Stabilization Contract config\n    the current Collateral Token price.\n    \n    Constraint checks are applied:\n    \n    invalid amount: the amount withdrawn is &lt; the CDP’s collateral amount\n    insufficient collateral: the withdrawn amount must not reduce the remaining Collateral Token amount below the minimum collateral ratio.\n    liquidatable: withdrawal does not make the CDP liquidatable. The withdrawn amount value must not reduce the CDP to an under collateralized state below the liquidation ratio.\n    \n    The CDP’s collateral balance is then decremented by the withdrawn amount and Collateral Token is transferred to the CDP owner.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    amount\n    uint256\n    Units of Collateral Token to withdraw (non-zero)\n    \n    \n    \n    \n    \n    Response\n    None.\n    \n    \n    Event\n    On a successful call the function emits a Withdraw event, logging: msg.sender, amount.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f withdraw amount\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f withdraw 1000000000000000000 | aut tx sign - | aut tx send -\n    \n    \n    \n    \n    \n    \n    borrow\n    Borrow Auton against CDP Collateral.\n    On method execution, state is inspected to retrieve:\n    \n    the current CDP borrow limit, and debt and accrued interest amounts\n    the minimum collateralization and liquidation ratios, and the minimum debt requirement from the Stabilization Contract config\n    the current Collateral Token price.\n    \n    Constraint checks are applied:\n    \n    invalid debt position: the debt after borrowing must satisfy the minimum debt requirement.\n    liquidatable: borrowing does not make the CDP liquidatable. The debt after borrowing amount value must not reduce the CDP to an under collateralized state below the liquidation ratio.\n    insufficient collateral: the borrowed amount must not exceed the borrow limit for the CDP. The debt after borrowing must not reduce the CDP to an under collateralized state below the minimum collateral ratio.\n    \n    The CDP’s debt is then incremented by the borrowed amount and Auton is minted to the CDP owner.\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    amount\n    uint256\n    Amount of Auton to borrow (non-zero)\n    \n    \n    \n    \n    \n    Response\n    None.\n    \n    \n    Event\n    On a successful call the function emits a Borrow event, logging: msg.sender, amount.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f borrow amount\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f borrow 1000000000000000000 | aut tx sign - | aut tx send -\n    \n    \n    \n    \n    \n    \n    repay\n    Make a payment towards a CDP debt. The transaction value is the payment amount.\n    On method execution, state is inspected to retrieve:\n    \n    the current CDP principal amount, and debt and accrued interest amounts\n    the minimum collateralization and liquidation ratios, and the minimum debt requirement from the Stabilization Contract config\n    the current Collateral Token price.\n    \n    Constraint checks are applied:\n    \n    no debt position: there is a debt; the CDP principal is &gt; 0.\n    invalid debt position: the debt after payment must satisfy the minimum debt requirement. The payment amount is &lt; the debt and the debt after the payment amount satisfies the minimum debt requirement.\n    \n    The payment is allocated to first cover outstanding interest debt on the CDP, and then repay CDP principal debt. If there is a surplus after principal repayment, then the surplus is returned to the CDP Owner.\n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    msg.value\n    uint256\n    The payment amount\n    \n    \n    \n    \n    \n    Response\n    None.\n    \n    \n    Event\n    On a successful call the function emits a Repay event, logging: msg.sender, msg.value.\n    \n    \n    Usage\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Use the aut tx command, specifying the Stabilization Contract address as the RECIPIENT address.\n    \n    \n    \n    \n    aut\n    \n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f --value amount repay\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f --value 1 repay | aut tx sign - | aut tx send -"
  },
  {
    "objectID": "reference/api/asm/stabilization/index.html#cdp-liquidator",
    "href": "reference/api/asm/stabilization/index.html#cdp-liquidator",
    "title": "Stabilization Contract Interface",
    "section": "CDP Liquidator",
    "text": "CDP Liquidator\n    \n    isLiquidatable\n    Determines if a CDP is liquidatable at the block height of the call.\n    Constraint checks are applied:\n    \n    good time: the block timestamp at the time of the call must be equal to or later than the CDP’s timestamp attribute, i.e. the time of the CDP’s last borrow or repayment (ensuring current and future liquidability is tested).\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The function tests liquidatibility by calling underCollateralized().\n    \n    \n    \n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    account\n    address\n    The CDP account address\n    \n    \n    \n    \n    \n    Response\n    The function returns a Boolean flag indicating if the CDP is liquidatable (True) or not (False).\n    \n    \n    Event\n    None.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f isLiquidatable account\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f isLiquidatable 0x1f790c60D974F5A8f88558CA90F743a71F009641\nfalse\n    \n    \n    \n    \n    \n    \n    liquidate\n    Liquidates a CDP that is undercollateralized.\n    The liquidator must pay all the CDP debt outstanding. As a reward, the liquidator will receive the collateral that is held in the CDP. The transaction value is the payment amount.\n    On method execution, state is inspected to retrieve:\n    \n    the current CDP debt, collateral, and accrued interest amounts\n    the liquidation ratio from the Stabilization Contract config\n    the current Collateral Token price.\n    \n    Constraint checks are applied:\n    \n    no debt position: there is a debt to liquidate; the CDP principal is &gt; 0.\n    not liquidatable: the CDP is under collateralized and eligible for liquidation.\n    insufficient payment: the payment amount is sufficient to pay off the CDP debt (principal and accrued interest). After covering the debt the surplus remaining from the payment is &gt;= 0.\n    \n    On processing the payment:\n    \n    the CDP’s debt is paid off and any payment surplus is refunded to the liquidator\n    the CDP’s Collateral Token is transferred to the liquidator\n    Auton to the value of the CDP’s debt is burnt.\n    \n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    account\n    address\n    The CDP account address to liquidate\n    \n    \n    msg.value\n    uint256\n    The payment amount\n    \n    \n    \n    \n    \n    Response\n    None.\n    \n    \n    Event\n    On a successful call the function emits a Liquidate event, logging: account, msg.sender.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f --value amount liquidate account\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract tx --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f --value 2500000000000000000 liquidate 0x1f790c60D974F5A8f88558CA90F743a71F009641 | aut tx sign - | aut tx send -"
  },
  {
    "objectID": "reference/api/asm/stabilization/index.html#cdp-view-functions",
    "href": "reference/api/asm/stabilization/index.html#cdp-view-functions",
    "title": "Stabilization Contract Interface",
    "section": "CDP View functions",
    "text": "CDP View functions\n    \n    accounts\n    Retrieve all the accounts that have opened a CDP.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    Returns an _accounts array of CDP account addresses:\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    account\n    address\n    The CDP account address\n    \n    \n    \n    \n    \n    Event\n    None.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f accounts\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f accounts\n[\"0x1f790c60D974F5A8f88558CA90F743a71F009641\"]\n    \n    \n    \n    \n    \n    \n    borrowLimit\n    Calculates the maximum amount of Auton that can be borrowed for the given amount of Collateral Token.\n    Constraint checks are applied:\n    \n    invalid parameter: the price and mcr argument values are valid, i.e. are not equal to 0.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The borrowing limit amount is calculated by (collateral * price * targetPrice) / (mcr * SCALE_FACTOR).\n    Where:\n    \n    SCALE_FACTOR is the Stabilisation Contract multiplier for scaling numbers to the required scale of decimal places in fixed-point integer representation. SCALE_FACTOR = 10 ** SCALE.\n    SCALE is the Stabilisation Contract setting for decimal places in fixed-point integer representation. SCALE = 18.\n    \n    \n    \n    \n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    collateral\n    uint256\n    Amount of Collateral Token backing the debt\n    \n    \n    price\n    uint256\n    The price of Collateral Token in Auton\n    \n    \n    targetPrice\n    uint256\n    The ACU value of 1 unit of debt\n    \n    \n    mcr\n    uint256\n    The minimum collateralization ratio\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    For the default values set for targetPrice and mcr see Reference, Genesis, ASM stabilization config.\n    The current price value can be returned by calling collateralPrice().\n    \n    \n    \n    \n    \n    Response\n    The function returns the maximum amount of Auton that can be borrowed as an uint256 integer value.\n    \n    \n    Event\n    None.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f borrowLimit collateral price targetPrice mcr\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f borrowLimit 4000000000000000000 9816500000000000000 1000000000000000000 2000000000000000000\n19633000000000000000\n    \n    \n    \n    \n    \n    \n    collateralPrice\n    Retrieves the Collateral Token price from the Oracle Contract and converts it to Auton.\n    The function reverts in case the price is invalid or unavailable.\n    Constraint checks are applied:\n    \n    price unavailable: the Oracle Contract is providing data computed in the oracle network’s last completed voting round.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    To get this data the Oracle Contract function latestRoundData() is called. This returns the latest available median price data for a currency pair symbol. If the last oracle voting round failed to successfully compute a new median price, then it will return the most recent median price for the requested symbol.\n    \n    \n    \n    \n    invalid price: the price returned by the Oracle Contract is not equal to 0.\n    \n    On method execution, state is inspected to retrieve:\n    \n    the latest computed Collateral Token price data and the Oracle Contract scale precision from the Oracle Contract.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The function converts the Collateral Token price retrieved from the Oracle Contract to SCALE decimals used by the Stabilisation Contract.\n    Conversion is conditional upon the difference between the Stabilisation Contract and Oracle Contract scale and precision:\n    \n    if (SCALE_FACTOR &gt; precision), then collateral price = price * (SCALE_FACTOR / precision\n    else collateral price = price / (precision() / SCALE_FACTOR).\n    \n    Where:\n    \n    SCALE_FACTOR is the Stabilisation Contract multiplier for scaling numbers to the required scale of decimal places in fixed-point integer representation. SCALE_FACTOR = 10 ** SCALE.\n    SCALE is the Stabilisation Contract setting for decimal places in fixed-point integer representation. SCALE = 18.\n    price is the aggregated median price for Collateral Token calculated by the Oracle Contract (returned by calling latestRoundData()).\n    precision is the Oracle Contract setting for the multiplier applied to submitted data price reports before calculation of an aggregated median price for a symbol (returned by calling getPrecision()).\n    \n    \n    \n    \n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    price\n    uint256\n    Price of Collateral Token\n    \n    \n    \n    \n    \n    Event\n    None.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f collateralPrice\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f collateralPrice\n10019717700000000000\n    \n    \n    \n    \n    \n    \n    debtAmount\n    Calculates the current debt amount outstanding for a CDP at the block height of the call.\n    Constraint checks are applied:\n    \n    good time: the block timestamp at the time of the call must be equal to or later than the CDP’s timestamp attribute, i.e. the time of the CDP’s last borrow or repayment (ensuring current and future liquidability is tested).\n    \n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    account\n    address\n    the CDP account address\n    \n    \n    timestamp\n    uint\n    the timestamp to value the debt. The timestamp is provided as a Unix time value\n    \n    \n    \n    \n    \n    Response\n    The function returns the debt amount as an uint256 integer value.\n    \n    \n    Event\n    None.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f debtAmount account timestamp\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f debtAmount 0x1f790c60D974F5A8f88558CA90F743a71F009641 1695740525\n300012369185855391\n    \n    \n    \n    \n    \n    \n    interestDue\n    Calculates the interest due for a given amount of debt.\n    Constraint checks are applied:\n    \n    invalid parameter: the timeBorrow argument is not greater than the timeDue argument value.\n    \n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    debt\n    uint256\n    The debt amount\n    \n    \n    rate\n    uint256\n    The borrow interest rate\n    \n    \n    timeBorrow\n    uint\n    The borrow time. The timestamp is provided as a Unix time value\n    \n    \n    timeDue\n    uint\n    The time the interest is due. The timestamp is provided as a Unix time value\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    For the default value set for rate see Reference, Genesis, ASM stabilization config.\n    \n    \n    \n    \n    \n    Response\n    The function returns the amount of interest due as an uint256 integer value.\n    \n    \n    Event\n    None.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f interestDue debt rate timeBorrow timeDue\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f interestDue 1000000000000000000 50000000000000000 1695308566 1697900566\n4118044981651418\n    \n    \n    \n    \n    \n    \n    minimumCollateral\n    Calculates the minimum amount of Collateral Token that must be deposited in the CDP in order to borrow the given amount of Autons.\n    Constraint checks are applied:\n    \n    invalid parameter: the price and mcr argument values are valid, i.e. are not equal to 0.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The minimum collateral amount is calculated by (principal * mcr) / price.\n    \n    \n    \n    \n    Parameters\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    principal\n    uint256\n    Auton amount to borrow\n    \n    \n    price\n    uint256\n    The price of Collateral Token in Auton\n    \n    \n    mcr\n    uint256\n    The minimum collateralization ratio\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    For the default value set for mcr see Reference, Genesis, ASM stabilization config.\n    The current price value can be returned by calling collateralPrice().\n    \n    \n    \n    \n    \n    Response\n    The function returns the minimum collateral required as an uint256 integer value.\n    \n    \n    Event\n    None.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f minimumCollateral principal price mcr\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f minimumCollateral 1000000000000000000 9672000000000000000 2000000000000000000\n206782464846980976\n    \n    \n    \n    \n    \n    \n    underCollateralized\n    Determines if a debt position is undercollateralized or not.\n    Constraint checks are applied:\n    \n    invalid price: the value of the price argument is valid, i.e. it is not equal to 0.\n    \n    If the CDP is under collateralized, then it can be liquidated - see liquidate().\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    If a debt position is under collateralized or not is determined by calculating (collateral * price) / debt. If this returns a value &lt; liquidationRatio, then the CDP is under collateralised and can be liquidated.\n    \n    \n    \n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    collateral\n    uint256\n    Amount of Collateral Token backing the debt\n    \n    \n    price\n    uint256\n    The price of Collateral Token in Auton\n    \n    \n    debt\n    uint256\n    The debt amount\n    \n    \n    liquidationRatio\n    uint256\n    The liquidation ratio\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    For the default value set for liquidationRatio see Reference, Genesis, ASM stabilization config.\n    The current price value can be returned by calling collateralPrice().\n    \n    \n    \n    \n    \n    Response\n    The method returns a boolean flag specifying whether the CDP is undercollateralized (true) or not (false).\n    \n    \n    Event\n    None.\n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f underCollateralized collateral price debt liquidationRatio\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f underCollateralized 206782464846980976 9672000000000000000 1000000000000000000 1800000000000000000\nfalse"
  },
  {
    "objectID": "reference/api/asm/acu/index.html",
    "href": "reference/api/asm/acu/index.html",
    "title": "ACU Contract Interface",
    "section": "",
    "text": "Interfaces for interacting with the ASM Auton Currency Unit Contract functions using:"
  },
  {
    "objectID": "reference/api/asm/acu/index.html#value",
    "href": "reference/api/asm/acu/index.html#value",
    "title": "ACU Contract Interface",
    "section": "value",
    "text": "value\n    Returns the latest value computed for the ACU index.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _value\n    int256\n    the ACU value in fixed-point integer representation\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x8Be503bcdEd90ED42Eff31f56199399B2b0154CA value\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x8Be503bcdEd90ED42Eff31f56199399B2b0154CA value\n98410"
  },
  {
    "objectID": "reference/api/asm/acu/index.html#symbols",
    "href": "reference/api/asm/acu/index.html#symbols",
    "title": "ACU Contract Interface",
    "section": "symbols",
    "text": "symbols\n    Returns the currency pair symbols used to compute the ACU index.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _symbols\n    string array\n    a comma-separated list of the currency pair symbols used to compute the ACU index value\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x8Be503bcdEd90ED42Eff31f56199399B2b0154CA symbols\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x8Be503bcdEd90ED42Eff31f56199399B2b0154CA symbols\n[\"AUD-USD\", \"CAD-USD\", \"EUR-USD\", \"GBP-USD\", \"JPY-USD\", \"USD-USD\", \"SEK-USD\"]"
  },
  {
    "objectID": "reference/api/asm/acu/index.html#quantities",
    "href": "reference/api/asm/acu/index.html#quantities",
    "title": "ACU Contract Interface",
    "section": "quantities",
    "text": "quantities\n    Returns the basket quantities used to compute the ACU index value.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _quantities\n    uint256 array\n    an array of the quantities\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x8Be503bcdEd90ED42Eff31f56199399B2b0154CA quantities\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x8Be503bcdEd90ED42Eff31f56199399B2b0154CA quantities\n[21300, 18700, 14300, 10400, 1760000, 18000, 141000]"
  },
  {
    "objectID": "reference/api/asm/supplycontrol/index.html",
    "href": "reference/api/asm/supplycontrol/index.html",
    "title": "Supply Control Contract Interface",
    "section": "",
    "text": "Interfaces for interacting with the ASM Supply Control Contract functions using:"
  },
  {
    "objectID": "reference/api/asm/supplycontrol/index.html#availablesupply",
    "href": "reference/api/asm/supplycontrol/index.html#availablesupply",
    "title": "Supply Control Contract Interface",
    "section": "availableSupply",
    "text": "availableSupply\n    Returns the supply of Auton available for minting.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    availableSupply\n    uint\n    the amount of Auton available for minting as an integer value\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x47c5e40890bcE4a473A49D7501808b9633F29782 availableSupply\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x47c5e40890bcE4a473A49D7501808b9633F29782 availableSupply\n115792089237316195423570985008687907853269984665640564039457584007913129639935"
  },
  {
    "objectID": "reference/api/asm/supplycontrol/index.html#stabilizer",
    "href": "reference/api/asm/supplycontrol/index.html#stabilizer",
    "title": "Supply Control Contract Interface",
    "section": "stabilizer",
    "text": "stabilizer\n    Returns the Stabilization Contract address, the stabilizer account that is authorized to mint and burn Auton.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    address\n    address\n    the Stabilization Contract address\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x47c5e40890bcE4a473A49D7501808b9633F29782 stabilizer\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x47c5e40890bcE4a473A49D7501808b9633F29782 stabilizer\n\"0x29b2440db4A256B0c1E6d3B4CDcaA68E2440A08f\""
  },
  {
    "objectID": "reference/api/asm/supplycontrol/index.html#totalsupply",
    "href": "reference/api/asm/supplycontrol/index.html#totalsupply",
    "title": "Supply Control Contract Interface",
    "section": "totalSupply",
    "text": "totalSupply\n    Returns the total supply of Auton under management.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    Auton Supply\n    uint256\n    the total supply of Auton under management\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x47c5e40890bcE4a473A49D7501808b9633F29782 totalSupply\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x47c5e40890bcE4a473A49D7501808b9633F29782 --abi SupplyControl.abi totalSupply\n115792089237316195423570985008687907853269984665640564039457584007913129639935"
  },
  {
    "objectID": "reference/api/asm/index.html",
    "href": "reference/api/asm/index.html",
    "title": "ASM Contract Interface",
    "section": "",
    "text": "Interfaces for interacting with Auton Stabilization Mechanism Contract functions using:\n    \n    The aut command-line RPC client to submit calls to inspect state and state-affecting transactions.\n    \n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    Examples for calling functions from aut use the setup described in the How to Submit a transaction from Autonity Utility Tool (aut).\n    Usage and Examples illustrate using the ASM Contracts’ generated ABI and the aut tool’s contract command to call the ASM Contract functions. See aut contract call --help.\n    Usage and Examples assume the path to the ABI file has been set in aut’s configuration file .autrc. The contract .abi files are generated when building the client from source and can be found in your autonity installation directory at ./params/generated/. Alternatively, you can generate the ABI using the abigen cmd utility if you built from source (See Install Autonity, Build from source code)."
  },
  {
    "objectID": "reference/api/oracle/index.html",
    "href": "reference/api/oracle/index.html",
    "title": "Oracle Contract Interface",
    "section": "",
    "text": "Interface for interacting with Autonity Oracle Contract functions using:"
  },
  {
    "objectID": "reference/api/oracle/index.html#getprecision",
    "href": "reference/api/oracle/index.html#getprecision",
    "title": "Oracle Contract Interface",
    "section": "getPrecision",
    "text": "getPrecision\n    Returns the precision to be used with price reports.\n    The precision is set as a constant to the integer value 10000000.\n    The precision is the multiplier applied to price data points before aggregation and calculation of a median price for symbols by the Oracle Contract. Data consumers can convert the aggregated value to decimal places by dividing with the precision value.\n    \n    \n    \n    \n    \n    \n    Conversion to decimal places\n    \n    \n    \n    \n    \n    For example, the symbol price for a currency pair is submitted with the value 1.001. The price is multiplied with precision 10000000, giving 10010000 which is the value submitted for price aggregation in the Oracle Contract. A data consumer can use the precision to convert the L2 aggregation value to decimal precision for their use case. For example, a median price of 12971000 converts to 1.2791.\n    \n    \n    \n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    precision\n    uint256\n    the decimal precision multiplier applied to currency pair symbol price reports before aggregation. Set as a constant to 10000000\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getPrecision\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getPrecision\n10000000"
  },
  {
    "objectID": "reference/api/oracle/index.html#getround",
    "href": "reference/api/oracle/index.html#getround",
    "title": "Oracle Contract Interface",
    "section": "getRound",
    "text": "getRound\n    Returns the index number of the current oracle contract voting round.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    round\n    uint256\n    the number of the current oracle voting round\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getRound\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getRound\n1809"
  },
  {
    "objectID": "reference/api/oracle/index.html#getrounddata",
    "href": "reference/api/oracle/index.html#getrounddata",
    "title": "Oracle Contract Interface",
    "section": "getRoundData",
    "text": "getRoundData\n    Returns the median price data for a currency pair symbol at a given oracle voting round.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _round\n    uint256\n    the oracle voting round index number for which the current price is requested\n    \n    \n    _symbol\n    string\n    the currency pair symbol for which the current price is requested\n    \n    \n    \n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    round\n    uint256\n    the index number of the oracle voting round in which the price was generated\n    \n    \n    _p.price\n    uint256\n    the median price for the requested currency pair symbol\n    \n    \n    _p.timestamp\n    string\n    the timestamp of the block height at which the returned price was calculated; the timestamp is in Unix Timestamp format\n    \n    \n    _p.status\n    uint\n    status value indicating if the median price was calculated successfully or not in the requested round; value of 0 (FAILURE) or 1 (SUCCESS). If a price was not successfully calculated in the requested round, then the price returned is the most recently generated price for the requested symbol and was generated at the returned block timestamp.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Note that median price calculation happens when the last block of a round is finalised. If getRoundData() is called with the current round number, then it will return zero because the price aggregation hasn’t been executed yet.\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getRoundData _round _symbol\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getRoundData 1809 \"SEK-USD\"\n{\"round\": 1809, \"price\": 899334, \"timestamp\": 1694668219, \"status\": 0}"
  },
  {
    "objectID": "reference/api/oracle/index.html#getsymbols",
    "href": "reference/api/oracle/index.html#getsymbols",
    "title": "Oracle Contract Interface",
    "section": "getSymbols",
    "text": "getSymbols\n    Returns the currency pair symbols for which the oracle generates price reports.\n    Note that if the symbols supported by the oracle are changed that there is a delay of 2 voting rounds before prices are reported for the new symbols. This is because if symbols are updated at round number r then:\n    \n    oracles submit price data commits for the new symbols the following round in r + 1\n    prices for the new symbols are computed by the oracle network in r + 2 when the commits are revealed and prices voted on by the oracle voters.\n    \n    If the getSymbols call is made at r + 1, then it will return the updated symbols for which prices will be generated at r + 2.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    symbols\n    string array\n    a comma-separated list of the currency pair symbols for which price reports are generated\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getSymbols\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getSymbols\n[\"AUD-USD\", \"CAD-USD\", \"EUR-USD\", \"GBP-USD\", \"JPY-USD\", \"SEK-USD\", \"ATN-USD\", \"NTN-USD\"]"
  },
  {
    "objectID": "reference/api/oracle/index.html#getvoteperiod",
    "href": "reference/api/oracle/index.html#getvoteperiod",
    "title": "Oracle Contract Interface",
    "section": "getVotePeriod",
    "text": "getVotePeriod\n    Returns the oracle contract setting for the interval at which the oracle network initiates a new oracle round for submitting, voting, and aggregating data points for oracle price reports. The interval is measured in blocks.\n    Vote period is set at network genesis, see Reference, Genesis,oracle config.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    votePeriod\n    uint256\n    integer value expressing the duration of an oracle round, measured in blocks\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getVotePeriod\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getVotePeriod\n30"
  },
  {
    "objectID": "reference/api/oracle/index.html#getvoters",
    "href": "reference/api/oracle/index.html#getvoters",
    "title": "Oracle Contract Interface",
    "section": "getVoters",
    "text": "getVoters\n    Returns the current list of oracle voters from memory.\n    The response is returned as a list of oracle identifier addresses, sorted in descending dictionary order.\n    \n    Parameters\n    None.\n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    address\n    address array\n    a comma-separated list of the oracle addresses for the current Oracle Voter set\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getVoters\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D getVoters   \n[\"0xf8D8c4818Fd21B4be57a0ACD619fdD88ec7A858c\", \"0xd4d2874450a21f1Bf5E1C12260773d8716b526B8\", \"0x636d3D9711F0f3907313dC5E2Aa08e73c0608A03\"]"
  },
  {
    "objectID": "reference/api/oracle/index.html#latestrounddata",
    "href": "reference/api/oracle/index.html#latestrounddata",
    "title": "Oracle Contract Interface",
    "section": "latestRoundData",
    "text": "latestRoundData\n    Returns the latest available median price data for a currency pair symbol. The price returned is the one generated in the last successfully completed oracle voting round.\n    If the last oracle voting round failed to successfully compute a new median price, then it will return the most recent median price for the requested symbol.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    _symbol\n    string\n    the currency pair symbol for which the current oracle price is requested\n    \n    \n    \n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    round-1\n    uint256\n    the index number of the oracle voting round in which the price was generated. This is always 1 less than the number of the oracle’s voting round at the time of the call\n    \n    \n    _p.price\n    uint256\n    the latest median price for the requested currency pair symbol\n    \n    \n    _p.timestamp\n    string\n    the timestamp of the block height at which the returned price was calculated; the timestamp is in Unix Timestamp format\n    \n    \n    _p.status\n    uint\n    status value indicating if the median price was calculated successfully or not in round-1, represented by a value of 1 (SUCCESS) or 0 (FAILURE). If a price was not successfully calculated, then the price returned is the most recently generated price for the requested symbol and was generated at the returned block timestamp.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Unix time represents time as an integer value recording the number of seconds since 1 January 1970 00:00:00 UTC.\n    This can easily be converted to a human-readable form, for example:\n    \n    programmatically, using the Python datetime library fromtimestamp() function\n    on the web, using online converters like https://www.unixtimestamp.com/index.php .\n    \n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D latestRoundData _symbol\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x47e9Fbef8C83A1714F1951F142132E6e90F5fa5D latestRoundData \"SEK-USD\"\n{\"round\": 47631, \"price\": 963459, \"timestamp\": 1688390007, \"status\": 0}"
  },
  {
    "objectID": "reference/api/index.html",
    "href": "reference/api/index.html",
    "title": "Autonity Interfaces",
    "section": "",
    "text": "Helper libraries\n    \n    \n    \n    \n    \n    Useful helpers for working with RPC\n    Interface usage and examples are shown using the Autonity Utility Tool (aut).\n    Remote Procedure Call (RPC) that read state can also be done using curl. You may already have curl installed on your system as it comes with many OS distributions.\n    A good helper for working with JSON response objects returned by RPC is jq."
  },
  {
    "objectID": "reference/api/liquid-newton/index.html",
    "href": "reference/api/liquid-newton/index.html",
    "title": "Liquid Newton Contract Interface",
    "section": "",
    "text": "The LiquidNewton contract is deployed by the Autonity contract in response to validator registration. It implements the Liquid Newton token for that validator, and handles the distribution of staking rewards to all delegators.\nThe address of the Liquid Newton contract for a given validator can be determined by the information returned from the Autonity contract getValidator method (see here for details of how to query this using the Autonity Utility Tool aut).\nLiquid Newton tokens implement the ERC20 interface, and so all ERC20 calls are implemented. The following public methods are also available for handling the reward distribution and querying Liquid Newton balances."
  },
  {
    "objectID": "reference/api/liquid-newton/index.html#unclaimedrewards",
    "href": "reference/api/liquid-newton/index.html#unclaimedrewards",
    "title": "Liquid Newton Contract Interface",
    "section": "unclaimedRewards",
    "text": "unclaimedRewards\n    Queries the contract and returns the total rewards owed to a given account.\n    This function is used by the aut validator unclaimed-rewards command of aut. Further details are given in the “Claiming staking rewards” section."
  },
  {
    "objectID": "reference/api/liquid-newton/index.html#claimrewards",
    "href": "reference/api/liquid-newton/index.html#claimrewards",
    "title": "Liquid Newton Contract Interface",
    "section": "claimRewards",
    "text": "claimRewards\n    Computes the total rewards owed to the caller, and sends the appropriate amount of auton.\n    The aut validator claim-rewards command uses this function. Usage details and examples are given in the “Claiming staking rewards” section."
  },
  {
    "objectID": "reference/api/liquid-newton/index.html#lockedbalanceof",
    "href": "reference/api/liquid-newton/index.html#lockedbalanceof",
    "title": "Liquid Newton Contract Interface",
    "section": "lockedBalanceOf",
    "text": "lockedBalanceOf\n    Queries the contract and returns the amount of locked Liquid Newton held by a stake delegator’s account.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    delegator\n    address\n    the account address of the Liquid Newton holder for which the locked balance amount is requested\n    \n    \n    \n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    amount\n    uint256\n    the account balance for Liquid Newton in a locked state\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address lockedBalanceOf delegator\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x109f93893af4c4b0afc7a9e97b59991260f98313  lockedBalanceOf 0xF47FDD88C8f6F80239E177386cC5AE3d6BCdEeEa\n0"
  },
  {
    "objectID": "reference/api/liquid-newton/index.html#unlockedbalanceof",
    "href": "reference/api/liquid-newton/index.html#unlockedbalanceof",
    "title": "Liquid Newton Contract Interface",
    "section": "unlockedBalanceOf",
    "text": "unlockedBalanceOf\n    Queries the contract and returns the amount of unlocked Liquid Newton held by a stake delegator’s account.\n    \n    Parameters\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    delegator\n    address\n    the account address of the Liquid Newton holder for which the unlocked balance amount is requested\n    \n    \n    \n    \n    \n    Response\n    \n    \n    \n    \n    \n    \n    \n    \n    Field\n    Datatype\n    Description\n    \n    \n    \n    \n    amount\n    uint256\n    the account balance for Liquid Newton in an unlocked state\n    \n    \n    \n    \n    \n    Usage\n    \n    aut\n    \n    \n    aut contract call --address unlockedBalanceOf delegator\n    \n    \n    \n    \n    \n    Example\n    \n    aut\n    \n    \n    aut contract call --address 0x109f93893af4c4b0afc7a9e97b59991260f98313 unlockedBalanceOf 0xF47FDD88C8f6F80239E177386cC5AE3d6BCdEeEa\n0"
  },
  {
    "objectID": "reference/api/web3/index.html",
    "href": "reference/api/web3/index.html",
    "title": "Web3 Namespace",
    "section": "",
    "text": "Autonity supports the following Geth Web3 APIs. Click on the links to go to the relevant Geth documentation:\n    \n    admin namespace\n    debug namespace\n    eth namespace\n    net namespace\n    personal namespace\n    txpool namespace\n    \n    Autonity does not support the Geth Web3 APIs:\n    \n    clique namespace\n    les namespace\n    miner namespace"
  },
  {
    "objectID": "reference/codebase/index.html",
    "href": "reference/codebase/index.html",
    "title": "Codebase",
    "section": "",
    "text": "Autonity is a fork of Geth.\n    For the base Geth golang reference documentation see Go Ethereum v1.10.16 on pkg.go.dev.\n    For the Solidity reference documentation see Solidity."
  },
  {
    "objectID": "reference/protocol/index.html",
    "href": "reference/protocol/index.html",
    "title": "Protocol Parameters",
    "section": "",
    "text": "Autonity Protocol parameters specify economic, consensus, temporal, and governance settings of an Autonity Network. They are specified as part of the genesis.json file at network genesis and may be updated by the network’s governance account."
  },
  {
    "objectID": "reference/protocol/index.html#parameters",
    "href": "reference/protocol/index.html#parameters",
    "title": "Protocol Parameters",
    "section": "Parameters",
    "text": "Parameters\n    \n    \n    \n    Parameter\n    Description\n    Genesis Configuration\n    Post Genesis Update Mechanism\n    \n    \n    \n    \n    minBaseFee\n    minimum price for a unit of gas used to compute a transaction on the network\n    See config.autonity.minBaseFee\n    See setMinimumBaseFee()\n    \n    \n    gasLimit\n    maximum amount of gas expenditure allowed for computing the genesis block, and then blocks thereafter\n    See config.gasLimit\n    None\n    \n    \n    treasury account\n    protocol’s treasury account for receiving treasury fees used for Autonity community funds\n    See config.autonity.treasury\n    See setTreasuryAccount()\n    \n    \n    treasuryFee\n    the percentage of staking rewards deducted for community funds.\n    See config.autonity.treasuryFee\n    See setTreasuryFee()\n    \n    \n    maxCommitteeSize\n    maximum number of consensus committee members\n    See config.autonity.maxCommitteeSize\n    See setCommitteeSize()\n    \n    \n    delegationRate\n    the percentage of staking rewards deducted by validators as a commission from delegated stake\n    See config.autonity.delegationRate\n    None (Individual validators can reset their rate after registration. See changeCommissionRate())\n    \n    \n    unbondingPeriod\n    the period of time bonded stake must wait before Newton can be redeemed after unbonding, defined as a number of blocks. The unbonding period can be any integer number &gt; 0, but must be longer than the epoch period.\n    See config.autonity.unbondingPeriod\n    See setUnbondingPeriod()\n    \n    \n    epochPeriod\n    the period of time for which a consensus committee is elected, defined as a number of blocks\n    See config.autonity.epochPeriod\n    See setEpochPeriod()\n    \n    \n    blockPeriod\n    the minimum time interval between two consecutive blocks, measured in seconds\n    See config.autonity.blockPeriod\n    None\n    \n    \n    governance operator account\n    address of the Autonity Protocol, Autonity Oracle Contract, and ASM Contracts governance account\n    See config.autonity.operator\n    See setOperatorAccount()\n    \n    \n    Oracle symbols\n    the currency pairs that the oracle network provides data points for\n    See config.oracle.symbols\n    See setSymbols()\n    \n    \n    Oracle votePeriod\n    the time interval at which the oracle network initiates a new oracle round for submitting and voting on oracle data, measured in blocks\n    See config.oracle.votePeriod\n    None\n    \n    \n    ASM ACU symbols, quantities, scale\n    the ACU currency basket configuration\n    See config.asm.acu object\n    See modifyBasket()\n    \n    \n    ASM Stabilization liquidationRatio\n    the minimum ACU value of collateral required to maintain 1 ACU value of debt\n    See config.asm.stabilization object\n    See setLiquidationRatio()\n    \n    \n    ASM Stabilization minCollateralizationRatio\n    the minimum ACU value of collateral required to borrow 1 ACU value of debt\n    See config.asm.stabilization object\n    See setMinCollateralizationRatio()\n    \n    \n    ASM Stabilization minDebtRequirement\n    the minimum amount of debt required to maintain a CDP\n    See config.asm.stabilization object\n    See setMinDebtRequirement()\n    \n    \n    ASM Stabilization minDebtRequirement\n    the minimum amount of debt required to maintain a CDP\n    See config.asm.stabilization object\n    See setMinDebtRequirement()\n    \n    \n    ASM Stabilization oracle contract address\n    the Autonity Oracle Contract address\n    See Concept Architecture and Autonity Oracle Contract\n    See setOracle()\n    \n    \n    ASM Stabilization supplyControl contract address\n    the ASM Supply Control Contract address\n    See Concept Architecture and ASM Supply Control Contract\n    See setSupplyControl()"
  },
  {
    "objectID": "reference/genesis/index.html",
    "href": "reference/genesis/index.html",
    "title": "Genesis",
    "section": "",
    "text": "Genesis configuration for public Autonity networks is built into the client’s configuration. If setting up a local testnet, for example a private devnet, configuration has to be specified when initialising the node."
  },
  {
    "objectID": "reference/genesis/index.html#public-autonity-network-configuration",
    "href": "reference/genesis/index.html#public-autonity-network-configuration",
    "title": "Genesis",
    "section": "Public Autonity Network configuration",
    "text": "Public Autonity Network configuration\n    Configuring the client to join a public network is done by setting the network as a command-line option when initialising the Autonity Go Client. The client will then auto-detect the network genesis configuration and bootnodes, connect, and sync.\n    \n    Public network flags\n    \n    \n    \n    Network\n    Command-line option\n    Network settings\n    \n    \n    \n    \n    Bakerloo Testnet\n    --bakerloo command-line option\n    Genesis configuration\n    \n    \n    Piccadilly Testnet\n    --piccadilly command-line option\n    Genesis configuration\n    \n    \n    \n    For details of individual public network purpose and use see the Networks section."
  },
  {
    "objectID": "reference/genesis/index.html#local-autonity-network-configuration",
    "href": "reference/genesis/index.html#local-autonity-network-configuration",
    "title": "Genesis",
    "section": "Local Autonity Network configuration",
    "text": "Local Autonity Network configuration\n    For launching a local Autonity network, genesis configuration and bootnodes need to be specified when running the client:\n    \n    Genesis configuration file. To set genesis state of your local Autonity network you will need to provide your own custom genesis.json configuration file, a JSON formatted file containing the initialisation configuration for the network. This file defines:\n    \n    the genesis block and that block’s header\n    protocol parameters configuring protocol rules of the network\n    validators from which the genesis consensus committee will be selected\n    oracle network configuration\n    accounts to be created at network genesis: initial allocation of Auton to EOA accounts; contract accounts.\n    \n    Bootnodes. Bootnodes can be provided statically as a file or as a command-line option when running the client. To provide statically, specify a static-nodes.json file, or as a comma-separated list in the --bootnodes command-line option.\n    \n    \n    Genesis configuration file\n    \n    JSON data structures\n    Genesis configuration file JSON objects:\n    \n    genesis file\n    config\n    config.autonity\n    config.autonity.validators\n    config.asm\n    config.asm.acu\n    config.asm.stabilization\n    config.asm.supplyControl\n    config.accountability\n    config.oracle\n    alloc\n    alloc.account object\n    \n    \n    \n    Genesis file object\n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    config\n    Configuration variables for the Autonity Network blockchain\n    See config object\n    \n    \n    nonce\n    Maintained by the Autonity Protocol for backward compatibility reasons in the EVM.\n    Set to 0 (0x0 in hexadecimal)\n    \n    \n    timestamp\n    Specifies the time point when the network starts mining and the first block is mined. If set to 0 the node will start mining on deployment. If a future time point is specified, then miners will wait until timestamp + blockPeriod to begin mining. The local node consensus engine will start when its local Unix clock reaches the timestamp value. The Validator node operator must keep their local node in sync, i.e. by the Network Time Protocol (NTP)\n    Set to 0 (0x0) to start node mining on connection to the Autonity network\n    \n    \n    baseFee\n    The base gas price for computing a transaction on an Autonity network after genesis. The base fee is adjusted per the EIP 1559 fee market mechanism. See Concepts, EIP 1559 Transaction fee mechanism (TFM)\n    Set to: 15000000000\n    \n    \n    gasLimit\n    The maximum amount of gas expenditure allowed for a block, placing a ceiling on transaction computations possible within a block. Denominated in ton. The gas limit determines the amount of gas allowed to compute the genesis block; for subsequent blocks the gas limit is algorithmically adjusted by protocol\n    Set to: 30000000\n    \n    \n    difficulty\n    Derived from Ethereum where it sets the difficulty for Ethereum’s Ethash Proof of Work consensus. For Autonity’s implementation of Tendermint BFT Proof of Stake consensus this must be assigned 0.\n    Set to 0 (0x0)\n    \n    \n    coinbase\n    Maintained for backward compatibility reasons in the EVM. Unused by the Autonity Protocol. Ethereum format address.\n    Set to 0x0000000000000000000000000000000000000000\n    \n    \n    number\n    A value equal to the number of ancestor blocks. At genesis there are no ancestor blocks and it is assigned the value 0\n    Set to 0 (0x0)\n    \n    \n    gasUsed\n    The gas used in the computation of the block. At genesis this is assigned the value 0\n    Set to 0 (0x0)\n    \n    \n    parentHash\n    A Keccak 256-bit hash of the parent block header. At genesis there is no parent block and this is assigned a zero value.\n    Set to 0x0000000000000000000000000000000000000000000000000000000000000000\n    \n    \n    mixHash\n    Maintained by the Autonity Protocol for backward compatibility reasons in the EVM. Used for: (a) compatibility with 3rd party Ethereum tools that expect the field, (b) an internal code check by the Autonity Protocol before a block is accepted during consensus; blocks without this hash are rejected.\n    A 256-bit hash as a Hex encoded string, set to: 0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\n    \n    \n    alloc\n    An array of accounts to be assigned Auton on chain initialisation. Contract accounts for deployment at genesis can also be specified.\n    See alloc object definition\n    \n    \n    \n    \n    \n    config object\n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    chainId\n    Identifier for the Autonity blockchain network, specifying which chain the node will connect to. Introduced by EIP 155 and used for transaction signature generation\n    8-digit decimal integer value formed according to a naming scheme composed of 3 elements: {A + Network Type + ID}, where: A = 65; Network Type = 00 (Public Mainnet) or 01 (Public General Purpose Testnet) or 10 (Public Special Purpose Testnet) or 11 (Private Internal Development Testnet); ID = 0000-9999 (unique identifier for the testnet). For example, Bakerloo Testnet has the chainId 65010000\n    \n    \n    autonity\n    Autonity Protocol configuration parameters\n    See config.autonity object\n    \n    \n    accountability\n    Autonity Accountability and Fault Detection protocol configuration parameters\n    See config.accountability object\n    \n    \n    asm\n    Auton Stabilization Mechanism configuration parameters\n    See config.asm object\n    \n    \n    oracle\n    Oracle protocol configuration parameters\n    See config.oracle object\n    \n    \n    \n    \n    \n    config.autonity object\n    ::: {.callout-note title=“Note” collapse=“false”} In current state the operator governance account is an EOA. It could be assigned to a smart contract address. For example, in the case the blockchain is DAO-governed.:::\n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    abi\n    The abi of an upgraded Autonity Protocol Contract to be deployed at genesis. By default the Autonity Protocol Contract in the Autonity Go Client release is deployed\n    Only specify if overriding default contract deployment\n    \n    \n    bytecode\n    The EVM bytecode of an upgraded Autonity Protocol Contract to be deployed at genesis. By default the Autonity Protocol Contract in the Autonity Go Client release is deployed\n    Only specify if overriding default contract deployment\n    \n    \n    minBaseFee\n    The minimum gas price for computing a transaction on an Autonity network after genesis. A high minimum gas price setting incentivizes validators at genesis when transaction volumes are low\n    Set to: 500000000\n    \n    \n    blockPeriod\n    The minimum time interval between two consecutive blocks, measured in seconds. Commonly known as ‘block time’ or ‘block interval’\n    Value is specific to network configuration. For example, set to 1 for a 1-second block interval\n    \n    \n    unbondingPeriod\n    The number of blocks bonded stake must wait after processing a stake unbond transaction before Newton is redeemed to the stake delegator. The unbondingPeriod must be longer than an epochPeriod\n    Value is specific to network configuration. For a production environment a number of blocks to span a day or more could be typical to enable Byzantine behavior detection. For a local devnet supporting rapid testing a value of 120 could be appropriate\n    \n    \n    epochPeriod\n    The number of blocks in an epoch. The epochPeriod must be shorter than the unbonding period\n    Value is specific to network configuration. For a local devnet supporting rapid testing a value of 30 could be appropriate\n    \n    \n    treasury\n    The Autonity Protocol’s treasury account for receiving treasury fees used for Autonity community funds. Ethereum format address.\n    Value is specific to network configuration\n    \n    \n    treasuryFee\n    The percentage fee of staking rewards that is deducted by the protocol for Autonity community funds. The fee is sent to the Autonity Treasury account at epoch end on reward distribution. Specified as an integer value representing up to 18 decimal places of precision.\n    Value is specific to network configuration. For example, a setting of 10000000000000000 = 1%\n    \n    \n    delegationRate\n    The percentage fee of staking rewards that is deducted by validators as a commission from delegated stake. The fee is sent to the validator entity’s account at epoch end on reward distribution. The rate can be specified to the precision of 1 basis point. Specified as an integer value representing up to 3 decimal places of precision.\n    Value is specific to network configuration. For example, a setting of 1000 = 10%\n    \n    \n    maxCommitteeSize\n    The maximum number of validators that can be selected as members of a consensus committee\n    Value is specific to network configuration. For example, for a local devnet supporting rapid testing a value of 21 could be appropriate\n    \n    \n    operator\n    Address of the Autonity Protocol governance account. The governance account has the authority to mint Newton and change protocol parameters including specification of a new governance operator account address. A scenario for this would be migrating to a DAO form of governance. For functions restricted to the operator, see the See API Reference section Autonity Protocol and Operator Only\n    EOA account address\n    \n    \n    validators\n    Object structure for validators at genesis\n    See config.autonity.validators object\n    \n    \n    \n    \n    \n    config.autonity.validators object\n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    enode\n    The enode url address for the validator node on the network after genesis\n    The validator’s enode URL\n    \n    \n    treasury\n    The validator’s treasury account for receiving staking rewards. Ethereum format address.\n    The validator’s EOA account address\n    \n    \n    consensusKey\n    The validator’s BLST key used for consensus gossiping when participating in consensus\n    The validator’s consensus public key\n    \n    \n    oracleAddress\n    The unique identifier for the Autonity Oracle Server providing data to the validator. Ethereum format address.\n    The Oracle Server’s account address\n    \n    \n    bondedStake\n    The amount of stake bonded to the validator node at genesis. Denominated in Newton.\n    Positive integer for stake amount. Value is specific to validator’s stake at genesis.\n    \n    \n    \n    \n    \n    config.asm object\n    Configuration of the Auton Stabilization Mechanism (ASM).\n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    acu\n    Object structure for the ASM’s Auton Currency Unit (ACU) configuration at genesis\n    See config.asm.acu object\n    \n    \n    stabilization\n    Object structure for the ASM’s Stabilization mechanism CDP configuration at genesis\n    See config.asm.stabilization object\n    \n    \n    supplyControl\n    Object structure for the ASM’s Auton supply control configuration at genesis\n    See config.asm.supplyControl object\n    \n    \n    \n    \n    \n    config.asm.acu object\n    Configuration of the Auton Currency Unit (ACU), an optimal currency basket of 7 free-floating fiat currencies.\n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    symbols\n    The currency pair symbols used to retrieve prices for the currencies in the basket\n    Set to [\"AUD-USD\", \"CAD-USD\", \"EUR-USD\", \"GBP-USD\", \"JPY-USD\", \"USD-USD\", \"SEK-USD\"]\n    \n    \n    quantities\n    The basket quantity corresponding to each symbol.\n    Set to [21_300,18_700,14_300,10_400,1_760_000,18_000,141_000]\n    \n    \n    scale\n    The scale used to represent the basket quantities and ACU value.\n    Set to 5\n    \n    \n    \n    \n    \n    config.asm.stabilization object\n    Configuration of the Stabilization mechanism’s Collateralized Debt Position (CDP).\n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    borrowInterestRate\n    The annual continuously-compounded interest rate for borrowing.\n    Set to 5%, 50_000_000_000_000_000\n    \n    \n    liquidationRatio\n    The minimum ACU value of collateral required to maintain 1 ACU value of debt.\n    Set to 1.8, 1_800_000_000_000_000_000\n    \n    \n    minCollateralizationRatio\n    The minimum ACU value of collateral required to borrow 1 ACU value of debt.\n    Set to 2, 2_000_000_000_000_000_000\n    \n    \n    minDebtRequirement\n    The minimum amount of debt required to maintain a CDP.\n    Set to a megaton, 1_000_000\n    \n    \n    targetPrice\n    The ACU value of 1 unit of debt.\n    Set to 1, 1_000_000_000_000_000_000\n    \n    \n    \n    \n    \n    config.asm.supplyControl object\n    Configuration of the Stabilization mechanism’s initial Auton supply.\n    \n    \n    \n    \n    \n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    initialAllocation\n    The initial allocation of Auton to the ASM\n    Value is specific to network configuration\n    \n    \n    \n    \n    \n    config.accountability object\n    Object structure for the Accountability and Fault Detection (AFD) protocol configuration at genesis.\n    \n    \n    \n    \n    \n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    innocenceProofSubmissionWindow\n    The number of blocks forming a window within which an accused offending validator has to submit a proof of innocence on-chain refuting an accusation\n    Set to 600\n    \n    \n    baseSlashingRateLow\n    The base slashing rate for a fault of Low severity\n    Set to 1000 (10%)\n    \n    \n    baseSlashingRateMid\n    The base slashing rate for a fault of Mid severity\n    Set to 2000 (20%)\n    \n    \n    collusionFactor\n    The percentage factor applied to the total number of slashable offences committed during an epoch when computing the slashing amount of a penalty\n    Set to 800 (8%)\n    \n    \n    historyFactor\n    The percentage factor applied to the proven fault count of an offending validator used as a factor when computing the slashing amount of a penalty\n    Set to 500 (5%)\n    \n    \n    jailFactor\n    The number of epochs used as a factor when computing the jail period of an offending validator\n    Set to 2\n    \n    \n    slashingRatePrecision\n    The division precision used as the denominator when computing the slashing amount of a penalty\n    Set to 10000\n    \n    \n    \n    \n    \n    config.accountability object\n    Object structure for the Accountability and Fault Detection (AFD) protocol configuration at genesis.\n    \n    \n    \n    \n    \n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    innocenceProofSubmissionWindow\n    The number of blocks forming a window within which an accused offending validator has to submit a proof of innocence on-chain refuting an accusation\n    Set to 600\n    \n    \n    baseSlashingRateLow\n    The base slashing rate for a fault of Low severity\n    Set to 1000 (10%)\n    \n    \n    baseSlashingRateMid\n    The base slashing rate for a fault of Mid severity\n    Set to 2000 (20%)\n    \n    \n    collusionFactor\n    The percentage factor applied to the total number of slashable offences committed during an epoch when computing the slashing amount of a penalty\n    Set to 800 (8%)\n    \n    \n    historyFactor\n    The percentage factor applied to the proven fault count of an offending validator used as a factor when computing the slashing amount of a penalty\n    Set to 500 (5%)\n    \n    \n    jailFactor\n    The number of epochs used as a factor when computing the jail period of an offending validator\n    Set to 2\n    \n    \n    slashingRatePrecision\n    The division precision used as the denominator when computing the slashing amount of a penalty\n    Set to 10000\n    \n    \n    \n    \n    \n    config.oracle object\n    Object structure for the oracle network at genesis.\n    \n    \n    \n    \n    \n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    bytecode\n    The EVM bytecode of an upgraded Autonity Oracle Contract to be deployed at genesis. By default the Oracle Contract in the Autonity Go Client release is deployed\n    Only specify if overriding default contract deployment\n    \n    \n    abi\n    The abi of an upgraded Autonity Oracle Contract to be deployed at genesis. By default the Autonity Oracle Contract in the Autonity Go Client release is deployed\n    Only specify if overriding default contract deployment\n    \n    \n    symbols\n    The currency pairs that the oracle component collects data points for. The first listed currency of the pair is the base currency and the second the quote currency\n    Comma separated list of currency pairs. Set to \"AUD-USD\",\"CAD-USD\",\"EUR-USD\",\"GBP-USD\",\"JPY-USD\",\"SEK-USD\",\"ATN-USD\",\"NTN-USD\",\"NTN-ATN\"\n    \n    \n    votePeriod\n    The interval at which the oracle network initiates a new oracle round for submitting and voting on oracle data, measured in blocks\n    Value is specific to network configuration. For example, set to 30 for initiating a new oracle voting round at 30-block intervals\n    \n    \n    \n    \n    \n    alloc object\n    The alloc object is used to issue native coin and allows pre-deployment of smart contract accounts at network genesis.\n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    alloc\n    An array of accounts objects to be created on the network at genesis. These can be EOA or contract accounts\n    See alloc.account object definition\n    \n    \n    \n    \n    \n    alloc.account object\n    \n    \n    \n    \n    \n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    alloc.ADDRESS\n    The account address\n    Ethereum format address\n    \n    \n    alloc.ADDRESS.balance\n    The amount of Auton allocated to the account ADDRESS\n    Positive integer value\n    \n    \n    alloc.ADDRESS.code\n    The contract bytecode to be deployed if a contract account ADDRESS\n    EVM bytecode\n    \n    \n    alloc.ADDRESS.storage\n    The key-value pair for the contract bytecode storage space if a contract account ADDRESS\n    k-v pairs for contract storage\n    \n    \n    \n    \n    \n    Example genesis.json\n    {\n  \"config\": {\n    \"chainId\": 65110000,\n    \"autonity\": {\n      \"minBaseFee\": 500000000,\n      \"delegationRate\" : 1000,\n      \"blockPeriod\": 1,\n      \"maxCommitteeSize\": 10,\n      \"unbondingPeriod\": 120,\n      \"epochPeriod\": 30,\n      \"operator\": \"0x293039dDC627B1dF9562380c0E5377848F94325A\",\n      \"treasury\": \"0x7f1B212dcDc119a395Ec2B245ce86e9eE551043E\",\n      \"treasuryFee\": 150000000,\n      \"validators\": [\n        {\n          \"enode\": \"enode://181dd52828614267b2e3fe16e55721ce4ee428a303b89a0cba3343081be540f28a667c9391024718e45ae880088bd8b6578e82d395e43af261d18cedac7f51c3@35.246.21.247:30303\",\n          \"treasury\": \"0x3e08FEc6ABaf669BD8Da54abEe30b2B8B5024013\",\n          \"consensusKey\": \"0x776d2652de66e7x2d294c77d0706c772x077d242076e97cx44feex03e27d59757f7c7m7905072537eccd2d6292262724\",\n          \"oracleAddress\": \"0x5307a90c018513de02aa4c02B14E6F3CaaA8af3f\",\n          \"bondedStake\": 10000000000000000000000\n        },\n        {\n          \"enode\": \"enode://e3b8ea9ddef567225530bcbae68af5d46f59a2b39acc04113165eba2744f6759493027237681f10911d4c12eda729c367f8e64dfd4789c508b7619080bb0861b@35.189.64.207:30303\",\n          \"treasury\": \"0xf1859D9feD50514F9D805BeC7a30623d061f40B7\",\n          \"consensusKey\": \"0x456y2357dfk6e7x2d294c71d0k06c512x077d242076lk7cx44feex03e27d59757f7c717925692537eccd2e6292262774\",\n          \"oracleAddress\": \"0xd54ba484243c99CE10f11Bc5fb24cCc728ba060D\",\n          \"bondedStake\": 10000000000000000000000\n        },\n        {\n          \"enode\": \"enode://00c6c1704c103e74a26ad072aa680d82f6c677106db413f0afa41a84b5c3ab3b0827ea1a54511f637350e4e31d8a87fdbab5d918e492d21bea0a399399a9a7b5@34.105.163.137:30303\",\n          \"treasury\": \"0x1B441084736B80f273e498E646b0bEA86B4eC6AB\",\n          \"consensusKey\": \"0xhi3d112de66e7x2d294c77d0709c772x099d272076e97cx44jyex03e27du175df7cp7hh05o71537eccd2d9282262532\",\n          \"oracleAddress\": \"0xF99bC17d7db947Bf4E7171519D678882FF3Dcb8d\",\n          \"bondedStake\": 10000000000000000000000\n        },\n        {\n          \"enode\": \"enode://dffaa985bf36c8e961b9aa7bcdd644f1ad80e07d7977ce8238ac126d4425509d98da8c7f32a3e47e19822bd412ffa705c4488ce49d8b1769b8c81ee7bf102249@35.177.8.113:30308\",\n          \"treasury\": \"0xB5C49d50470743D8dE43bB6822AC4505E64648Da\",\n          \"consensusKey\": \"0x1a0j2652de66e7x2a294c7ad0406c711x077d242076e97cfc4fykx03e27d59757f7c777905072537ec9d2fhj9w26271u\",\n          \"oracleAddress\": \"0x89f2CabCA5e09f92E49fACC10BBDfa5114D13113\",\n          \"bondedStake\": 10000000000000000000000\n        },\n        {\n          \"enode\": \"enode://1bd367bfb421eb4d21f9ace33f9c3c26cd1f6b257cc4a1af640c9af56f338d865c8e5480c7ee74d5881647ef6f71d880104690936b72fdc905886e9594e976d1@35.179.46.181:30309\",\n          \"treasury\": \"0x31e1dE659A26F7638FAaFEfD94D47258FE361823\",\n          \"consensusKey\": \"0xf9wd795wdew6e7x2d294c75d07c6c281xk7md282076ek7ch34fesx03e279j9d87f5c1o790i0725h7efcd2d69372mh527\",\n          \"oracleAddress\": \"0x7CF62D2C8314445Df0bF3F322f84d3BF785e4aeF\",\n          \"bondedStake\": 10000000000000000000000\n        },\n        {\n          \"enode\": \"enode://a7465d99513715ece132504e47867f88bb5e289b8bca0fca118076b5c733d901305db68d1104ab838cf6be270b7bf71e576a44644d02f8576a4d43de8aeba1ab@3.9.98.39:30310\",\n          \"treasury\": \"0xe22617BD2a4e1Fe3938F84060D8a6be7A18a2ef9\",\n          \"consensusKey\": \"0x776d2602de06e7x2d294c77d0706c772x077d242076e97cx44feex00e27d09707f7c7779j0e49il2etc4kd2ar39ov3a7\",\n          \"oracleAddress\": \"0xD689E4D1061a55Fd9292515AaE9bF8a3C876047d\",\n          \"bondedStake\": 10000000000000000000000\n        }\n      ]\n    },\n    \"asm\": {\n      \"acu\" : {\n        \"symbols\" : [\"AUD-USD\",\"CAD-USD\",\"EUR-USD\",\"GBP-USD\",\"JPY-USD\",\"USD-USD\",\"SEK-USD\"],\n        \"quantities\" : [21_300, 18_700, 14_300, 10_400, 1_760_000, 18_000, 141_000],\n        \"scale\" : 5\n      },\n      \"stabilization\":{\n        \"borrowInterestRate\" : 50_000_000_000_000_000,\n        \"liquidationRatio\": 1_800_000_000_000_000_000,\n        \"minCollateralizationRatio\": 2_000_000_000_000_000_000,\n        \"minDebtRequirement\"  : 1_000_000,\n        \"targetPrice\" : 1_000_000_000_000_000_000\n      },\n      \"supplyControl\" : {\n        \"initialAllocation\": 1000\n      }\n    },\n    \"accountability\": {\n         \"innocenceProofSubmissionWindow\": 600,\n         \"baseSlashingRateLow\": 1000,\n         \"baseSlashingRateMid\": 2000,\n         \"collusionFactor\": 800,\n         \"historyFactor\": 500,\n         \"jailFactor\": 2,\n         \"slashingRatePrecision\": 10000\n       },\n     \"oracle\": {\n      \"symbols\":[\n            \"AUD-USD\",\n            \"CAD-USD\",\n            \"EUR-USD\",\n            \"GBP-USD\",\n            \"JPY-USD\",\n            \"SEK-USD\",\n            \"ATN-USD\",\n            \"NTN-USD\",\n            \"NTN-ATN\"\n         ],\n      \"votePeriod\": 30\n    }\n  },\n  \"nonce\": \"0x0\",\n  \"timestamp\": \"0x0\",\n  \"baseFee\": \"15000000000\",\n  \"gasLimit\": \"10000000000\",\n  \"difficulty\": \"0x0\",\n  \"coinbase\": \"0x0000000000000000000000000000000000000000\",\n  \"number\": \"0x0\",\n  \"gasUsed\": \"0x0\",\n  \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n  \"mixHash\": \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\",\n  \"alloc\": {\n    \"0xe22617BD2a4e1Fe3938F84060D8a6be7A18a2ef9\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0x31e1dE659A26F7638FAaFEfD94D47258FE361823\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0x293039dDC627B1dF9562380c0E5377848F94325A\": {\n      \"balance\": \"1000000000000000000000000000000000000000000000000000000000000000\"\n    },\n    \"0xB5C49d50470743D8dE43bB6822AC4505E64648Da\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0xf1859D9feD50514F9D805BeC7a30623d061f40B7\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0x3e08FEc6ABaf669BD8Da54abEe30b2B8B5024013\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0x1B441084736B80f273e498E646b0bEA86B4eC6AB\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0x5307a90c018513de02aa4c02B14E6F3CaaA8af3f\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0xd54ba484243c99CE10f11Bc5fb24cCc728ba060D\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0xF99bC17d7db947Bf4E7171519D678882FF3Dcb8d\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0x89f2CabCA5e09f92E49fACC10BBDfa5114D13113\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0x7CF62D2C8314445Df0bF3F322f84d3BF785e4aeF\": {\n      \"balance\": \"10000000000000000000000\"\n    },\n    \"0xD689E4D1061a55Fd9292515AaE9bF8a3C876047d\": {\n      \"balance\": \"10000000000000000000000\"\n    }\n  }\n}\n    \n    \n    \n    Static nodes file\n    \n    \n    \n    Parameter\n    Description\n    Value\n    \n    \n    \n    \n    enode\n    An array of enode url addresses for the network bootnodes\n    The node’s enode URL\n    \n    \n    \n    \n    Example static-nodes.json\n    [\n    \"enode://bb9bb2bcd75a5cde083a6a9be2c28f31d9fd6e8de38baa594ffffab0efc5d26524b91baf002fed32f098db71acf0d7646a7c32a7d05ed89fdbbb78c74db13a1a@52.89.151.55:30303\",\n    \"enode://e89196cae37e8041e14d7a063cc82dec3bb351f79f46ab10a059220403932c1337f144ddbf1fd830bf1221fbf539a4e986c924600b060c0a36337256aa70ee2c@52.89.151.55:40303\",\n    \"enode://d8ec443a7a16cd0da3df70d8c96a1a4939ac3cc497097843614b0c87167c6b080f07e02f12f8609230cae5db53f677d620b6bb574155738256d6782f902b9506@52.89.151.55:50303\",\n    \"enode://53f7ed087d55c044278279963a9d3a039d1044d2ff6ae61f11778fee42a5c14c7fdd9b529b08075de8be6f3b41ce28ab1e31b1a0a9db2fd0ec09f07cf6edabd2@512.89.151.55:60303\"\n]"
  },
  {
    "objectID": "reference/cli/agc/index.html",
    "href": "reference/cli/agc/index.html",
    "title": "Autonity Go Client Command-line",
    "section": "",
    "text": "Autonity supports all Geth command-line options with the following exceptions:\n    \n    \n    \n    \n    \n    \n    \n    Command\n    Exception\n    \n    \n    \n    \n    COMMANDS:\n    \n    \n    \n    dumpgenesis\n    The command is removed and has been replaced by an Autonity Protocol contract [config](/reference/api/aut/#config) method to return the genesis block configuration\n    \n    \n    init\n    The command is deprecated and has been replaced by a --genesis command option to give the path to the genesis configuration file genesis.json. For example: --genesis ./genesis.json\n    \n    \n    clique\n    The Clique Proof of Authority consensus functionality has been removed\n    \n    \n    wallet\n    The command for managing Ethereum presale wallets has been removed\n    \n    \n    attach and console\n    The Geth JavaScript console is deprecated in favour of the Autonity Utility Tool aut\n    \n    \n    makecache and makedag\n    The commands are removed. They are specific to ethash Proof of Work consensus and not required by Autonity’s Tendermint consensus\n    \n    \n    ETHEREUM OPTIONS:\n    \n    \n    \n    piccadilly and bakerloo\n    Options for connecting to the Autonity test networks ‘Piccadilly’ and Bakerloo are added (Options for connecting to the Ethereum test networks are removed)\n    \n    \n    genOwnershipProof\n    An option to generate an enode proof required for validator registration is added\n    \n    \n    genAutonityKeys\n    Autonity implements separate channels for transaction and consensus gossiping and so has two keys at the P2P layer. An option to generate an Autonity keys file containing the transaction and consensus gossiping private keys is added\n    \n    \n    NETWORKING OPTIONS:\n    \n    \n    \n    --netrestrict\n    Netrestrict functionality is modified in the client to allow for dynamic trusted peers. Netrestrict now supports a dynamic validator set and sentry node architecture: trusted but netrestricted nodes can connect, enabling a sentry node architecture for trusted consensus committee validator enode urls\n    \n    \n    --nodekey and --nodekeyhex\n    The P2P node key flags are renamed to --autonitykeys and --autonitykeyshex. Autonity implements separate channels for transaction and consensus gossiping and so has two keys at the P2P layer - a consensus key and a transaction gossiping key. An Autonity keys file containing the private keys is generated by running the sub command genAutonityKeys\n    \n    \n    --oraclekey\n    An option for the Autonity Oracle Server account key file is added. Validator nodes on an Autonity network must run the oracle binary to participate in the oracle network.\n    \n    \n    --oraclekeyhex\n    An option for the Autonity Oracle Server account key as hex (for testing) is added\n    \n    \n    --consensus.port\n    An option for the network listening port for the consensus channel is added (default: 20203)\n    \n    \n    --consensus.nat\n    An option for the NAT port mapping mechanism for the consensus channel is added (“any”, “none”, “upnp”, “pmp”, “extip:”) (default: “any”)\n    \n    \n    MINER OPTIONS:\n    \n    \n    \n    miner.etherbase\n    The option for setting the address for receiving block mining rewards is removed. Autonity implements a protocol mechanism for distributing staking rewards\n    \n    \n    miner.gasprice\n    The default value for the minimum gas price for mining a transaction is changed from ‘1000000000’ to ‘500000000’\n    \n    \n    miner.gaslimit\n    The default value for Ethereum’s native gas block limit voting mechanism is changed from ‘8000000’ to ‘20000000’\n    \n    \n    LIGHT CLIENT OPTIONS:\n    All options are removed\n    \n    \n    DEVELOPER CHAIN OPTIONS:\n    All options are removed. Autonity doesn’t support clique Proof of Authority consensus. Developer mode options for a proof-of-stake developer mode are added to MISC OPTIONS beneath\n    \n    \n    ETHASH OPTIONS:\n    All options are removed. Autonity doesn’t support Proof of Work consensus\n    \n    \n    LOGGING AND DEBUGGING OPTIONS:\n    \n    \n    \n    fakepow\n    The option is removed. Autonity doesn’t support Proof of Work consensus\n    \n    \n    ALIASED (deprecated) OPTIONS:\n    \n    \n    \n    --miner.gastarget and --nousb\n    The options are deprecated and will be removed in the future\n    \n    \n    MISC OPTIONS:\n    \n    \n    \n    --writeaddress\n    An option to write out the node’s public key on stdout is added\n    \n    \n    --dev\n    A developer mode option to create an ephemeral proof-of-stake network with a pre-funded developer account, mining enabled\n    \n    \n    --dev.gaslimit\n    An option to set the initial block gas limit (default: 30000000) for the developer mode network\n    \n    \n    --dev.etherbase\n    An option to set the public address of the external account to be used for developer mode (default: “0”)"
  },
  {
    "objectID": "reference/cli/agc/index.html#command-line-options",
    "href": "reference/cli/agc/index.html#command-line-options",
    "title": "Autonity Go Client Command-line",
    "section": "",
    "text": "Autonity supports all Geth command-line options with the following exceptions:\n    \n    \n    \n    \n    \n    \n    \n    Command\n    Exception\n    \n    \n    \n    \n    COMMANDS:\n    \n    \n    \n    dumpgenesis\n    The command is removed and has been replaced by an Autonity Protocol contract [config](/reference/api/aut/#config) method to return the genesis block configuration\n    \n    \n    init\n    The command is deprecated and has been replaced by a --genesis command option to give the path to the genesis configuration file genesis.json. For example: --genesis ./genesis.json\n    \n    \n    clique\n    The Clique Proof of Authority consensus functionality has been removed\n    \n    \n    wallet\n    The command for managing Ethereum presale wallets has been removed\n    \n    \n    attach and console\n    The Geth JavaScript console is deprecated in favour of the Autonity Utility Tool aut\n    \n    \n    makecache and makedag\n    The commands are removed. They are specific to ethash Proof of Work consensus and not required by Autonity’s Tendermint consensus\n    \n    \n    ETHEREUM OPTIONS:\n    \n    \n    \n    piccadilly and bakerloo\n    Options for connecting to the Autonity test networks ‘Piccadilly’ and Bakerloo are added (Options for connecting to the Ethereum test networks are removed)\n    \n    \n    genOwnershipProof\n    An option to generate an enode proof required for validator registration is added\n    \n    \n    genAutonityKeys\n    Autonity implements separate channels for transaction and consensus gossiping and so has two keys at the P2P layer. An option to generate an Autonity keys file containing the transaction and consensus gossiping private keys is added\n    \n    \n    NETWORKING OPTIONS:\n    \n    \n    \n    --netrestrict\n    Netrestrict functionality is modified in the client to allow for dynamic trusted peers. Netrestrict now supports a dynamic validator set and sentry node architecture: trusted but netrestricted nodes can connect, enabling a sentry node architecture for trusted consensus committee validator enode urls\n    \n    \n    --nodekey and --nodekeyhex\n    The P2P node key flags are renamed to --autonitykeys and --autonitykeyshex. Autonity implements separate channels for transaction and consensus gossiping and so has two keys at the P2P layer - a consensus key and a transaction gossiping key. An Autonity keys file containing the private keys is generated by running the sub command genAutonityKeys\n    \n    \n    --oraclekey\n    An option for the Autonity Oracle Server account key file is added. Validator nodes on an Autonity network must run the oracle binary to participate in the oracle network.\n    \n    \n    --oraclekeyhex\n    An option for the Autonity Oracle Server account key as hex (for testing) is added\n    \n    \n    --consensus.port\n    An option for the network listening port for the consensus channel is added (default: 20203)\n    \n    \n    --consensus.nat\n    An option for the NAT port mapping mechanism for the consensus channel is added (“any”, “none”, “upnp”, “pmp”, “extip:”) (default: “any”)\n    \n    \n    MINER OPTIONS:\n    \n    \n    \n    miner.etherbase\n    The option for setting the address for receiving block mining rewards is removed. Autonity implements a protocol mechanism for distributing staking rewards\n    \n    \n    miner.gasprice\n    The default value for the minimum gas price for mining a transaction is changed from ‘1000000000’ to ‘500000000’\n    \n    \n    miner.gaslimit\n    The default value for Ethereum’s native gas block limit voting mechanism is changed from ‘8000000’ to ‘20000000’\n    \n    \n    LIGHT CLIENT OPTIONS:\n    All options are removed\n    \n    \n    DEVELOPER CHAIN OPTIONS:\n    All options are removed. Autonity doesn’t support clique Proof of Authority consensus. Developer mode options for a proof-of-stake developer mode are added to MISC OPTIONS beneath\n    \n    \n    ETHASH OPTIONS:\n    All options are removed. Autonity doesn’t support Proof of Work consensus\n    \n    \n    LOGGING AND DEBUGGING OPTIONS:\n    \n    \n    \n    fakepow\n    The option is removed. Autonity doesn’t support Proof of Work consensus\n    \n    \n    ALIASED (deprecated) OPTIONS:\n    \n    \n    \n    --miner.gastarget and --nousb\n    The options are deprecated and will be removed in the future\n    \n    \n    MISC OPTIONS:\n    \n    \n    \n    --writeaddress\n    An option to write out the node’s public key on stdout is added\n    \n    \n    --dev\n    A developer mode option to create an ephemeral proof-of-stake network with a pre-funded developer account, mining enabled\n    \n    \n    --dev.gaslimit\n    An option to set the initial block gas limit (default: 30000000) for the developer mode network\n    \n    \n    --dev.etherbase\n    An option to set the public address of the external account to be used for developer mode (default: “0”)"
  },
  {
    "objectID": "reference/cli/agc/index.html#usage",
    "href": "reference/cli/agc/index.html#usage",
    "title": "Autonity Go Client Command-line",
    "section": "Usage",
    "text": "Usage\n    Run autonity --help to view the options:\n    \n    \n    \n    \n    \n    \n    Info\n    \n    \n    \n    \n    \n    Autonity is a Geth fork and command-line options are inherited from Geth. The Geth docs Command-line Options are kept in synch with the current stable version of Geth. The Command-line Options inherited from Geth reflect the Geth version from which Autonity is forked. For Autonity’s Geth base version see Reference Codebase.\n    \n    \n    \n    NAME:\n   autonity - the autonity command line interface\n\n   Copyright 2013-2021 The go-ethereum Authors\n\nUSAGE:\n   autonity [options] [command] [command options] [arguments...]\n   \nVERSION:\n   0.13.0-rc-8b4a17c1-20240210\n   \nCOMMANDS:\n   account                            Manage accounts\n   attach                             Start an interactive JavaScript environment (connect to node)\n   console                            Start an interactive JavaScript environment\n   db                                 Low level database operations\n   dump                               Dump a specific block from storage\n   dumpconfig                         Show configuration values\n   export                             Export blockchain into file\n   export-preimages                   Export the preimage database into an RLP stream\n   genAutonityKeys                    Generate autonity keys\n   genOwnershipProof                  Generate enode proof\n   import                             Import a blockchain file\n   import-preimages                   Import the preimage database from an RLP stream\n   js                                 Execute the specified JavaScript files\n   license                            Display license information\n   removedb                           Remove blockchain and state databases\n   show-deprecated-flags              Show flags that have been deprecated\n   snapshot                           A set of commands based on the snapshot\n   version                            Print version numbers\n   help, h                            Shows a list of commands or help for one command\n   \nETHEREUM OPTIONS:\n  --config value                      TOML configuration file\n  --genesis value                     Path to the genesis json file, the genesis file contains\n                                      configuration that defines the first (aka genesis) block of the chain\n                                      and also controls how the client behaves. This flag must be provided\n                                      the first time a node is run so that the node can initialise its\n                                      database with the provided config. Subsequent to the first run, if the\n                                      flag is not set, the node will load all configuration from its\n                                      database, otherwise the node will verify that the config for the\n                                      genesis block exactly matches the genesis block it has in its database\n                                      and then see if the configuration that controls client behaviour is\n                                      compatible with the configuration in the database. If so the client will\n                                      update the configuration that controls client behaviour. This is the\n                                      mechanism is used for handling forks.\n  --datadir value                     Data directory for the databases and keystore (default: \"~/.autonity\")\n  --datadir.ancient value             Data directory for ancient chain segments (default = inside chaindata)\n  --datadir.minfreedisk value         Minimum free disk space in MB, once reached triggers auto shut down (default = --cache.gc converted to MB, 0 = disabled)\n  --keystore value                    Directory for the keystore (default = inside the datadir)\n  --usb                               Enable monitoring and management of USB hardware wallets\n  --pcscdpath value                   Path to the smartcard daemon (pcscd) socket file (default: \"/run/pcscd/pcscd.comm\")\n  --networkid value                   Explicitly set network id (integer)(For testnets: use --piccadilly instead) (default: 65000000)\n  --syncmode value                    Blockchain sync mode (\"snap\", \"full\" or \"light\") (default: snap)\n  --exitwhensynced                    Exits after block synchronisation completes\n  --gcmode value                      Blockchain garbage collection mode (\"full\", \"archive\") (default: \"full\")\n  --piccadilly                        Piccadilly network: pre-configured Autonity test network\n  --bakerloo                          Bakerloo network: pre-configured Autonity test network\n  --txlookuplimit value               Number of recent blocks to maintain transactions index for (default = about one year, 0 = entire chain) (default: 2350000)\n  --ethstats value                    Reporting URL of a ethstats service (nodename:secret@host:port)\n  --identity value                    Custom node name\n  --lightkdf                          Reduce key-derivation RAM & CPU usage at some expense of KDF strength\n  --eth.requiredblocks value          Comma separated block number-to-hash mappings to enforce (&lt;number&gt;=&lt;hash&gt;)\n  \nTRANSACTION POOL OPTIONS:\n  --txpool.locals value               Comma separated accounts to treat as locals (no flush, priority inclusion)\n  --txpool.nolocals                   Disables price exemptions for locally submitted transactions\n  --txpool.journal value              Disk journal for local transaction to survive node restarts (default: \"transactions.rlp\")\n  --txpool.rejournal value            Time interval to regenerate the local transaction journal (default: 1h0m0s)\n  --txpool.pricelimit value           Minimum gas price limit to enforce for acceptance into the pool (default: 1)\n  --txpool.pricebump value            Price bump percentage to replace an already existing transaction (default: 10)\n  --txpool.accountslots value         Minimum number of executable transaction slots guaranteed per account (default: 16)\n  --txpool.globalslots value          Maximum number of executable transaction slots for all accounts (default: 5120)\n  --txpool.accountqueue value         Maximum number of non-executable transaction slots permitted per account (default: 64)\n  --txpool.globalqueue value          Maximum number of non-executable transaction slots for all accounts (default: 1024)\n  --txpool.lifetime value             Maximum amount of time non-executable transaction are queued (default: 3h0m0s)\n  \nPERFORMANCE TUNING OPTIONS:\n  --cache value                       Megabytes of memory allocated to internal caching (default = 4096 mainnet full node, 128 light mode) (default: 1024)\n  --cache.database value              Percentage of cache memory allowance to use for database io (default: 50)\n  --cache.trie value                  Percentage of cache memory allowance to use for trie caching (default = 15% full mode, 30% archive mode) (default: 15)\n  --cache.trie.journal value          Disk journal directory for trie cache to survive node restarts (default: \"triecache\")\n  --cache.trie.rejournal value        Time interval to regenerate the trie cache journal (default: 1h0m0s)\n  --cache.gc value                    Percentage of cache memory allowance to use for trie pruning (default = 25% full mode, 0% archive mode) (default: 25)\n  --cache.snapshot value              Percentage of cache memory allowance to use for snapshot caching (default = 10% full mode, 20% archive mode) (default: 10)\n  --cache.noprefetch                  Disable heuristic state prefetch during block import (less CPU and disk IO, more time waiting for data)\n  --cache.preimages                   Enable recording the SHA3/keccak preimages of trie keys\n  \nACCOUNT OPTIONS:\n  --unlock value                      Comma separated list of accounts to unlock\n  --password value                    Password file to use for non-interactive password input\n  --signer value                      External signer (url or path to ipc file)\n  --allow-insecure-unlock             Allow insecure account unlocking when account-related RPCs are exposed by http\n  \nAPI AND CONSOLE OPTIONS:\n  --ipcdisable                        Disable the IPC-RPC server\n  --ipcpath value                     Filename for IPC socket/pipe within the datadir (explicit paths escape it)\n  --http                              Enable the HTTP-RPC server\n  --http.addr value                   HTTP-RPC server listening interface (default: \"localhost\")\n  --http.port value                   HTTP-RPC server listening port (default: 8545)\n  --http.api value                    API's offered over the HTTP-RPC interface\n  --http.rpcprefix value              HTTP path path prefix on which JSON-RPC is served. Use '/' to serve on all paths.\n  --http.corsdomain value             Comma separated list of domains from which to accept cross origin requests (browser enforced)\n  --http.vhosts value                 Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts '*' wildcard. (default: \"localhost\")\n  --ws                                Enable the WS-RPC server\n  --ws.addr value                     WS-RPC server listening interface (default: \"localhost\")\n  --ws.port value                     WS-RPC server listening port (default: 8546)\n  --ws.api value                      API's offered over the WS-RPC interface\n  --ws.rpcprefix value                HTTP path prefix on which JSON-RPC is served. Use '/' to serve on all paths.\n  --ws.origins value                  Origins from which to accept websockets requests\n  --graphql                           Enable GraphQL on the HTTP-RPC server. Note that GraphQL can only be started if an HTTP server is started as well.\n  --graphql.corsdomain value          Comma separated list of domains from which to accept cross origin requests (browser enforced)\n  --graphql.vhosts value              Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts '*' wildcard. (default: \"localhost\")\n  --rpc.gascap value                  Sets a cap on gas that can be used in eth_call/estimateGas (0=infinite) (default: 50000000)\n  --rpc.evmtimeout value              Sets a timeout used for eth_call (0=infinite) (default: 5s)\n  --rpc.txfeecap value                Sets a cap on transaction fee (in auton) that can be sent via the RPC APIs (0 = no cap) (default: 1)\n  --rpc.allow-unprotected-txs         Allow for unprotected (non EIP155 signed) transactions to be submitted via RPC\n  --jspath loadScript                 JavaScript root path for loadScript (default: \".\")\n  --exec value                        Execute JavaScript statement\n  --preload value                     Comma separated list of JavaScript files to preload into the console\n  \nNETWORKING OPTIONS:\n  --bootnodes value                   Comma separated enode URLs for P2P discovery bootstrap\n  --discovery.dns value               Sets DNS discovery entry points (use \"\" to disable DNS)\n  --port value                        Network listening port for execution channel (default: 30303)\n  --maxpeers value                    Maximum number of network peers (network disabled if set to 0) (default: 50)\n  --maxpendpeers value                Maximum number of pending connection attempts (defaults used if set to 0) (default: 0)\n  --nat value                         NAT port mapping mechanism for execution channel (any|none|upnp|pmp|extip:&lt;IP&gt;) (default: \"any\")\n  --nodiscover                        Disables the peer discovery mechanism (manual peer addition)\n  --v5disc                            Enables the experimental RLPx V5 (Topic Discovery) mechanism\n  --netrestrict value                 Restricts network communication to the given IP networks (CIDR masks)\n  --autonitykeys value                Autonity keys file generated by sub command genAutonityKeys\n  --autonitykeyshex value             Autonity keys as hex (for testing)\n  --oraclekey value                   oracle account key file\n  --oraclekeyhex value                oracle account key as hex (for testing)\n  --consensus.port value              Network listening port for consensus channel (default: 20203)\n  --consensus.nat value               NAT port mapping mechanism for consensus channel (any|none|upnp|pmp|extip:&lt;IP&gt;) (default: \"any\")\n  \nMINER OPTIONS:\n  --mine                              Enable mining. Will bypass the chain sync check.\n  --miner.threads value               Number of CPU threads to use for mining (default: 0)\n  --miner.notify value                Comma separated HTTP URL list to notify of new work packages\n  --miner.notify.full                 Notify with pending block headers instead of work packages\n  --miner.gasprice value              Minimum gas price for mining a transaction (default: 500000000)\n  --miner.gaslimit value              Target gas ceiling for mined blocks (default: 20000000)\n  --miner.extradata value             Block extra data set by the miner (default = client version)\n  --miner.recommit value              Time interval to recreate the block being mined (default: 3s)\n  --miner.noverify                    Disable remote sealing verification\n  \nGAS PRICE ORACLE OPTIONS:\n  --gpo.blocks value                  Number of recent blocks to check for gas prices (default: 20)\n  --gpo.percentile value              Suggested gas price is the given percentile of a set of recent transaction gas prices (default: 60)\n  --gpo.maxprice value                Maximum transaction priority fee (or gasprice before London fork) to be recommended by gpo (default: 500000000000)\n  --gpo.ignoreprice value             Gas price below which gpo will ignore transactions (default: 2)\n  \nVIRTUAL MACHINE OPTIONS:\n  --vmdebug                           Record information useful for VM and contract debugging\n  \nLOGGING AND DEBUGGING OPTIONS:\n  --nocompaction                      Disables db compaction after import\n  --verbosity value                   Logging verbosity: 0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3)\n  --vmodule value                     Per-module verbosity: comma-separated list of &lt;pattern&gt;=&lt;level&gt; (e.g. eth/*=5,p2p=4)\n  --log.json                          Format logs with JSON\n  --log.backtrace value               Request a stack trace at a specific logging statement (e.g. \"block.go:271\")\n  --log.debug                         Prepends log messages with call-site location (file and line number)\n  --pprof                             Enable the pprof HTTP server\n  --pprof.addr value                  pprof HTTP server listening interface (default: \"127.0.0.1\")\n  --pprof.port value                  pprof HTTP server listening port (default: 6060)\n  --pprof.memprofilerate value        Turn on memory profiling with the given rate (default: 524288)\n  --pprof.blockprofilerate value      Turn on block profiling with the given rate (default: 0)\n  --pprof.cpuprofile value            Write CPU profile to the given file\n  --trace value                       Write execution trace to the given file\n  \nMETRICS AND STATS OPTIONS:\n  --metrics                              Enable metrics collection and reporting\n  --metrics.expensive                    Enable expensive metrics collection and reporting\n  --metrics.addr value                   Enable stand-alone metrics HTTP server listening interface (default: \"127.0.0.1\")\n  --metrics.port value                   Metrics HTTP server listening port (default: 6060)\n  --metrics.influxdb                     Enable metrics export/push to an external InfluxDB database\n  --metrics.influxdb.endpoint value      InfluxDB API endpoint to report metrics to (default: \"http://localhost:8086\")\n  --metrics.influxdb.database value      InfluxDB database name to push reported metrics to (default: \"autonity\")\n  --metrics.influxdb.username value      Username to authorize access to the database (default: \"test\")\n  --metrics.influxdb.password value      Password to authorize access to the database (default: \"test\")\n  --metrics.influxdb.tags value          Comma-separated InfluxDB tags (key/values) attached to all measurements (default: \"host=localhost\")\n  --metrics.influxdbv2                   Enable metrics export/push to an external InfluxDB v2 database\n  --metrics.influxdb.token value         Token to authorize access to the database (v2 only) (default: \"test\")\n  --metrics.influxdb.bucket value        InfluxDB bucket name to push reported metrics to (v2 only) (default: \"autonity\")\n  --metrics.influxdb.organization value  InfluxDB organization name (v2 only) (default: \"autonity\")\n  \nALIASED (deprecated) OPTIONS:\n  --nousb                             Disables monitoring for and managing USB hardware wallets (deprecated)\n  \nMISC OPTIONS:\n  --snapshot                          Enables snapshot-database mode (default = enable)\n  --bloomfilter.size value            Megabytes of memory allocated to bloom-filter for pruning (default: 2048)\n  --help, -h                          show help\n  --writeaddress                      writes out the node's public key on stdout\n  --dev                               Ephemeral proof-of-stake network with a pre-funded developer account, mining enabled\n  --dev.gaslimit value                Initial block gas limit (default: 30000000)\n  --dev.etherbase value               Public address of external account to be used for developer mode (default: \"0\")\n  \n\nCOPYRIGHT:\n   Copyright 2013-2022 The go-ethereum Authors"
  },
  {
    "objectID": "reference/cli/oracle/index.html",
    "href": "reference/cli/oracle/index.html",
    "title": "Autonity Oracle Server Command-line",
    "section": "",
    "text": "Autonity Oracle Server provides command-line options for displaying version and help information, and setting oracle server configuration."
  },
  {
    "objectID": "reference/cli/oracle/index.html#command-line-options",
    "href": "reference/cli/oracle/index.html#command-line-options",
    "title": "Autonity Oracle Server Command-line",
    "section": "",
    "text": "Autonity Oracle Server provides command-line options for displaying version and help information, and setting oracle server configuration."
  },
  {
    "objectID": "reference/cli/oracle/index.html#usage",
    "href": "reference/cli/oracle/index.html#usage",
    "title": "Autonity Oracle Server Command-line",
    "section": "Usage",
    "text": "Usage\n    Run autoracle --help to view the options:\n    \n    \n    \n    COMMANDS:\n    Description\n    \n    \n    \n    \n    version, v\n    Print version information and default configuration\n    \n    \n    help, -h\n    Shows a list of Oracle Server configuration options\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ORACLE SERVER OPTIONS:\n    Description\n    Default\n    Required?\n    \n    \n    \n    \n    -config\n    The path to the oracle server configuration file oracle-server.config.\n    “ws://127.0.0.1:8546”\n    No\n    \n    \n    -key.file\n    The path to the oracle server key file.\n    (Defaults to testing key in /test_data/keystore)\n    Yes\n    \n    \n    -key.password\n    The password to the oracle server key file.\n    (Defaults to password for testing key in /test_data/keystore)\n    Yes\n    \n    \n    -log.level\n    The logging level. Available levels are: 0: NoLevel, 1: Trace, 2:Debug, 3: Info, 4: Warn, 5: Error.\n    3\n    No\n    \n    \n    -plugin.conf\n    The path to the data source plugins YAML configuration file plugins-conf.yml.\n    ./plugins-conf.yml\n    Yes\n    \n    \n    -plugin.dir\n    The path to the DIR where the data source plugins are stored.\n    ./plugins\n    No\n    \n    \n    -tip\n    The gas priority fee cap set for oracle data report transactions. Must be a non-zero value.\n    1\n    No\n    \n    \n    -ws\n    The WS-RPC server listening interface and port of the connected Autonity Go Client node.\n    “ws://127.0.0.1:8546”\n    Yes"
  },
  {
    "objectID": "reference/cli/index.html",
    "href": "reference/cli/index.html",
    "title": "Autonity Command-line",
    "section": "",
    "text": "Command-line tools for interacting with an Autonity Go Client are provided by:\n    \n    Autonity Utility Tool aut. A Python command-line RPC client for Autonity. The tool provides access to Autonity Contract and ERC20 token contract interfaces.\n    \n    For aut installation, usage, and command-line options see Reference Setup the Autonity Utility Tool (aut)."
  },
  {
    "objectID": "reference/cli/index.html#command-line-facilities",
    "href": "reference/cli/index.html#command-line-facilities",
    "title": "Autonity Command-line",
    "section": "",
    "text": "Command-line tools for interacting with an Autonity Go Client are provided by:\n    \n    Autonity Utility Tool aut. A Python command-line RPC client for Autonity. The tool provides access to Autonity Contract and ERC20 token contract interfaces.\n    \n    For aut installation, usage, and command-line options see Reference Setup the Autonity Utility Tool (aut)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Autonity Documentation",
    "section": "",
    "text": "Welcome to the documentation site for the Autonity Go Client (AGC) and Autonity Oracle Server (AOS). AGC is the main client software run by peer nodes in an Autonity network. AOS is the oracle software run by validator nodes to source price data from external data providers and submit price reports on-chain.\nAGC is a fork of Geth  and is the reference implementation of the Autonity Protocol. The protocol provides an EVM-based blockchain that utilises Tendermint BFT for delegated proof of stake consensus, has a dual native coin design for tokenomics, and provides liquid staking for capital efficiency.\nThis documentation describes key concepts and functionality of the Autonity protocol, main client, and oracle server. It explains how to use the software and connect to an Autonity network."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Autonity Documentation",
    "section": "Getting started",
    "text": "Getting started\n    \n    Autonity protocol and platform\n    \n    See Concepts for key concepts of the Autonity protocol and tokenomics, technical architecture of the platform, and available networks.\n    \n    \n    \n    Usage\n    \n    See the user-oriented guides for how to use the system:\n    \n    Account Holders for how to set up an account on the network: set up the Autonity aut command-line tool, create and fund accounts, submit transactions.\n    Staking for how to delegate stake in Autonity’s liquid staking model: bond and unbond stake to validators, claim staking rewards, and transfer Liquid Newton.\n    Running a Node for how to install and run the Autonity Go Client, connect to an Autonity Network, and setup node monitoring.\n    Running a Validator and Running an Oracle Server for how to operate your node as a validator node:\n    \n    Setting up the validator’s oracle server\n    Registering, pausing and reactivating validator operations, and setting your validator commission rate.\n    \n    Development for how to set up a custom network for development and deploy contracts to your local or a public Autonity network.\n    \n    See Networks for publicly accessible Autonity Networks you can connect your node to.\n    \n    \n    \n    Reference\n    \n    See Reference for technical reference documentation of the codebase and API’s.\n    \n    \n    \n    Terminology\n    \n    Explanations of terminology used throughout the documentation can be found in the Glossary."
  },
  {
    "objectID": "networks/testnet-bakerloo/index.html",
    "href": "networks/testnet-bakerloo/index.html",
    "title": "Bakerloo Testnet",
    "section": "",
    "text": "Bakerloo is a public Testnet providing a stable testing environment for those developing a project on top of Autonity.\nBakerloo is for participants interested in:"
  },
  {
    "objectID": "networks/testnet-bakerloo/index.html#bakerloo-testnet-details",
    "href": "networks/testnet-bakerloo/index.html#bakerloo-testnet-details",
    "title": "Bakerloo Testnet",
    "section": "Bakerloo Testnet details",
    "text": "Bakerloo Testnet details\n    \n    \n    \n    Field\n    Input\n    \n    \n    \n    \n    Network Name\n    Autonity Bakerloo (Barada) Testnet\n    \n    \n    New RPC URL\n    https://rpc1.bakerloo.autonity.org\n    \n    \n    ChainID\n    65010002\n    \n    \n    Symbol\n    ATN\n    \n    \n    Block Explorer URL (optional)\n    https://bakerloo.autonity.org/\n    \n    \n    \n    (The above information can be used to connect an existing client such as MetaMask)"
  },
  {
    "objectID": "networks/testnet-bakerloo/index.html#genesis-configuration",
    "href": "networks/testnet-bakerloo/index.html#genesis-configuration",
    "title": "Bakerloo Testnet",
    "section": "Genesis configuration",
    "text": "Genesis configuration\n    The network’s genesis configuration is:\n    \n    \n    \n    \n    \n    \n    \n    Name\n    Bakerloo\n    \n    \n    \n    \n    chainId\n    65010002\n    \n    \n    gasLimit\n    30000000 (30M)\n    \n    \n    config.autonity.blockPeriod\n    1 second\n    \n    \n    config.autonity.epochPeriod\n    1800(30 min)\n    \n    \n    config.autonity.unbondingPeriod\n    21600(6 hours)\n    \n    \n    config.autonity.maxCommitteeSize\n    50\n    \n    \n    config.autonity.delegationRate\n    1000 (10%)\n    \n    \n    config.autonity.treasuryFee\n    10000000000000000 (1%)\n    \n    \n    config.autonity.minBaseFee\n    500000000 (0.5 GWei)\n    \n    \n    config.autonity.operator\n    0x293039dDC627B1dF9562380c0E5377848F94325A\n    \n    \n    config.autonity.treasury\n    0x7f1B212dcDc119a395Ec2B245ce86e9eE551043E\n    \n    \n    config.autonity.validators\n    enode://181dd52828614267b2e3fe16e55721ce4ee428a303b89a0cba3343081be540f28a667c9391024718e45ae880088bd8b6578e82d395e43af261d18cedac7f51c3@35.246.21.247:30303\n    \n    \n    \n    enode://e3b8ea9ddef567225530bcbae68af5d46f59a2b39acc04113165eba2744f6759493027237681f10911d4c12eda729c367f8e64dfd4789c508b7619080bb0861b@35.189.64.207:30303\n    \n    \n    \n    enode://00c6c1704c103e74a26ad072aa680d82f6c677106db413f0afa41a84b5c3ab3b0827ea1a54511f637350e4e31d8a87fdbab5d918e492d21bea0a399399a9a7b5@34.105.163.137:30303\n    \n    \n    \n    enode://dffaa985bf36c8e961b9aa7bcdd644f1ad80e07d7977ce8238ac126d4425509d98da8c7f32a3e47e19822bd412ffa705c4488ce49d8b1769b8c81ee7bf102249@35.177.8.113:30308\n    \n    \n    \n    enode://1bd367bfb421eb4d21f9ace33f9c3c26cd1f6b257cc4a1af640c9af56f338d865c8e5480c7ee74d5881647ef6f71d880104690936b72fdc905886e9594e976d1@35.179.46.181:30309\n    \n    \n    \n    enode://a7465d99513715ece132504e47867f88bb5e289b8bca0fca118076b5c733d901305db68d1104ab838cf6be270b7bf71e576a44644d02f8576a4d43de8aeba1ab@3.9.98.39:30310\n    \n    \n    config.oracle.symbols\n    [\"AUD-USD\", \"CAD-USD\", \"EUR-USD\", \"GBP-USD\", \"JPY-USD\", \"SEK-USD\", \"ATN-USD\", \"NTN-USD\", \"ATN-NTN\"]\n    \n    \n    config.oracle.votePeriod\n    30 (30 blocks)"
  },
  {
    "objectID": "networks/testnet-bakerloo/index.html#bootnodes",
    "href": "networks/testnet-bakerloo/index.html#bootnodes",
    "title": "Bakerloo Testnet",
    "section": "Bootnodes",
    "text": "Bootnodes\n    The network bootnode addresses are:\n    \n    “enode://46164e112b9a89641ca1cdb861fb7fefa6d5b111df1ec831601afdb6262a85af1865b4c53b378988c0b85e2d53b758c81322f86b5d3831ccf54d2e4e62c77ff6@34.142.78.108:30303”\n    “enode://475b720eded83c95ba55648127cb861c1620482690bfb3aece61f0cad85a234d7b73e1d2b29b753af4e9c6f5a1ffd16a1da04e1185169366fe011ca81ef2ecf7@35.189.83.7:30303”"
  },
  {
    "objectID": "networks/testnet-bakerloo/index.html#release",
    "href": "networks/testnet-bakerloo/index.html#release",
    "title": "Bakerloo Testnet",
    "section": "Release",
    "text": "Release\n    \n    The current iteration of the Bakerloo network is built using this Autonity Release: v0.13.0\n    The docker image release is: ghcr.io/autonity/autonity:latest"
  },
  {
    "objectID": "networks/testnet-bakerloo/index.html#faucet",
    "href": "networks/testnet-bakerloo/index.html#faucet",
    "title": "Bakerloo Testnet",
    "section": "Faucet",
    "text": "Faucet\n    \n    Faucet for auton test funds: https://faucet.autonity.org/\n    There is currently no faucet for newton, as newton tokens will be made available to network participants in later phases of the testnet."
  },
  {
    "objectID": "networks/testnet-bakerloo/index.html#public-endpoints",
    "href": "networks/testnet-bakerloo/index.html#public-endpoints",
    "title": "Bakerloo Testnet",
    "section": "Public endpoints",
    "text": "Public endpoints\n    Default rate limit on calls to ws and http public endpoints combined is 250 requests per second per IP.\n    \n    RPC: https://rpc1.bakerloo.autonity.org\n    WebSocket: wss://rpc1.bakerloo.autonity.org/ws"
  },
  {
    "objectID": "networks/testnet-bakerloo/index.html#block-explorer",
    "href": "networks/testnet-bakerloo/index.html#block-explorer",
    "title": "Bakerloo Testnet",
    "section": "Block explorer",
    "text": "Block explorer\n    \n    BlockScout explorer for searching and viewing ledger data: https://bakerloo.autonity.org/"
  },
  {
    "objectID": "networks/index.html",
    "href": "networks/index.html",
    "title": "Networks",
    "section": "",
    "text": "Autonity provides open testnets for node operators, validators and developers."
  },
  {
    "objectID": "networks/index.html#get-auton-test-funds",
    "href": "networks/index.html#get-auton-test-funds",
    "title": "Networks",
    "section": "Get Auton test funds",
    "text": "Get Auton test funds\n    To get started on either the Bakerloo or Piccadilly testnet, you can use the Faucet to get free auton to fund your account for testing.\n    If the Faucet is down for maintenance, an alternative way to get auton is by requesting some from the Autonity Discord Server. Please note this will take much longer."
  },
  {
    "objectID": "networks/testnet-piccadilly/index.html",
    "href": "networks/testnet-piccadilly/index.html",
    "title": "Piccadilly Testnet",
    "section": "",
    "text": "Piccadilly is a public Testnet running the latest deployable version of the Autonity protocol. It is the testing environment used in the pre-MainNet Piccadilly Circus Games Competition (PCGC) and may undergo re-genesis with the latest protocol implementation at the end of a game round.\nPiccadilly is for participants interested in:"
  },
  {
    "objectID": "networks/testnet-piccadilly/index.html#piccadilly-testnet-details",
    "href": "networks/testnet-piccadilly/index.html#piccadilly-testnet-details",
    "title": "Piccadilly Testnet",
    "section": "Piccadilly Testnet details",
    "text": "Piccadilly Testnet details\n    \n    \n    \n    Field\n    Input\n    \n    \n    \n    \n    Network Name\n    Autonity Piccadilly (Barada) Testnet\n    \n    \n    New RPC URL\n    https://rpc1.piccadilly.autonity.org/\n    \n    \n    ChainID\n    65100002\n    \n    \n    Symbol\n    ATN\n    \n    \n    Block Explorer URL (optional)\n    https://piccadilly.autonity.org/\n    \n    \n    \n    (The above information can be used to connect an existing client such as MetaMask)"
  },
  {
    "objectID": "networks/testnet-piccadilly/index.html#genesis-configuration",
    "href": "networks/testnet-piccadilly/index.html#genesis-configuration",
    "title": "Piccadilly Testnet",
    "section": "Genesis configuration",
    "text": "Genesis configuration\n    \n    \n    \n    \n    \n    \n    \n    Name\n    Piccadilly\n    \n    \n    \n    \n    chainId\n    65100002\n    \n    \n    gasLimit\n    30000000(30M)\n    \n    \n    config.autonity.blockPeriod\n    1 second\n    \n    \n    config.autonity.epochPeriod\n    1800(30 min)\n    \n    \n    config.autonity.unbondingPeriod\n    21600(6 hours)\n    \n    \n    config.autonity.maxCommitteeSize\n    9 (increases to 100 after genesis, then oscillates in range 34 - 100)\n    \n    \n    config.autonity.delegationRate\n    1000 (10%)\n    \n    \n    config.autonity.treasuryFee\n    10000000000000000 (1%)\n    \n    \n    config.autonity.minBaseFee\n    500000000 (0.5 GWei)\n    \n    \n    config.autonity.operator\n    0xd32C0812Fa1296F082671D5Be4CbB6bEeedC2397\n    \n    \n    config.autonity.treasury\n    0xF74c34Fed10cD9518293634C6f7C12638a808Ad5\n    \n    \n    config.autonity.validators\n    enode://d4dc137f987e17155a69b31e566494c16edafd228912483cc519a48ce85864781faccc38141cc0eb1df8cdb28b9b3ccd10e1c298bac78ac43bbe5804021c1152@34.142.71.5:30303\n    \n    \n    \n    enode://74a4f767ad2f3f607a2db06732b44e6c61a68cae1959b331c18aea6256aae16bded31ba40dd85dcc4d719baaeb29f918726d19fa51b5d8174b27da0d7593e19b@34.142.33.89:30303\n    \n    \n    \n    enode://0ddc30943837f9416f563063ed5d409aca37780b8b8f939ef9f4b7901b9eb94c09d7ba2af27f70b33d76e74403d00021c13ebc4943ad46bc1e5051689cd862b8@35.234.131.29:30303\n    \n    \n    \n    enode://9435658d26e5daf30261648504560f6375b24cdf0e4403613d44ebc4020489cc67ac82ababe7928d63d9f113c67b946845d18db935abe3d241e665114fc75e94@35.177.73.222:30303\n    \n    \n    \n    enode://fe2c621f2b660725a3d529b3eefd780e90bb86e9eb4b7136c0b00a7365260a478b9b8941f1a65c6d4d77bff1b2e22eb6d781f5cc86401d60b373c6d4155c189a@3.10.195.56:30304\n    \n    \n    \n    enode://6ab1e6bbf5897e1a24ccf8d8718615ec972ffd54d99c3e46f4517d5602e8bf7110e2e5e2c2e584795e45e2e842172de044b4df165a7082133c6697b632da8282@18.168.88.205:30305\n    \n    \n    config.oracle.symbols\n    [\"AUD-USD\", \"CAD-USD\", \"EUR-USD\", \"GBP-USD\", \"JPY-USD\", \"SEK-USD\", \"ATN-USD\", \"NTN-USD\", \"ATN-NTN\"]\n    \n    \n    config.oracle.votePeriod\n    30 (30 blocks)"
  },
  {
    "objectID": "networks/testnet-piccadilly/index.html#bootnodes",
    "href": "networks/testnet-piccadilly/index.html#bootnodes",
    "title": "Piccadilly Testnet",
    "section": "Bootnodes",
    "text": "Bootnodes\n    The network bootnode addresses are:\n    \n    “enode://3c7f26eb85a7fc37d5ea64c07598a28dd58f507477a88b2144179a4a162c6cba9407389d39c76386126f0604dd53141680d8075b6d210a22cc38c3a8dd877711@35.246.7.21:30303”\n    “enode://08e2ed9ca80772ce32e3b56fba3469e33a034a66780e4852586e38db657658fdc610cfb7345543a01277eb53af458ef7cac0b66570ac1982011f24d3832d782c@34.100.165.124:30303”\n    “enode://d820e4d53f1e47443c23f2db28b251ca8b8dc207a1b0a0e36ae1bbeb63d0cea4f00dabb61e5daf27468f022adc8780dfd181c57ce0db16a9668dd72e18ecac6b@159.203.156.236:30303”"
  },
  {
    "objectID": "networks/testnet-piccadilly/index.html#release",
    "href": "networks/testnet-piccadilly/index.html#release",
    "title": "Piccadilly Testnet",
    "section": "Release",
    "text": "Release\n    \n    The current iteration of the Piccadilly network is built using this Autonity Release: v0.13.0\n    The docker image release is: ghcr.io/autonity/autonity:latest"
  },
  {
    "objectID": "networks/testnet-piccadilly/index.html#faucet",
    "href": "networks/testnet-piccadilly/index.html#faucet",
    "title": "Piccadilly Testnet",
    "section": "Faucet",
    "text": "Faucet\n    \n    There is currently no faucet for auton or newton on Piccadilly. Network participants access testnet auton and newton by participating in the Piccadilly Circus Games Competition (PCGC)."
  },
  {
    "objectID": "networks/testnet-piccadilly/index.html#public-endpoints",
    "href": "networks/testnet-piccadilly/index.html#public-endpoints",
    "title": "Piccadilly Testnet",
    "section": "Public endpoints",
    "text": "Public endpoints\n    Default rate limit on calls to ws and http public endpoints combined is 250 requests per second per IP.\n    \n    RPC: https://rpc1.piccadilly.autonity.org\n    WebSocket: wss://rpc1.piccadilly.autonity.org/ws"
  },
  {
    "objectID": "networks/testnet-piccadilly/index.html#block-explorer",
    "href": "networks/testnet-piccadilly/index.html#block-explorer",
    "title": "Piccadilly Testnet",
    "section": "Block explorer",
    "text": "Block explorer\n    \n    BlockScout explorer for searching and viewing ledger data: https://piccadilly.autonity.org/"
  },
  {
    "objectID": "validators/change-commission-rate/index.html",
    "href": "validators/change-commission-rate/index.html",
    "title": "Change Validator Commission Rate",
    "section": "",
    "text": "An Autonity Go Client registered as a validator (the validator can be in a paused or an active state - see validator lifecycle).\n    A running instance of aut for submitting transactions from your account configured as described in Submit a transaction from Autonity Utility Tool (aut).\n    Your validator’s treasury account is funded with auton to pay for transaction gas costs.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    See the Validator economics section for more information on commission rate and its default setting on an Autonity Network."
  },
  {
    "objectID": "validators/change-commission-rate/index.html#prerequisites",
    "href": "validators/change-commission-rate/index.html#prerequisites",
    "title": "Change Validator Commission Rate",
    "section": "",
    "text": "An Autonity Go Client registered as a validator (the validator can be in a paused or an active state - see validator lifecycle).\n    A running instance of aut for submitting transactions from your account configured as described in Submit a transaction from Autonity Utility Tool (aut).\n    Your validator’s treasury account is funded with auton to pay for transaction gas costs.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    See the Validator economics section for more information on commission rate and its default setting on an Autonity Network."
  },
  {
    "objectID": "validators/change-commission-rate/index.html#change-validator-commission-rate",
    "href": "validators/change-commission-rate/index.html#change-validator-commission-rate",
    "title": "Change Validator Commission Rate",
    "section": "Change validator commission rate",
    "text": "Change validator commission rate\n    \n    To specify a new commission rate for a validator, use the validator command change-commission-rate. Specify:\n    \n    --validator: &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt; of the validator node you are pausing.\n    &lt;RATE&gt;: the new commission rate value. The commission rate precision is expressed in basis points as an integer value in the range 0-10000 (10000 = 100%). Specify a decimal value between 0-1 For example, 0.078 would set a commission rate of 780 bps or 7.8%.\n    \n    aut validator change-commission-rate --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt; &lt;RATE&gt; | aut tx sign - | aut tx send -\n    You will be prompted for your passphrase for the key file. Having entered the password, the transaction hash will be returned on success.\n    You should see something like beneath. In this example the validator node with identifier 0x49454f01a8F1Fbab21785a57114Ed955212006be is paused. The returned hash is 0xdbc9a2...6674d725:\n    aut validator change-commission-rate --validator 0x49454f01a8F1Fbab21785a57114Ed955212006be 0.078 | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit): \n0xdbc9a27a2f7b53d9eaa660add917ed61fe7213d1cdd826065d0e7af96674d725\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    Commission rate changes are subject to the same temporal unbonding period constraint as staking transitions. On commit of the rate change transaction, the unbonding period is tracked and the rate change is applied at the end of the epoch in which the unbonding period expires.\n    \n    \n    \n    \n    (Optional) To verify the updated rate, use the validator command info to submit a call to query for validator metadata. It will return the validator metadata from system state, including the validator status:\n    aut validator info --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt;\n    This will return a Validator object. The commission_rate property will show the new rate. You should see something like this:\n    aut validator info --validator 0x49454f01a8F1Fbab21785a57114Ed955212006be\n{\n    \"treasury\": \"0xd4EdDdE5D1D0d7129a7f9C35Ec55254f43b8E6d4\",\n    \"addr\": \"0x49454f01a8F1Fbab21785a57114Ed955212006be\",\n    \"enode\": \"enode://c746ded15b4fa7e398a8925d8a2e4c76d9fc8007eb8a6b8ad408a18bf66266b9d03dd9aa26c902a4ac02eb465d205c0c58b6f5063963fc752806f2681287a915@51.89.151.55:30304\",\n    \"commission_rate\": 780,\n    \"bonded_stake\": 0,\n    \"total_slashed\": 0,\n    \"liquid_contract\": \"0x109F93893aF4C4b0afC7A9e97B59991260F98313\",\n    \"liquid_supply\": 0,\n    \"registration_block\": 3505,\n    \"state\": 1\n}"
  },
  {
    "objectID": "validators/pause-vali/index.html",
    "href": "validators/pause-vali/index.html",
    "title": "Pause and reactivate a Validator",
    "section": "",
    "text": "An Autonity Go Client registered as a validator in an active state.\n    A running instance of aut for submitting transactions from your account configured as described in Submit a transaction from Autonity Utility Tool (aut).\n    Your validator’s validator’s treasury account is funded with auton to pay for transaction gas costs.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    See the Validator section for an explanation of the validator, a description of the validator lifecycle, and validator pausing.\n    Note that the pause and reactivation of a validator will become effective at the end of the current epoch (i.e. the epoch in which the transaction is processed). The change in validator state is applied before the committee is selected for the following epoch is selected, ensuring that the validator is either ignored (if paused) or included (if reactivated)."
  },
  {
    "objectID": "validators/pause-vali/index.html#prerequisites",
    "href": "validators/pause-vali/index.html#prerequisites",
    "title": "Pause and reactivate a Validator",
    "section": "",
    "text": "An Autonity Go Client registered as a validator in an active state.\n    A running instance of aut for submitting transactions from your account configured as described in Submit a transaction from Autonity Utility Tool (aut).\n    Your validator’s validator’s treasury account is funded with auton to pay for transaction gas costs.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    See the Validator section for an explanation of the validator, a description of the validator lifecycle, and validator pausing.\n    Note that the pause and reactivation of a validator will become effective at the end of the current epoch (i.e. the epoch in which the transaction is processed). The change in validator state is applied before the committee is selected for the following epoch is selected, ensuring that the validator is either ignored (if paused) or included (if reactivated)."
  },
  {
    "objectID": "validators/pause-vali/index.html#pause-as-a-validator",
    "href": "validators/pause-vali/index.html#pause-as-a-validator",
    "title": "Pause and reactivate a Validator",
    "section": "Pause as a validator",
    "text": "Pause as a validator\n    \n    To pause a validator from an active to a paused, inactive state, use the validator command pause. Specify:\n    \n    --validator: &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt; of the validator node you are pausing.\n    \n    aut validator pause --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt; | aut tx sign - | aut tx send -\n    You will be prompted for your passphrase for the key file. Having entered the password, the transaction hash will be returned on success.\n    You should see something like beneath. In this example the validator node with identifier 0x49454f01a8F1Fbab21785a57114Ed955212006be is paused. The returned hash is 0x942328...baec2d20:\n    aut validator pause --validator 0x49454f01a8F1Fbab21785a57114Ed955212006be | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit):\n0x942328bea54a0096ca9b2fb88acd337c883f7923c2ef6b8290a340c5baec2d20\n    (Optional) To verify the validator is paused, use the validator command info to submit a call to query for validator metadata. It will return the validator metadata from system state, including the validator status:\n    aut validator info --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt;\n    This will return a Validator object. The state property will be 1 (paused). You should see something like this:\n    aut validator info --validator 0x49454f01a8F1Fbab21785a57114Ed955212006be\n{\n    \"treasury\": \"0xd4EdDdE5D1D0d7129a7f9C35Ec55254f43b8E6d4\",\n    \"addr\": \"0x49454f01a8F1Fbab21785a57114Ed955212006be\",\n    \"enode\": \"enode://c746ded15b4fa7e398a8925d8a2e4c76d9fc8007eb8a6b8ad408a18bf66266b9d03dd9aa26c902a4ac02eb465d205c0c58b6f5063963fc752806f2681287a915@51.89.151.55:30304\",\n    \"commission_rate\": 1000,\n    \"bonded_stake\": 0,\n    \"total_slashed\": 0,\n    \"liquid_contract\": \"0x109F93893aF4C4b0afC7A9e97B59991260F98313\",\n    \"liquid_supply\": 0,\n    \"registration_block\": 3505,\n    \"state\": 1\n}"
  },
  {
    "objectID": "validators/pause-vali/index.html#re-activate-a-validator",
    "href": "validators/pause-vali/index.html#re-activate-a-validator",
    "title": "Pause and reactivate a Validator",
    "section": "Re-activate a validator",
    "text": "Re-activate a validator\n    \n    To resume a validator from an inactive state (paused or jailed) to an active state, use the validator command activate. Specify:\n    \n    --validator: &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt; of the validator node you are pausing.\n    \n    aut validator activate --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt; | aut tx sign - | aut tx send -\n    You will be prompted for your passphrase for the key file. Having entered the password, the transaction hash will be returned on success.\n    You should see something like beneath. In this example the validator node with identifier 0x49454f01a8F1Fbab21785a57114Ed955212006be is re-activated. The returned hash is 0x0849c0...f1eb2a5b:\n    aut validator activate --validator 0x49454f01a8F1Fbab21785a57114Ed955212006be | aut tx sign - | aut tx send -\n(consider using 'KEYFILEPWD' env var).\nEnter passphrase (or CTRL-d to exit):\n0x0849c0307bc446bb3fbb61b5c1518847574356aedb0b986248158d36f1eb2a5b\n    (Optional) To verify the validator is re-activated, use the validator command info to submit a call to query for validator metadata. It will return the validator metadata from system state, including the validator status:\n    aut validator info --validator &lt;VALIDATOR_IDENTIFIER_ADDRESS&gt;\n    This will return a Validator object. The state property will be 0 (active). You should see something like this:\n    aut validator info --validator 0x49454f01a8F1Fbab21785a57114Ed955212006be\n{\n    \"treasury\": \"0xd4EdDdE5D1D0d7129a7f9C35Ec55254f43b8E6d4\",\n    \"addr\": \"0x49454f01a8F1Fbab21785a57114Ed955212006be\",\n    \"enode\": \"enode://c746ded15b4fa7e398a8925d8a2e4c76d9fc8007eb8a6b8ad408a18bf66266b9d03dd9aa26c902a4ac02eb465d205c0c58b6f5063963fc752806f2681287a915@51.89.151.55:30304\",\n    \"commission_rate\": 1000,\n    \"bonded_stake\": 0,\n    \"total_slashed\": 0,\n    \"liquid_contract\": \"0x109F93893aF4C4b0afC7A9e97B59991260F98313\",\n    \"liquid_supply\": 0,\n    \"registration_block\": 3505,\n    \"state\": 0\n}"
  },
  {
    "objectID": "validators/index.html",
    "href": "validators/index.html",
    "title": "Running a Validator",
    "section": "",
    "text": "A node on the Autonity network can be registered to become a Validator, making it eligible for selection into the consensus committee to earn rewards for proposing and finalizing blocks.\n    Validator nodes participate in the oracle protocol when members of the consensus committee. Accordingly, to operate a validator node, the Autonity Oracle Server must also be installed and configured to collect data from one or more external data sources.\n    The steps here describe how to register a node as a validator and other operations related to validator node management. This guide assumes a running oracle server and a running node and connected aut."
  },
  {
    "objectID": "validators/register-vali/index.html",
    "href": "validators/register-vali/index.html",
    "title": "Register as a Validator",
    "section": "",
    "text": "To register a validator you need:\n    \n    A running instance of the Autonity Go Client running on your host machine, with networking configured to allow incoming traffic on the following ports:\n    \n    TCP, UDP 30303 for node p2p (DEVp2p) communication for transaction gossiping.\n    TCP 20203 for node p2p (DEVp2p) communication for consensus gossiping.\n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The oracle server providing price data to your validator node must be able to establish a WebSocket RPC connection to your node on TCP port 8546. If you are running your oracle server on a different host to your AGC, then you will need to allow incoming traffic on that TCP port.\n    \n    \n    \n    \n    A running instance of the Autonity Oracle Server running on your host machine, with a funded oracle server account. This will be configured to provide data price reports to your validator node’s WebSocket port.\n    A configured instance of aut.\n    An account that has been funded with auton (to pay for transaction gas costs). Note that this account will become the validator’s treasury account - the account used to manage the validator, that will also receive the validator’s share of staking rewards.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    See the Validator section for an explanation of the validator, a description of the validator lifecycle, and a description of the post-genesis registration process.\n    See the System model, Networking section for an explanation of node p2p (DEVp2p) communication for transaction and consensus gossiping.\n    See the Oracle section for an explanation of the oracle server."
  },
  {
    "objectID": "validators/register-vali/index.html#prerequisites",
    "href": "validators/register-vali/index.html#prerequisites",
    "title": "Register as a Validator",
    "section": "",
    "text": "To register a validator you need:\n    \n    A running instance of the Autonity Go Client running on your host machine, with networking configured to allow incoming traffic on the following ports:\n    \n    TCP, UDP 30303 for node p2p (DEVp2p) communication for transaction gossiping.\n    TCP 20203 for node p2p (DEVp2p) communication for consensus gossiping.\n    \n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The oracle server providing price data to your validator node must be able to establish a WebSocket RPC connection to your node on TCP port 8546. If you are running your oracle server on a different host to your AGC, then you will need to allow incoming traffic on that TCP port.\n    \n    \n    \n    \n    A running instance of the Autonity Oracle Server running on your host machine, with a funded oracle server account. This will be configured to provide data price reports to your validator node’s WebSocket port.\n    A configured instance of aut.\n    An account that has been funded with auton (to pay for transaction gas costs). Note that this account will become the validator’s treasury account - the account used to manage the validator, that will also receive the validator’s share of staking rewards.\n    \n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    See the Validator section for an explanation of the validator, a description of the validator lifecycle, and a description of the post-genesis registration process.\n    See the System model, Networking section for an explanation of node p2p (DEVp2p) communication for transaction and consensus gossiping.\n    See the Oracle section for an explanation of the oracle server."
  },
  {
    "objectID": "validators/register-vali/index.html#register-as-a-validator",
    "href": "validators/register-vali/index.html#register-as-a-validator",
    "title": "Register as a Validator",
    "section": "Register as a validator",
    "text": "Register as a validator\n    \n    Step 1. Generate a cryptographic proof of node ownership\n    This must be performed on the host machine running the Autonity Go Client, using the autonity genOwnershipProof command:\n    autonity genOwnershipProof --autonitykeys &lt;AUTONITYKEYS_PATH&gt; --oraclekey &lt;ORACLE_KEY_PATH&gt; &lt;TREASURY_ACCOUNT_ADDRESS&gt;\n    where:\n    \n    &lt;AUTONITYKEYS_PATH&gt;: path of the file containing the node’s autonitykeys. For generating your autonitykeys file see the guide Run Autonity.\n    &lt;ORACLE_KEY_PATH&gt;: is the path to the private key file of the oracle server key. (For creating this key see the guide Run Autonity Oracle Server.)\n    &lt;TREASURY_ACCOUNT_ADDRESS&gt;: is the account address you will use to operate the validator and receive commission revenue rewards to (i.e. the address you are using to submit the registration transaction from the local machine).\n    \n    You should see something like this:\n    autonity genOwnershipProof --autonitykeys ./keystore/autonityKeys --oraclekey ./keystore/oraclekey 0xf47fdd88c8f6f80239e177386cc5ae3d6bcdeeea\n\n0xad5652191c7b36608b52bdb6479c2de4b8786fb72b7be30cade15c847323ed091542e917d304d9e011892fe26006f359808f01557651607ba70542218a7d329a01a5189e8d50880faf97ad42501375b216b89304c3fd4acf548a1d7fd7136e74771791422819134e2e3fbf720c35652d8c163e3d4f22c798a3c648958f7abcda2c0089d5969f39bc6dff61ae6d90ac4074879e53daaf8857f3bc5b5cc3743725544dfa2954d0fc077a0fddc7c9b01994c96a079f5340bfec22c59e67c9687b4348913b37ed0617dd66a324b8532146c6d33a280d1c5a6425799856648c58d45c9c06\n    This signature hex will be required for the registration.\n    If you are running the Autonity Go Client in a docker container, setup as described in the guide Run Autonity as a Docker Image, the proof can be generated as follows. In this example the keys are mounted in a volume simply named keystore:\n    docker run -t -i --volume $PWD/keystore:/keystore --name autonity --rm ghcr.io/autonity/autonity:latest genOwnershipProof --autonitykeys /&lt;AUTONITYKEYS_PATH&gt; --oraclekey /&lt;ORACLE_KEY_PATH&gt; &lt;TREASURY_ACCOUNT_ADDRESS&gt;\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The genOwnershipProof command options --autonitykeys and --oraclekey options require the raw (unencrypted) private key file is passed in as argument.\n    The autonitykeys file is generated unencrypted.\n    If aut has been used to generate the oracle key, then the key has been created in encrypted file format using the Web3 Secret Storage Definition.\n    Autonity’s ethkey cmd utility can be used to inspect the oracle key file and view the account address, public key, and private key after entering your account password:\n    ./build/bin/ethkey inspect --private &lt;ORACLE_KEY_PATH&gt;/oracle.key                   \n\nPassword: \n    To install the cmd utilities use make all when building Autonity from source code.\n    \n    \n    \n    \n    \n    Step 2. Determine the validator enode and address\n    \n    Ensure that aut connects to the node that will become a validator. Query the enode using the aut node info command:\n    aut node info\n    $ aut node info\n{\n\"eth_accounts\": [],\n\"eth_blockNumber\": 113463,\n\"eth_gasPrice\": 1000000000,\n\"eth_hashrate\": 0,\n\"eth_mining\": false,\n\"eth_syncing\": false,\n\"eth_chainId\": 65000011,\n\"net_listening\": true,\n\"net_peerCount\": 0,\n\"net_networkId\": \"65100000\",\n\"web3_clientVersion\": \"Autonity/v0.13.0-rc-8b4a17c1-20240210/linux-amd64/go1.21.6\",\n\"admin_enode\": \"enode://cef6334d0855b72dadaa923ceae532550ef68e0ac50288a393eda5d811b9e81053e1324e637a202e21d04e301fe1765900bdd9f3873d58a2badf693331cb1b15@751.11.121.34:30303\",\n\"admin_id\": \"f8d35fa6019628963668e868a9f070101236476fe077f4a058c0c22e81b8a6c9\"\n}\n    The url is returned in the admin_enode field.\n    The validator address can now be computed from the enode string using aut:\n    aut validator compute-address enode://cef6334d0855b72dadaa923ceae532550ef68e0ac50288a393eda5d811b9e81053e1324e637a202e21d04e301fe1765900bdd9f3873d58a2badf693331cb1b15@751.11.121.34:30303\n    0x550454352B8e1EAD5F27Cce108EF59439B18E249\n    Make a note of the enode and validator address values.\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The validator address is a unique identifier for your validator node. Technically, it is the public key derived from the node’s P2P node key’s private key used for transaction gossiping.\n    \n    \n    \n    \n    \n    Step 3. Determine the validator consensus public key\n    To get the consensus public key of your node, inspect the autonitykeys file of your node using Autonity’s ethkey cmd utility and the `autinspect command:\n    ./build/bin/ethkey autinspect &lt;KEYFILE&gt;\n    where &lt;KEYFILE&gt; is the path to the autonitykeys file location. By default this is in the autonity subfolder of the --datadir specified when running the node.\n    Make a note of the Consensus Public Key value returned.\n    For example:\n    ./autonity/build/bin/ethkey autinspect ../autonity-chaindata/autonity/autonitykeys\n\nNode Address:           0x550454352B8e1EAD5F27Cce108EF59439B18E249\nNode Public Key:        0xcef6334d0855b72dadaa923ceae532550ef68e0ac50288a393eda5d811b9e81053e1324e637a202e21d04e301fe1765900bdd9f3873d58a2badf693331cb1b15\nConsensus Public Key:   0x1aa83a28e235072ffdae41fg01ccc46e2b8d9dc16df3b6ff87ffa5ff6d7f90a2852649a60563237cd66a256f60a92e71\n    \n    \n    Step 4. Submit the registration transaction\n    \n    \n    \n    \n    \n    \n    Note\n    \n    \n    \n    \n    \n    The commands given in this step assume that your .autrc configuration file contains a keyfile = &lt;path&gt; entry pointing to the keyfile for the treasury account used to generate the proof of node ownership above. If this is not the case, use the --keyfile option in the aut validator register and aut tx sign command below, to ensure that the registration transaction is compatible with the proof.\n    \n    \n    \n    aut validator register &lt;ENODE&gt; &lt;ORACLE&gt; &lt;CONSENSUS_KEY&gt; &lt;PROOF&gt; | aut tx sign - | aut tx send -\n    where:\n    \n    &lt;ENODE&gt;: the node’s enode url returned in Step 2.\n    &lt;ORACLE&gt;: the oracle server account address.\n    &lt;CONSENSUS_KEY&gt;: the node’s consensus public key returned in Step 3.\n    &lt;PROOF&gt;: the proof of node ownership generated in Step 1.\n    \n    Once the transaction is finalized (use aut tx wait &lt;txid&gt; to wait for it to be included in a block and return the status), the node is registered as a validator in the active state. It will become eligible for selection to the consensus committee once stake has been bonded to it.\n    \n    Troubleshooting\n    Errors of the form\n    Error: execution reverted: Invalid proof provided for registration\n    indicate a mismatch between treasury address and either:\n    \n    the from address of the transaction generated in the aut validator register command, AND/OR\n    \n    \n    \n    the key used in the aut tx sign command\n    \n    Check your configuration as described in the “Important Note” at the start of this section.\n    If you are still unable to register, verify there is not a mismatch in the treasury, oracle, enode, or consensus keys being used. You can do this using the ethkey utility for the verification steps beneath.\n    \n    \n    \n    \n    \n    \n    Verifying your ownership proof against your keys\n    \n    \n    \n    \n    \n    You can use Autonity’s ethkey cmd utility to check there is no key mismatch between the account private keys you used to generate the ownership proof with the genOwnershipProof command, and the argument data you are providing in the validator registration transaction:\n    ./build/bin/ethkey verifypop &lt;TREASURY_ADDRESS&gt; &lt;ENODE_URL&gt; &lt;ORACLE_ADDRESS&gt; &lt;CONSENSUS_PUBLIC_KEY&gt; &lt;PROOF&gt;                \n    The command verifypop will verify the ownership proof against the other argument data and print if the proof for registering a validator is valid or not. For the proof to be valid, node key, oracle key and consensus key must all return true and not false. For example:\n    ===== POP Validation Results =====\nNode Key:       true\nOracle Key:     true\nConsensus Key:  true\n    A false value indicates you have a key mismatch. For example, providing to verifypop an incorrect oracle address returns:\n    ===== POP Validation Results =====\nNode Key:       true\nOracle Key:     false\nConsensus Key:  true\n    This can be done as a pre-flight check before submitting the registration transaction to make sure you don’t have a key mismatch.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Verifying you are using the correct autonitykeys file\n    \n    \n    \n    \n    \n    You can use Autonity’s ethkey cmd utility to check there is no key mismatch between the data you are providing in the registration transaction and the autonitykeys file of the node:\n    ./build/bin/ethkey autinspect &lt;KEYFILE&gt;                \n    The command autinspect will return the Node Address, Node Public Key and Consensus Public Key of the node.\n    Referring back to the output generated in Step 3:\n    Node Address:           0x550454352B8e1EAD5F27Cce108EF59439B18E249\nNode Public Key:        0xcef6334d0855b72dadaa923ceae532550ef68e0ac50288a393eda5d811b9e81053e1324e637a202e21d04e301fe1765900bdd9f3873d58a2badf693331cb1b15\nConsensus Public Key:   0x1aa83a28e235072ffdae41fg01ccc46e2b8d9dc16df3b6ff87ffa5ff6d7f90a2852649a60563237cd66a256f60a92e71\n    Note that (a) the Node public key value minus the leading 0x marker of the HEX string is the public key component of your enode url, and, (b) the Node Address value is the validator identifier address returned in Step 2.\n    You can verify you are using the correct autonitykeys file by checking the values correspond. If they don’t, then you have an autonitykeys file mismatch.\n    \n    \n    \n    \n    \n    \n    Step 5. Confirm registration\n    Confirm that the validator has been registered by checking that its identifier (noted in Step 2) appears in the validator list:\n    aut validator list\n    0x32F3493Ef14c28419a98Ff20dE8A033cf9e6aB97\n0x31870f96212787D181B3B2771F58AF2BeD0019Aa\n0xE03D1DE3A2Fb5FEc85041655F218f18c9d4dac55\n0x52b89AFA0D1dEe274bb5e4395eE102AaFbF372EA\n0x550454352B8e1EAD5F27Cce108EF59439B18E249\n    Confirm the validator details using:\n    aut validator info --validator 0x550454352B8e1EAD5F27Cce108EF59439B18E249\n    and check that the information is as expected for your validator.\n    \n    \n    \n    \n    \n    \n    Bond stake to your validator\n    \n    \n    \n    \n    \n    To self-bond stake to your validator node, submit a bond transaction from the account used to submit the registration transaction - i.e. the validator’s treasury account address. For how to do this see the how to Bond stake."
  }
]